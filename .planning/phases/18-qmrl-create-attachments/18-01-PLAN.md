---
phase: 18-qmrl-create-attachments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/hooks/use-staged-files.ts
  - components/files/file-dropzone-preview.tsx
  - app/(dashboard)/qmrl/new/page.tsx
  - app/(dashboard)/qmrl/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User sees file upload area in QMRL create form"
    - "User can select and preview files before submitting form"
    - "Files are uploaded and linked to QMRL after entity creation succeeds"
    - "Failed file uploads do not block QMRL creation (graceful degradation)"
  artifacts:
    - path: "lib/hooks/use-staged-files.ts"
      provides: "StagedFile type and useStagedFiles hook for managing file state"
      exports: ["StagedFile", "useStagedFiles"]
      min_lines: 40
    - path: "components/files/file-dropzone-preview.tsx"
      provides: "Dropzone with preview grid and remove functionality"
      exports: ["FileDropzonePreview"]
      min_lines: 80
    - path: "app/(dashboard)/qmrl/new/page.tsx"
      provides: "QMRL create form with file upload section"
      contains: "FileDropzonePreview"
    - path: "app/(dashboard)/qmrl/[id]/page.tsx"
      provides: "QMRL detail page with upload status toast"
      contains: "pending-uploads"
  key_links:
    - from: "app/(dashboard)/qmrl/new/page.tsx"
      to: "lib/hooks/use-staged-files.ts"
      via: "useStagedFiles hook"
      pattern: "useStagedFiles"
    - from: "app/(dashboard)/qmrl/new/page.tsx"
      to: "components/files/file-dropzone-preview.tsx"
      via: "FileDropzonePreview component"
      pattern: "FileDropzonePreview"
    - from: "app/(dashboard)/qmrl/new/page.tsx"
      to: "lib/actions/files.ts"
      via: "uploadFile server action after QMRL creation"
      pattern: "uploadFile"
    - from: "app/(dashboard)/qmrl/[id]/page.tsx"
      to: "sessionStorage"
      via: "pending-uploads check on mount"
      pattern: "pending-uploads"
---

<objective>
Enable file uploads during QMRL creation using the Upload-After-Create pattern.

Purpose: Users need to attach supporting documents when creating a request letter, but the existing upload infrastructure requires an entity ID. This plan implements file staging (hold in React state) during form editing, then uploads sequentially after QMRL creation succeeds.

Output:
- `useStagedFiles` hook for managing pending files with memory-safe preview URLs
- `FileDropzonePreview` component with drag-drop, preview grid, and remove functionality
- Modified QMRL create page with Attachments section
- Modified QMRL detail page to show upload status toast on redirect
</objective>

<execution_context>
@/Users/thihaaung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thihaaung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-qmrl-create-attachments/18-RESEARCH.md

# Existing file upload infrastructure
@lib/hooks/use-file-upload.ts
@lib/actions/files.ts
@lib/utils/file-validation.ts
@components/files/file-dropzone.tsx

# Pages to modify
@app/(dashboard)/qmrl/new/page.tsx
@app/(dashboard)/qmrl/[id]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useStagedFiles hook and StagedFile type</name>
  <files>lib/hooks/use-staged-files.ts</files>
  <action>
Create a new hook for managing files staged for upload (before entity exists).

**StagedFile interface:**
```typescript
export interface StagedFile {
  id: string;           // crypto.randomUUID() for React key
  file: File;           // The actual File object
  previewUrl?: string;  // Blob URL for image preview (undefined for non-images)
}
```

**useStagedFiles hook returns:**
- `files: StagedFile[]` - Current staged files
- `addFiles(files: File[]): void` - Add files with auto-generated preview URLs for images
- `removeFile(id: string): void` - Remove file and revoke its preview URL
- `clearFiles(): void` - Clear all files and revoke all preview URLs
- `getFilesForUpload(): File[]` - Get raw File objects for upload

**Implementation requirements:**
1. Generate preview URL using `URL.createObjectURL(file)` ONLY for files where `file.type.startsWith('image/')`
2. In `removeFile`, call `URL.revokeObjectURL(previewUrl)` before removing from state
3. In `clearFiles`, revoke ALL preview URLs before clearing state
4. Add cleanup effect that revokes all URLs on unmount (empty deps array - only on unmount)
5. Follow existing hook patterns from `use-file-upload.ts`

**Memory management is critical:** Blob URLs persist until explicitly revoked. Always revoke in removeFile, clearFiles, and unmount cleanup.
  </action>
  <verify>
1. TypeScript compiles without errors: `npm run type-check`
2. File exists at lib/hooks/use-staged-files.ts
3. Exports StagedFile interface and useStagedFiles function
  </verify>
  <done>
- useStagedFiles hook created with proper memory management
- StagedFile type exported for use in components
- Preview URLs generated for images only
- All blob URLs properly revoked on removal, clear, and unmount
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileDropzonePreview component</name>
  <files>components/files/file-dropzone-preview.tsx</files>
  <action>
Create a component that combines the dropzone with a preview grid for staged files.

**Props interface:**
```typescript
interface FileDropzonePreviewProps {
  files: StagedFile[];
  onFilesAdd: (files: File[]) => void;
  onFileRemove: (id: string) => void;
  disabled?: boolean;
}
```

**Structure:**
1. **Dropzone area** (top) - Reuse dropzone logic from existing `file-dropzone.tsx`:
   - Use `useDropzone` from react-dropzone
   - Same accept/maxSize config (images, PDFs, Office docs; 25MB)
   - Same visual states (idle, drag active, drag reject)
   - Call `onFilesAdd` with accepted files
   - Show toast for rejected files

2. **Preview grid** (below dropzone, only when files.length > 0):
   - 4-column grid: `grid grid-cols-4 gap-3`
   - Each file card has:
     - Thumbnail area (h-20): Image preview OR extension badge
     - For images: `<img src={previewUrl} className="h-full w-full object-cover" />`
     - For non-images: Colored badge showing extension (use EXTENSION_COLORS map)
     - File info: filename (truncated), size (use `formatFileSize`)
     - Remove button: X icon, absolute positioned top-right, `onClick={() => onFileRemove(id)}`

**Extension colors map (match existing patterns):**
```typescript
const EXTENSION_COLORS: Record<string, { bg: string; text: string }> = {
  '.pdf': { bg: 'bg-red-500/20', text: 'text-red-400' },
  '.doc': { bg: 'bg-blue-500/20', text: 'text-blue-400' },
  '.docx': { bg: 'bg-blue-500/20', text: 'text-blue-400' },
  '.xls': { bg: 'bg-emerald-500/20', text: 'text-emerald-400' },
  '.xlsx': { bg: 'bg-emerald-500/20', text: 'text-emerald-400' },
  '.ppt': { bg: 'bg-orange-500/20', text: 'text-orange-400' },
  '.pptx': { bg: 'bg-orange-500/20', text: 'text-orange-400' },
};
// Default: { bg: 'bg-slate-500/20', text: 'text-slate-400' }
```

**Styling:**
- Match existing command-panel/slate theme
- Card: `rounded-lg border border-slate-700 bg-slate-800/50 overflow-hidden`
- Remove button: `absolute top-1 right-1 p-1 rounded bg-slate-800/80 hover:bg-red-500/80`
- Use `cn()` for conditional classes
- Import icons from lucide-react (Upload, X, AlertCircle)
  </action>
  <verify>
1. TypeScript compiles without errors: `npm run type-check`
2. File exists at components/files/file-dropzone-preview.tsx
3. Component exports FileDropzonePreview
4. Uses existing file-validation utilities (formatFileSize, getFileExtension, etc.)
  </verify>
  <done>
- FileDropzonePreview component created with dropzone + preview grid
- Images show actual thumbnails, non-images show extension badges
- Remove button on each file card works
- Matches existing slate/amber theme
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate file upload into QMRL create flow</name>
  <files>
    app/(dashboard)/qmrl/new/page.tsx
    app/(dashboard)/qmrl/[id]/page.tsx
  </files>
  <action>
**Part A: Modify QMRL create page (`app/(dashboard)/qmrl/new/page.tsx`)**

1. **Add imports:**
```typescript
import { useStagedFiles } from "@/lib/hooks/use-staged-files";
import { FileDropzonePreview } from "@/components/files/file-dropzone-preview";
import { uploadFile } from "@/lib/actions/files";
import { Paperclip } from "lucide-react";
```

2. **Add staged files state** (inside component):
```typescript
const { files: stagedFiles, addFiles, removeFile, clearFiles, getFilesForUpload } = useStagedFiles();
```

3. **Add new section "Attachments"** after the "Description & Notes" section:
```tsx
{/* Section 5: Attachments */}
<div className="command-panel corner-accents animate-slide-up" style={{ animationDelay: "500ms" }}>
  <div className="section-header">
    <Paperclip className="h-4 w-4 text-amber-500" />
    <h2>Attachments</h2>
    {stagedFiles.length > 0 && (
      <span className="ml-auto text-xs text-slate-400">
        {stagedFiles.length} file{stagedFiles.length !== 1 ? 's' : ''} selected
      </span>
    )}
  </div>

  <FileDropzonePreview
    files={stagedFiles}
    onFilesAdd={addFiles}
    onFileRemove={removeFile}
    disabled={isSubmitting}
  />
  <p className="text-xs text-slate-400 mt-2">
    Files will be uploaded after the request is created
  </p>
</div>
```

4. **Modify handleSubmit** to upload files after QMRL creation:
```typescript
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  // ... existing validation ...

  setIsSubmitting(true);
  const supabase = createClient();

  // ... existing insert logic ...

  const { data, error } = await supabase
    .from("qmrl")
    .insert(insertData)
    .select()
    .single();

  if (error) {
    // ... existing error handling ...
    setIsSubmitting(false);
    return;
  }

  // Upload staged files (non-blocking, graceful degradation)
  const filesToUpload = getFilesForUpload();
  if (filesToUpload.length > 0) {
    // Store intent for feedback on detail page
    sessionStorage.setItem(`pending-uploads-${data.id}`, JSON.stringify({
      total: filesToUpload.length,
      completed: 0,
      failed: 0,
    }));

    // Start uploads in background (don't await)
    uploadStagedFilesSequentially(filesToUpload, data.id);
  }

  toast({
    title: "Success",
    description: "Request letter created successfully.",
    variant: "success",
  });

  router.push(`/qmrl/${data.id}`);
};

// Add helper function outside component or inside with useCallback
async function uploadStagedFilesSequentially(files: File[], entityId: string) {
  let completed = 0;
  let failed = 0;

  for (const file of files) {
    try {
      const formData = new FormData();
      formData.append('file', file);
      const result = await uploadFile(formData, 'qmrl', entityId);

      if (result.success) {
        completed++;
      } else {
        failed++;
        console.error(`Upload failed for ${file.name}:`, result.error);
      }
    } catch (error) {
      failed++;
      console.error(`Upload error for ${file.name}:`, error);
    }
  }

  // Update sessionStorage with final status (detail page will read this)
  sessionStorage.setItem(`pending-uploads-${entityId}`, JSON.stringify({
    total: files.length,
    completed,
    failed,
  }));
}
```

5. **Update action buttons animationDelay** to "600ms" (shifted from 500ms)

**Part B: Modify QMRL detail page (`app/(dashboard)/qmrl/[id]/page.tsx`)**

Add upload status toast on page load. Add this useEffect after the existing useEffects:

```typescript
// Check for pending upload status from create page
useEffect(() => {
  if (!qmrl?.id) return;

  const checkPendingUploads = () => {
    const pendingKey = `pending-uploads-${qmrl.id}`;
    const pending = sessionStorage.getItem(pendingKey);

    if (pending) {
      try {
        const { total, completed, failed } = JSON.parse(pending);
        sessionStorage.removeItem(pendingKey);

        if (failed > 0) {
          toast({
            title: "Some files failed to upload",
            description: `${completed} of ${total} file${total !== 1 ? 's' : ''} uploaded successfully. You can retry from the Attachments tab.`,
            variant: "warning",
          });
        } else if (completed > 0 && completed === total) {
          toast({
            title: "Files uploaded",
            description: `${completed} file${completed !== 1 ? 's' : ''} attached successfully.`,
            variant: "success",
          });
        }

        // Refresh file count
        fetchQmrl();
      } catch (e) {
        sessionStorage.removeItem(pendingKey);
      }
    }
  };

  // Check immediately and after a delay (uploads may still be in progress)
  checkPendingUploads();
  const timer = setTimeout(checkPendingUploads, 3000);

  return () => clearTimeout(timer);
}, [qmrl?.id]);
```

Note: The detail page already imports `toast` from `@/components/ui/use-toast` and has access to `qmrl.id`. The existing `fetchQmrl` function can be used to refresh data.
  </action>
  <verify>
1. TypeScript compiles without errors: `npm run type-check`
2. Build succeeds: `npm run build`
3. QMRL create page has Attachments section with FileDropzonePreview
4. QMRL detail page has pending-uploads check in useEffect
  </verify>
  <done>
- QMRL create page has Attachments section with drag-drop file selection
- Files are staged in React state during form editing
- After QMRL creation, files upload sequentially in background
- Navigation to detail page happens immediately (non-blocking uploads)
- Detail page shows toast with upload results (success, partial, or failure)
- TypeScript and build pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type check:** `npm run type-check` passes
2. **Build:** `npm run build` succeeds
3. **Manual verification flow:**
   - Navigate to /qmrl/new
   - Verify Attachments section visible below Description & Notes
   - Drag a PDF and an image into the dropzone
   - Verify PDF shows extension badge, image shows thumbnail preview
   - Click X on one file to remove it
   - Fill required fields (title, contact person)
   - Submit form
   - Verify redirect to detail page
   - Verify toast shows upload status
   - Navigate to Attachments tab to confirm files are present
</verification>

<success_criteria>
1. User sees file upload area in QMRL create form (Attachments section with dropzone)
2. User can select and preview files before submitting form (images show thumbnails, others show badges)
3. Files are uploaded and linked to QMRL after entity creation succeeds (sequential upload after insert)
4. Failed file uploads do not block QMRL creation (graceful degradation - navigate immediately, toast results)
</success_criteria>

<output>
After completion, create `.planning/phases/18-qmrl-create-attachments/18-01-SUMMARY.md`
</output>
