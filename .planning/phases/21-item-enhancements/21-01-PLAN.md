---
phase: 21-item-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/049_item_sku_price_reference.sql
  - components/ui/tooltip.tsx
  - types/database.ts
autonomous: true

must_haves:
  truths:
    - "Items table has price_reference column with 100 char limit"
    - "SKU codes are generated in SKU-[CAT]-[XXXX] format on item save"
    - "Category abbreviation extracts first letter of each word uppercase"
    - "Existing items have backfilled SKU codes in new format"
    - "Tooltip component exists and can display content on hover"
  artifacts:
    - path: "supabase/migrations/049_item_sku_price_reference.sql"
      provides: "Database schema extension, SKU trigger, backfill"
      contains: "generate_item_sku_v2"
    - path: "components/ui/tooltip.tsx"
      provides: "Radix tooltip wrapper component"
      exports: ["Tooltip", "TooltipContent", "TooltipProvider", "TooltipTrigger"]
    - path: "types/database.ts"
      provides: "Updated Item type with price_reference"
      contains: "price_reference"
  key_links:
    - from: "items table"
      to: "categories table"
      via: "get_category_abbreviation function"
      pattern: "get_category_abbreviation\\(c\\.name\\)"
    - from: "generate_item_sku_v2 trigger"
      to: "items.sku column"
      via: "BEFORE INSERT OR UPDATE trigger"
      pattern: "NEW\\.sku := 'SKU-'"
---

<objective>
Add database foundation for item price reference and SKU code generation, plus create Tooltip UI component.

Purpose: Enable items to have price reference notes for purchasing context and auto-generated SKU codes based on category. The tooltip component will be used in Plan 02 to display price references in PO line item selector.

Output:
- Database migration with price_reference column, SKU generation functions/trigger, and backfill
- Radix UI tooltip wrapper component
- Updated TypeScript types
</objective>

<execution_context>
@/Users/thihaaung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thihaaung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-item-enhancements/21-CONTEXT.md
@.planning/phases/21-item-enhancements/21-RESEARCH.md
@supabase/migrations/007_items.sql
@supabase/migrations/017_item_categories.sql
@types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for price reference and SKU generation</name>
  <files>supabase/migrations/049_item_sku_price_reference.sql</files>
  <action>
Create a single migration file that:

1. **Add price_reference column to items table:**
   ```sql
   ALTER TABLE items ADD COLUMN IF NOT EXISTS price_reference TEXT;
   ALTER TABLE items ADD CONSTRAINT items_price_reference_length
     CHECK (char_length(price_reference) <= 100);
   ```
   Note: NOT NULL constraint is NOT added - existing items can remain without reference until edited.

2. **Create get_category_abbreviation() function:**
   - Extract first letter of each word, uppercase
   - "Office Supplies" -> "OS", "Equipment" -> "E"
   - Return 'UNK' if input is NULL or empty
   ```sql
   CREATE OR REPLACE FUNCTION get_category_abbreviation(category_name TEXT)
   RETURNS TEXT AS $$
   BEGIN
     IF category_name IS NULL OR category_name = '' THEN
       RETURN 'UNK';
     END IF;
     RETURN UPPER(
       array_to_string(
         ARRAY(
           SELECT substring(word, 1, 1)
           FROM regexp_split_to_table(category_name, '\s+') AS word
           WHERE word != ''
         ),
         ''
       )
     );
   END;
   $$ LANGUAGE plpgsql IMMUTABLE;
   ```

3. **Create generate_random_suffix() function:**
   - Generate 4-character random alphanumeric (A-Z, 0-9 only)
   ```sql
   CREATE OR REPLACE FUNCTION generate_random_suffix(length INT DEFAULT 4)
   RETURNS TEXT AS $$
   DECLARE
     chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
     result TEXT := '';
     i INT;
   BEGIN
     FOR i IN 1..length LOOP
       result := result || substr(chars, floor(random() * 36 + 1)::INT, 1);
     END LOOP;
     RETURN result;
   END;
   $$ LANGUAGE plpgsql VOLATILE;
   ```

4. **Drop existing SKU trigger and create new generate_item_sku_v2():**
   - Drop the old `generate_item_sku_trigger` and `generate_item_sku` function
   - Create new trigger function that:
     - On INSERT: Generate SKU as 'SKU-' + category_abbr + '-' + random_suffix
     - On UPDATE with category change: Keep random suffix, update category portion only
     - Collision handling: Retry up to 10 times with new random
   ```sql
   DROP TRIGGER IF EXISTS generate_item_sku_trigger ON items;
   DROP FUNCTION IF EXISTS generate_item_sku();

   CREATE OR REPLACE FUNCTION generate_item_sku_v2()
   RETURNS TRIGGER AS $$
   DECLARE
     cat_abbr TEXT;
     rand_suffix TEXT;
     new_sku TEXT;
     attempt INT := 0;
     max_attempts INT := 10;
   BEGIN
     -- Only generate/update SKU on INSERT or when category changes
     IF TG_OP = 'INSERT' OR
        (TG_OP = 'UPDATE' AND OLD.category_id IS DISTINCT FROM NEW.category_id) THEN

       -- Get category abbreviation
       SELECT get_category_abbreviation(c.name) INTO cat_abbr
       FROM categories c WHERE c.id = NEW.category_id;

       cat_abbr := COALESCE(cat_abbr, 'UNK');

       -- For UPDATE: keep existing suffix, only update category portion
       IF TG_OP = 'UPDATE' AND OLD.sku IS NOT NULL THEN
         rand_suffix := substring(OLD.sku FROM '[A-Z0-9]{4}$');
         IF rand_suffix IS NOT NULL AND length(rand_suffix) = 4 THEN
           NEW.sku := 'SKU-' || cat_abbr || '-' || rand_suffix;
           RETURN NEW;
         END IF;
       END IF;

       -- For INSERT or UPDATE without valid suffix: generate new random
       LOOP
         rand_suffix := generate_random_suffix(4);
         new_sku := 'SKU-' || cat_abbr || '-' || rand_suffix;

         -- Check for collision
         IF NOT EXISTS (SELECT 1 FROM items WHERE sku = new_sku AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)) THEN
           NEW.sku := new_sku;
           EXIT;
         END IF;

         attempt := attempt + 1;
         IF attempt >= max_attempts THEN
           RAISE EXCEPTION 'Failed to generate unique SKU after % attempts', max_attempts;
         END IF;
       END LOOP;
     END IF;

     RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;

   CREATE TRIGGER generate_item_sku_v2_trigger
     BEFORE INSERT OR UPDATE ON items
     FOR EACH ROW
     EXECUTE FUNCTION generate_item_sku_v2();
   ```

5. **Backfill existing items with new SKU format:**
   - Use DO block to iterate through all active items
   - Generate new SKU for each (overwrite existing)
   - Handle uncategorized items with 'UNK' abbreviation
   ```sql
   DO $$
   DECLARE
     item_rec RECORD;
     cat_abbr TEXT;
     rand_suffix TEXT;
     new_sku TEXT;
     attempt INT;
     max_attempts INT := 10;
   BEGIN
     FOR item_rec IN SELECT i.id, i.category_id, c.name as category_name
                     FROM items i
                     LEFT JOIN categories c ON c.id = i.category_id
                     WHERE i.is_active = true
     LOOP
       cat_abbr := COALESCE(
         get_category_abbreviation(item_rec.category_name),
         'UNK'
       );

       attempt := 0;
       LOOP
         rand_suffix := generate_random_suffix(4);
         new_sku := 'SKU-' || cat_abbr || '-' || rand_suffix;

         IF NOT EXISTS (SELECT 1 FROM items WHERE sku = new_sku) THEN
           UPDATE items SET sku = new_sku WHERE id = item_rec.id;
           EXIT;
         END IF;

         attempt := attempt + 1;
         IF attempt >= max_attempts THEN
           -- Fallback: append item ID snippet
           new_sku := 'SKU-' || cat_abbr || '-' || upper(substring(item_rec.id::text, 1, 4));
           UPDATE items SET sku = new_sku WHERE id = item_rec.id;
           EXIT;
         END IF;
       END LOOP;
     END LOOP;
   END $$;
   ```

6. **Add comment for documentation:**
   ```sql
   COMMENT ON COLUMN items.price_reference IS 'Price reference note for purchasing context (max 100 chars)';
   COMMENT ON FUNCTION get_category_abbreviation(TEXT) IS 'Extract first letter of each word as uppercase abbreviation';
   COMMENT ON FUNCTION generate_random_suffix(INT) IS 'Generate random alphanumeric string (A-Z, 0-9)';
   ```
  </action>
  <verify>
Run: `npx supabase db reset` (or apply migration manually)
Then verify:
- `SELECT column_name FROM information_schema.columns WHERE table_name = 'items' AND column_name = 'price_reference';` returns 1 row
- `SELECT get_category_abbreviation('Office Supplies');` returns 'OS'
- `SELECT get_category_abbreviation('Equipment');` returns 'E'
- `SELECT sku FROM items LIMIT 5;` shows SKU-XXX-YYYY format
  </verify>
  <done>
- price_reference column exists on items table with 100 char constraint
- SKU trigger generates codes in SKU-[CAT]-[XXXX] format
- All existing items have backfilled SKU codes in new format
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Tooltip UI component</name>
  <files>components/ui/tooltip.tsx</files>
  <action>
Create a Radix UI tooltip wrapper component following project conventions.

Use the existing Radix UI library (@radix-ui/react-tooltip ^1.1.3 already installed).

```tsx
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-slate-800 px-3 py-1.5 text-xs text-slate-200",
      "border border-slate-700 shadow-md",
      "animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
      "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      "max-w-xs",
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
```

Key styling decisions:
- Dark theme (bg-slate-800, border-slate-700, text-slate-200) to match project
- max-w-xs to prevent overflow on long price references
- Standard animation classes for smooth appearance
- Side-aware slide animations
  </action>
  <verify>
Run: `npm run type-check`
Verify: No TypeScript errors related to tooltip component
  </verify>
  <done>
- Tooltip component exists at components/ui/tooltip.tsx
- Exports TooltipProvider, Tooltip, TooltipTrigger, TooltipContent
- Styled consistently with project dark theme
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TypeScript types for Item</name>
  <files>types/database.ts</files>
  <action>
Update the items table type definition to include the new price_reference column.

Find the `items:` section in the Tables object and add `price_reference` to Row, Insert, and Update:

**In Row (around line 225-243):**
Add after `photo_url`:
```typescript
price_reference: string | null
```

**In Insert (around line 244-262):**
Add after `photo_url`:
```typescript
price_reference?: string | null
```

**In Update (around line 263-275):**
Add after `photo_url`:
```typescript
price_reference?: string | null
```

The Item type is already exported as `export type Item = Tables<"items">` so it will automatically include the new field.
  </action>
  <verify>
Run: `npm run type-check`
Verify: No TypeScript errors
Verify: In VS Code, hover over `Item` type shows `price_reference: string | null`
  </verify>
  <done>
- Item type includes price_reference field
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. Database migration applies without errors: `npx supabase db reset` succeeds
2. Verify SKU format: `SELECT sku FROM items LIMIT 10;` shows all SKU-XXX-YYYY format
3. Verify category abbreviation: `SELECT get_category_abbreviation('Office Supplies');` returns 'OS'
4. Verify tooltip component exists and exports correctly
5. TypeScript compiles: `npm run type-check` passes
</verification>

<success_criteria>
1. items table has price_reference column with CHECK constraint for 100 char max
2. generate_item_sku_v2 trigger creates SKU codes in SKU-[CAT]-[XXXX] format
3. All existing items have backfilled SKU codes in new format
4. Category abbreviation function extracts first letters correctly
5. Tooltip component exports TooltipProvider, Tooltip, TooltipTrigger, TooltipContent
6. TypeScript types updated with price_reference field
</success_criteria>

<output>
After completion, create `.planning/phases/21-item-enhancements/21-01-SUMMARY.md`
</output>
