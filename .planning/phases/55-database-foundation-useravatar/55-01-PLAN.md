---
phase: 55-database-foundation-useravatar
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260217100000_two_layer_approval_schema.sql
  - types/database.ts
autonomous: true
requirements:
  - APPR-06

must_haves:
  truths:
    - "stock_out_approvals table has layer TEXT column with CHECK constraint allowing 'quartermaster' and 'admin'"
    - "stock_out_approvals table has parent_approval_id UUID column referencing itself"
    - "stock_out_approvals table has warehouse_id UUID column referencing warehouses(id)"
    - "sor_line_item_status enum includes 'awaiting_admin' and 'fully_approved' values"
    - "All existing approved stock_out_approvals records have layer='admin' (backfill complete)"
    - "All existing stock_out_line_items with status='approved' now have status='fully_approved' (backfill complete)"
    - "validate_sor_line_item_status_transition allows pending->awaiting_admin, awaiting_admin->fully_approved, fully_approved->partially_executed->executed transitions"
    - "update_line_item_status_on_approval transitions pending->awaiting_admin on L1 approval, awaiting_admin->fully_approved on L2 approval"
    - "validate_sor_fulfillment requires layer='admin' AND decision='approved' before allowing execution"
    - "compute_sor_request_status counts awaiting_admin and fully_approved line item statuses"
    - "TypeScript types for stock_out_approvals include layer, parent_approval_id, and warehouse_id fields"
  artifacts:
    - path: "supabase/migrations/20260217100000_two_layer_approval_schema.sql"
      provides: "Two-layer approval schema migration with enum extension, column additions, trigger rewrites, and data backfill"
    - path: "types/database.ts"
      provides: "Updated TypeScript types matching new database schema"
  key_links:
    - from: "validate_sor_approval()"
      to: "stock_out_approvals.layer"
      via: "Layer-aware validation: L1 checks total stock, L2 checks warehouse stock + L1 qty cap"
    - from: "update_line_item_status_on_approval()"
      to: "stock_out_line_items.status"
      via: "L1 approval -> awaiting_admin, L2 approval -> fully_approved"
    - from: "validate_sor_fulfillment()"
      to: "stock_out_approvals.layer"
      via: "Only layer='admin' approvals can be executed"
---

<objective>
Create migration 063 that extends the stock-out approval schema for two-layer approval workflow and update TypeScript types to match.

Purpose: The two-layer approval schema (L1 quartermaster qty approval, L2 admin warehouse assignment) is the database foundation that phases 56, 57, and 58 all depend on. Without this migration, no approval UI changes can proceed.

Output: A single atomic migration file and updated TypeScript type definitions.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-database-foundation-useravatar/55-RESEARCH.md

# Source migrations to understand current schema and trigger functions:
@supabase/migrations/052_stock_out_requests.sql
@supabase/migrations/053_stock_out_validation.sql
@supabase/migrations/058_advisory_lock_stock_validation.sql
@supabase/migrations/059_row_lock_status_aggregation.sql
@supabase/migrations/20260211103947_fix_line_item_status_rejection_qty.sql
@types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create two-layer approval database migration</name>
  <files>supabase/migrations/20260217100000_two_layer_approval_schema.sql</files>
  <action>
Create migration file `supabase/migrations/20260217100000_two_layer_approval_schema.sql` with the following structure. This is a complex migration — follow the exact ordering below to avoid pitfalls.

**STEP 1: ENUM EXTENSION (outside transaction block)**

Add two new values to `sor_line_item_status` enum using `ALTER TYPE ... ADD VALUE IF NOT EXISTS` (project pattern from migration 017). These MUST run before any `BEGIN;` block — PostgreSQL prohibits ADD VALUE inside a transaction when the type has existing data.

```sql
ALTER TYPE public.sor_line_item_status ADD VALUE IF NOT EXISTS 'awaiting_admin';
ALTER TYPE public.sor_line_item_status ADD VALUE IF NOT EXISTS 'fully_approved';
```

**STEP 2: SCHEMA CHANGES (inside BEGIN/COMMIT transaction)**

Add three columns to `stock_out_approvals`:

1. `layer TEXT CHECK (layer IN ('quartermaster', 'admin'))` — nullable (NULL for rejected records is acceptable per Claude's discretion on rejected backfill handling). Layer 1 = quartermaster (qty approval), Layer 2 = admin (warehouse assignment).

2. `parent_approval_id UUID REFERENCES stock_out_approvals(id) ON DELETE SET NULL` — L2 approvals link to their L1 parent. NULL for L1 approvals.

3. `warehouse_id UUID REFERENCES warehouses(id) ON DELETE RESTRICT` — nullable for L1 approvals, required for L2 approvals. This column is needed by the Layer 2 trigger validation (stock cap check) and by Phase 57 UI. Per research open question #1: must be in migration 063 even though UI captures it in Phase 57.

Add indexes:
- `idx_sor_approval_layer ON stock_out_approvals(layer)`
- `idx_sor_approval_parent ON stock_out_approvals(parent_approval_id) WHERE parent_approval_id IS NOT NULL`
- `idx_sor_approval_warehouse ON stock_out_approvals(warehouse_id) WHERE warehouse_id IS NOT NULL`

Add comments on new columns explaining their purpose.

**STEP 3: TRIGGER FUNCTION REWRITES (inside same transaction, BEFORE backfill)**

Rewrite these 5 trigger functions using `CREATE OR REPLACE FUNCTION`. The order matters — `validate_sor_line_item_status_transition` must be rewritten FIRST because the backfill UPDATE changes status from 'approved' to 'fully_approved', which the old transition guard would block.

**3a. `validate_sor_line_item_status_transition()`**

New allowed transitions:
- `pending` -> `awaiting_admin` (L1 approval)
- `pending` -> `rejected` (L1 rejection)
- `pending` -> `cancelled` (cancellation)
- `awaiting_admin` -> `fully_approved` (L2 approval/assignment)
- `fully_approved` -> `partially_executed` -> `executed` (execution flow)
- `approved` -> `fully_approved` (backfill transition — allows migration to update legacy records)
- `approved` -> `partially_executed` -> `executed` (legacy records that were already in execution)

Block:
- `pending` -> `approved` (old direct path, no longer valid for new records)
- `rejected` -> anything (terminal)
- `cancelled` -> anything (terminal)
- `executed` -> anything (terminal)

Implementation approach: Use an explicit allowed-transitions pattern. Define a CASE on OLD.status, list allowed NEW.status values for each, RAISE EXCEPTION for everything else.

**3b. `validate_sor_approval()`**

Rewrite to be layer-aware. The function receives the INSERT on `stock_out_approvals`.

For ALL approvals:
- Set `NEW.layer` automatically: if `NEW.parent_approval_id IS NULL` then `NEW.layer = 'quartermaster'`; else `NEW.layer = 'admin'`.
- This auto-sets the layer so callers don't need to manually specify it.

For L1 (quartermaster) approvals (`NEW.layer = 'quartermaster'`):
- Validate `approved_quantity` does not exceed remaining requested quantity (existing logic).
- If `decision = 'approved'`: validate total stock availability using `get_total_item_stock(li_item_id)` (existing logic, advisory lock on item_id).
- If `decision = 'rejected'`: set `NEW.layer = 'quartermaster'` (already set above), require rejection_reason (existing constraint handles this).
- `NEW.warehouse_id` must be NULL for L1.

For L2 (admin) approvals (`NEW.layer = 'admin'`):
- `NEW.decision` must be `'approved'` (L2 has no reject option — locked decision).
- Validate `parent_approval_id` points to an existing L1 approval with `decision = 'approved'` and `layer = 'quartermaster'`.
- Get L1 parent's `approved_quantity`. L2 `approved_quantity` must not exceed L1 parent's `approved_quantity`.
- `NEW.warehouse_id` must NOT be NULL for L2 (it's a warehouse assignment).
- Validate warehouse stock: acquire advisory lock on `hashtext(NEW.item_id::text || NEW.warehouse_id::text)`, then check `get_warehouse_stock(li_item_id, NEW.warehouse_id)` >= `NEW.approved_quantity`.

**3c. `update_line_item_status_on_approval()`**

Rewrite to handle the two-layer flow. Fires AFTER INSERT on `stock_out_approvals`.

When L1 (quartermaster) approval is inserted:
- If `decision = 'approved'`: calculate total L1 approved qty for this line item. If `total_l1_approved >= requested_quantity`, transition line item status from `pending` to `awaiting_admin`.
- If `decision = 'rejected'`: calculate total L1 rejected qty. If `total_l1_rejected >= requested_quantity` AND `total_l1_approved = 0`, transition to `rejected`.
- Otherwise: stay `pending` (partial decisions, more remaining).

When L2 (admin) approval is inserted:
- L2 is always `decision = 'approved'`. Transition line item status from `awaiting_admin` to `fully_approved`.

**3d. `validate_sor_fulfillment()`**

Update the existing advisory-lock-protected function. Change the approval validation check:
- Old: `approval_decision != 'approved'` raises exception.
- New: Must check BOTH `approval_decision = 'approved'` AND `approval_layer = 'admin'`. Only L2 (admin) approvals can be executed.
- Add `approval_layer TEXT` variable. SELECT layer in addition to approved_quantity and decision.
- Error message: 'Cannot fulfill: only Layer 2 (admin) approved stock-out approvals can be executed'.

**3e. `compute_sor_request_status()`**

Update the status aggregation function. Add counts for new statuses:
- Add `awaiting_admin_count` and `fully_approved_count` variables.
- Count `awaiting_admin` and `fully_approved` in the FILTER clauses.
- Status mapping logic update:
  - All items `fully_approved` (and none pending/awaiting_admin) -> parent status `'approved'` (execution ready)
  - All items `approved` (legacy backfilled) -> parent status `'approved'` (backward compat)
  - Mix of `awaiting_admin` + `fully_approved` + approved -> `'partially_approved'`
  - Any `awaiting_admin` with no pending -> `'partially_approved'`
  - Existing execution/rejection/cancellation logic stays the same.
- Keep the existing row-level lock pattern (`SELECT ... FOR UPDATE` on parent request).

**3f. `update_sor_line_item_execution_status()`**

Update to recognize `fully_approved` in addition to `approved` for the execution status transition:
- Change `WHERE id = li_id AND status IN ('approved', 'partially_executed')` to `WHERE id = li_id AND status IN ('fully_approved', 'approved', 'partially_executed')` for the `executed` transition.
- Change `WHERE id = li_id AND status = 'approved'` to `WHERE id = li_id AND status IN ('fully_approved', 'approved')` for the `partially_executed` transition.

**STEP 4: DATA BACKFILL (inside same transaction, AFTER trigger rewrites)**

The trigger rewrites must be in place before the backfill runs, because the backfill changes line item status from `approved` to `fully_approved`, and the old transition guard would block this.

```sql
-- Backfill layer on approved approvals
UPDATE stock_out_approvals
SET layer = 'admin', updated_at = NOW()
WHERE decision = 'approved' AND layer IS NULL AND is_active = true;

-- Backfill rejected approvals with layer='quartermaster' (Claude's discretion)
UPDATE stock_out_approvals
SET layer = 'quartermaster', updated_at = NOW()
WHERE decision = 'rejected' AND layer IS NULL AND is_active = true;

-- Backfill line item status: approved -> fully_approved
UPDATE stock_out_line_items
SET status = 'fully_approved', updated_at = NOW()
WHERE status = 'approved' AND is_active = true;
```

**STEP 5: COLUMN COMMENTS + PERMISSIONS**

Add COMMENT ON COLUMN for all three new columns. Grant necessary permissions.

**Important implementation notes:**
- Use `ADD COLUMN IF NOT EXISTS` for idempotency.
- Use `CREATE INDEX IF NOT EXISTS` for idempotency.
- All trigger functions use `CREATE OR REPLACE FUNCTION` (idempotent).
- Do NOT use `SELECT ... FOR UPDATE` in any new trigger functions (except `compute_sor_request_status` which already has it). Use `pg_advisory_xact_lock` for concurrency in `validate_sor_approval`.
- The `validate_sor_approval` function should use `BEFORE INSERT` trigger and modify `NEW.layer` directly (returning modified NEW).
  </action>
  <verify>
Run `npx supabase db reset` in the project root to verify the migration applies cleanly against the full migration chain. Check for:
1. No SQL errors during migration
2. Enum extension succeeds (check with `SELECT unnest(enum_range(NULL::sor_line_item_status))`)
3. Columns exist (check with `\d stock_out_approvals`)
4. Trigger functions are replaced (check with `\df validate_sor_approval`)

If supabase CLI is not available, verify by reading the SQL file carefully for syntax errors, ensuring ADD VALUE is outside BEGIN block, and all trigger function signatures are correct.
  </verify>
  <done>
Migration file exists at `supabase/migrations/20260217100000_two_layer_approval_schema.sql`. It contains: (1) enum extension outside transaction, (2) three new columns on stock_out_approvals, (3) six rewritten trigger functions, (4) data backfill for existing approved/rejected records, (5) indexes and comments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TypeScript types for two-layer approval schema</name>
  <files>types/database.ts</files>
  <action>
Update `types/database.ts` to reflect the new schema:

1. **stock_out_approvals Row type**: Add three new fields:
   - `layer: string | null` (nullable — NULL for legacy/rejected records before backfill, but practically always set after migration)
   - `parent_approval_id: string | null`
   - `warehouse_id: string | null`

2. **stock_out_approvals Insert type**: Add:
   - `layer?: string | null`
   - `parent_approval_id?: string | null`
   - `warehouse_id?: string | null`

3. **stock_out_approvals Update type**: Add:
   - `layer?: string | null`
   - `parent_approval_id?: string | null`
   - `warehouse_id?: string | null`

4. **stock_out_approvals Relationships**: Add two new relationship entries:
   - `parent_approval_id` self-referencing `stock_out_approvals`
   - `warehouse_id` referencing `warehouses`

5. **sor_line_item_status enum**: Add `"awaiting_admin"` and `"fully_approved"` to the union type. Place them after `"approved"` for logical grouping:
   ```
   | "pending"
   | "approved"
   | "awaiting_admin"
   | "fully_approved"
   | "rejected"
   | "cancelled"
   | "partially_executed"
   | "executed"
   ```

Find each section in the file and add the new fields/values. Be precise with the TypeScript syntax and maintain the existing formatting conventions.
  </action>
  <verify>
Run `npm run type-check` (or `npx tsc --noEmit`) to verify TypeScript compilation succeeds with the updated types. No new type errors should be introduced.
  </verify>
  <done>
`types/database.ts` includes `layer`, `parent_approval_id`, and `warehouse_id` on stock_out_approvals types, `awaiting_admin` and `fully_approved` in sor_line_item_status enum, and new relationship entries. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists and follows the structure: enum extension (outside tx) -> schema changes (inside tx) -> trigger rewrites -> backfill -> comments
2. All five trigger functions are rewritten with two-layer awareness
3. Backfill sets layer='admin' on approved records and status='fully_approved' on approved line items
4. TypeScript types match the new database schema
5. No new TypeScript compilation errors
</verification>

<success_criteria>
- Migration 063 applies cleanly on `npx supabase db reset`
- stock_out_approvals has layer, parent_approval_id, warehouse_id columns
- sor_line_item_status enum has awaiting_admin and fully_approved values
- Trigger functions enforce two-layer flow: pending -> awaiting_admin -> fully_approved -> execution
- TypeScript types updated and compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/55-database-foundation-useravatar/55-01-SUMMARY.md`
</output>
