---
phase: 22-po-inline-creation-validation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - components/providers/auth-provider.tsx
autonomous: true

must_haves:
  truths:
    - "User can work in multiple browser tabs without authentication errors"
    - "Session refreshes silently when user returns to an inactive tab"
    - "Logging out in one tab logs out all other tabs"
    - "User sees warning modal if session expires while having unsaved work"
    - "Modal allows user to acknowledge before redirect to login"
  artifacts:
    - path: "components/providers/auth-provider.tsx"
      provides: "Tab visibility session refresh and cross-tab logout sync"
      contains: "visibilitychange"
      contains: "BroadcastChannel"
  key_links:
    - from: "components/providers/auth-provider.tsx"
      to: "document.visibilityState"
      via: "visibilitychange event listener"
      pattern: "visibilitychange"
    - from: "components/providers/auth-provider.tsx"
      to: "BroadcastChannel"
      via: "Cross-tab messaging for logout"
      pattern: "BroadcastChannel.*qm-auth"
---

<objective>
Add multi-tab session handling with silent refresh on tab focus and cross-tab logout synchronization.

Purpose: Users can work across multiple browser tabs without encountering unexpected authentication errors or stale sessions.
Output: Enhanced auth provider with tab visibility handling, cross-tab logout sync, and unsaved work warning.
</objective>

<execution_context>
@/Users/thihaaung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thihaaung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-po-inline-creation-validation/22-CONTEXT.md
@.planning/phases/22-po-inline-creation-validation/22-RESEARCH.md
@components/providers/auth-provider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tab visibility session refresh</name>
  <files>components/providers/auth-provider.tsx</files>
  <action>
Add visibilitychange event listener to refresh session when user returns to an inactive tab:

1. Add state for session expired modal:
   ```tsx
   const [showSessionExpiredModal, setShowSessionExpiredModal] = useState(false);
   ```

2. Add new useEffect after the activity tracking useEffect for tab visibility handling:
   ```tsx
   // Tab visibility handling - refresh session when tab becomes active
   useEffect(() => {
     if (!supabaseUser) return;

     let isRefreshing = false; // Prevent re-entrancy

     const handleVisibilityChange = async () => {
       // Only act when tab becomes visible
       if (document.visibilityState !== 'visible') return;
       if (isRefreshing) return;

       isRefreshing = true;

       try {
         const supabase = createClient();
         const { data: { session }, error } = await supabase.auth.getSession();

         if (error || !session) {
           // Session invalid - check for unsaved work
           const hasUnsavedWork = checkForUnsavedWork();

           if (hasUnsavedWork) {
             setShowSessionExpiredModal(true);
           } else {
             await signOut();
           }
         } else {
           // Session valid - update activity marker
           try {
             localStorage.setItem(ACTIVITY_KEY, Date.now().toString());
           } catch {}
         }
       } catch (err) {
         console.error('Session check failed:', err);
       } finally {
         isRefreshing = false;
       }
     };

     document.addEventListener('visibilitychange', handleVisibilityChange);

     return () => {
       document.removeEventListener('visibilitychange', handleVisibilityChange);
     };
   }, [supabaseUser, signOut]);
   ```

3. Add helper function to check for unsaved work (before the useEffect):
   ```tsx
   // Check for unsaved work in sessionStorage
   const checkForUnsavedWork = (): boolean => {
     try {
       return !!(
         sessionStorage.getItem('qmhq_draft') ||
         sessionStorage.getItem('qmhq_route_data') ||
         sessionStorage.getItem('po_draft')
       );
     } catch {
       return false;
     }
   };
   ```

4. Add Dialog import at the top (from shadcn/ui):
   ```tsx
   import {
     Dialog,
     DialogContent,
     DialogDescription,
     DialogFooter,
     DialogHeader,
     DialogTitle,
   } from "@/components/ui/dialog";
   import { Button } from "@/components/ui/button";
   ```

5. Add session expired modal in the return statement, just before the closing `</AuthContext.Provider>`:
   ```tsx
   {/* Session expired modal */}
   <Dialog open={showSessionExpiredModal} onOpenChange={() => {}}>
     <DialogContent className="sm:max-w-md" onPointerDownOutside={(e) => e.preventDefault()}>
       <DialogHeader>
         <DialogTitle>Session Expired</DialogTitle>
         <DialogDescription>
           Your session has expired. You have unsaved changes that will be lost.
         </DialogDescription>
       </DialogHeader>
       <DialogFooter className="flex gap-2 sm:gap-0">
         <Button
           variant="outline"
           onClick={() => {
             // Clear draft data and sign out
             try {
               sessionStorage.removeItem('qmhq_draft');
               sessionStorage.removeItem('qmhq_route_data');
               sessionStorage.removeItem('po_draft');
             } catch {}
             setShowSessionExpiredModal(false);
             signOut();
           }}
         >
           Discard & Login
         </Button>
         <Button
           onClick={() => setShowSessionExpiredModal(false)}
         >
           Stay on Page
         </Button>
       </DialogFooter>
     </DialogContent>
   </Dialog>
   ```

Note: "Stay on Page" allows user to copy data manually before losing it. The session is already invalid so API calls will fail, but they can at least see their data.
  </action>
  <verify>
1. TypeScript compiles: `npm run type-check`
2. Manual test:
   - Log in to the app
   - Open a second tab with the app
   - In tab 2, start creating a QMHQ (fill some fields to create draft)
   - Wait or manually clear session (hard to test timeout naturally)
   - Switch to tab 2 - should see session check happen
3. Verify Dialog import works - no runtime errors
  </verify>
  <done>
Auth provider refreshes session when returning to inactive tab and shows warning modal if session expired with unsaved work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cross-tab logout synchronization</name>
  <files>components/providers/auth-provider.tsx</files>
  <action>
Add BroadcastChannel for cross-tab logout sync with Safari fallback:

1. Add new useEffect for BroadcastChannel listener (after the visibility handling useEffect):
   ```tsx
   // Cross-tab logout sync via BroadcastChannel
   useEffect(() => {
     let channel: BroadcastChannel | null = null;

     try {
       channel = new BroadcastChannel('qm-auth');

       channel.onmessage = (event) => {
         if (event.data.type === 'SIGNED_OUT') {
           // Another tab signed out - sync this tab
           clearSessionMarkers();
           setUser(null);
           setSupabaseUser(null);
           router.push('/login');
         } else if (event.data.type === 'SIGNED_IN') {
           // Another tab signed in - refresh user data
           refreshUser();
         }
       };
     } catch (e) {
       // BroadcastChannel not supported (Safari) - graceful degradation
       console.log('BroadcastChannel not available for cross-tab sync');
     }

     return () => {
       try {
         channel?.close();
       } catch {}
     };
   }, [router, refreshUser]);
   ```

2. Update the existing signOut function to broadcast to other tabs:
   ```tsx
   const signOut = useCallback(async () => {
     const supabase = createClient();
     try {
       await supabase.auth.signOut();
     } catch {}
     clearSessionMarkers();
     setUser(null);
     setSupabaseUser(null);

     // Broadcast to other tabs
     try {
       const channel = new BroadcastChannel('qm-auth');
       channel.postMessage({ type: 'SIGNED_OUT' });
       channel.close();
     } catch {
       // BroadcastChannel not supported - graceful degradation
     }

     router.push("/login");
   }, [router]);
   ```

3. The signOut function is already memoized with useCallback, so just update the implementation.

Note: Safari doesn't support BroadcastChannel. The try-catch ensures graceful degradation - Safari users simply won't get cross-tab sync, but the app still works normally per user decision (no localStorage fallback needed).
  </action>
  <verify>
1. TypeScript compiles: `npm run type-check`
2. Manual test in Chrome/Firefox:
   - Log in to the app
   - Open app in multiple tabs (3-4 tabs)
   - Click logout in one tab
   - Verify all other tabs redirect to login
3. Manual test in Safari:
   - Log in to the app
   - Open app in second tab
   - Logout in tab 1
   - Tab 2 should still work (no crash), but won't auto-redirect (expected limitation)
4. Verify console shows "BroadcastChannel not available" in Safari (no errors)
  </verify>
  <done>
Logging out in one tab broadcasts to all other tabs, causing them to also log out and redirect to login page.
  </done>
</task>

</tasks>

<verification>
1. Tab visibility test:
   - Open app, start creating QMHQ
   - Switch to another app/tab for a while
   - Return to app - session should refresh silently (no error)
2. Cross-tab logout test:
   - Open app in 3 tabs
   - Log out in tab 1
   - Tabs 2 and 3 should redirect to login
3. Unsaved work warning test:
   - Open app, start creating QMHQ (fill form to create draft)
   - Simulate session expiry (clear Supabase auth cookies manually)
   - Switch away and back - should see modal about unsaved changes
4. Type checking passes: `npm run type-check`
5. Build succeeds: `npm run build`
</verification>

<success_criteria>
1. Session refreshes silently when returning to inactive tab
2. Invalid session with unsaved work shows warning modal
3. Modal offers "Discard & Login" and "Stay on Page" options
4. Logout in one tab logs out all other tabs (Chrome/Firefox)
5. Safari gracefully degrades (no crash, works normally without cross-tab sync)
6. No console errors related to BroadcastChannel
</success_criteria>

<output>
After completion, create `.planning/phases/22-po-inline-creation-validation/22-03-SUMMARY.md`
</output>
