---
phase: 39-end-to-end-flow-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260211_flow_tracking_view.sql
  - types/flow-tracking.ts
  - lib/supabase/flow-tracking-queries.ts
autonomous: true

must_haves:
  truths:
    - "PostgreSQL VIEW qmrl_flow_chain joins QMRL -> QMHQ -> PO -> Invoice -> Stock + Financial Transactions in a single query"
    - "TypeScript types model the nested chain structure (QMRL with QMHQs, each with route-specific children)"
    - "Query function fetches flow chain by QMRL request_id and transforms flat VIEW rows into nested structure"
  artifacts:
    - path: "supabase/migrations/20260211_flow_tracking_view.sql"
      provides: "qmrl_flow_chain VIEW with multi-level LEFT JOINs"
      contains: "CREATE OR REPLACE VIEW qmrl_flow_chain"
    - path: "types/flow-tracking.ts"
      provides: "FlowChain, FlowQMRL, FlowQMHQ, FlowPO, FlowInvoice, FlowStock, FlowFinancialTransaction types"
      min_lines: 60
    - path: "lib/supabase/flow-tracking-queries.ts"
      provides: "fetchFlowChain function with row-to-tree transformation"
      exports: ["fetchFlowChain"]
  key_links:
    - from: "lib/supabase/flow-tracking-queries.ts"
      to: "types/flow-tracking.ts"
      via: "import FlowChain types"
      pattern: "import.*from.*types/flow-tracking"
    - from: "lib/supabase/flow-tracking-queries.ts"
      to: "qmrl_flow_chain VIEW"
      via: "supabase .from('qmrl_flow_chain')"
      pattern: "from\\(.*qmrl_flow_chain.*\\)"
---

<objective>
Create the database VIEW and data layer for flow tracking: a PostgreSQL VIEW that joins the full QMRL downstream chain (QMRL -> QMHQs -> POs -> Invoices -> Stock + Financial Transactions), TypeScript types for the nested chain structure, and a query function that fetches and transforms flat VIEW rows into a nested tree.

Purpose: Establish the data foundation that the flow tracking page UI (Plan 02) will consume.
Output: Migration file, type definitions, query function with transformation logic.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-end-to-end-flow-tracking/39-RESEARCH.md

Key schema references:
- supabase/migrations/009_qmrl.sql (QMRL table: id, request_id, title, status_id, category_id, department_id, contact_person_id, assigned_to, requester_id, request_date, priority)
- supabase/migrations/011_qmhq.sql (QMHQ table: id, request_id, qmrl_id, line_name, route_type, status_id, category_id, contact_person_id, assigned_to)
- supabase/migrations/015_purchase_orders.sql (PO table: id, po_number, qmhq_id, supplier_id, status, po_date, expected_delivery_date, is_active)
- supabase/migrations/021_invoices.sql (Invoice table: id, invoice_number, po_id, status, invoice_date, due_date, is_voided, is_active)
- supabase/migrations/023_inventory_transactions.sql (Stock: id, movement_type, item_id, warehouse_id, quantity, status, transaction_date, invoice_id, qmhq_id)
- supabase/migrations/012_financial_transactions.sql (FinTrans: id, qmhq_id, transaction_type, amount, currency, exchange_rate, transaction_date, is_voided)
- supabase/migrations/052_stock_out_requests.sql (SOR: id, request_number, status, qmhq_id, reason, requester_id)

Existing patterns:
- lib/supabase/server.ts (createClient for server-side queries)
- types/database.ts (existing database types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL VIEW and TypeScript types for flow chain</name>
  <files>
    supabase/migrations/20260211_flow_tracking_view.sql
    types/flow-tracking.ts
  </files>
  <action>
**Migration file:** Create `supabase/migrations/20260211_flow_tracking_view.sql` with a VIEW named `qmrl_flow_chain` that LEFT JOINs the full downstream chain. Use timestamp-style migration naming (matching recent pattern `20260211120001_*.sql`). Actually name it `20260211140000_flow_tracking_view.sql` for proper ordering.

The VIEW must join:
1. **qmrl** (root) with status_config for status name/color, users for requester and assigned_to (full_name, avatar_url), contact_persons for contact name
2. **qmhq** via qmrl_id, with status_config, users for assigned_to, contact_persons
3. **purchase_orders** via qmhq_id (only for PO route, but LEFT JOIN handles this), with suppliers for supplier name
4. **invoices** via po_id, include is_voided for strikethrough styling
5. **inventory_transactions** via either qmhq_id (item route stock-out) or invoice_id (PO route stock-in)
6. **financial_transactions** via qmhq_id (expense route)
7. **stock_out_requests** via qmhq_id (item route SOR status)

SELECT columns to include (all prefixed by entity type):
- QMRL: id, request_id, title, priority, request_date, created_at, status (name, color), requester (id, full_name, avatar_url), assigned_to (id, full_name, avatar_url), contact_person name
- QMHQ: id, request_id, line_name, route_type, created_at, status (name, color), assigned_to (id, full_name, avatar_url), contact_person name
- PO: id, po_number, status (po_status enum), po_date, expected_delivery_date, created_at, supplier name, is_active
- Invoice: id, invoice_number, status (invoice_status enum), invoice_date, due_date, is_voided, created_at, is_active
- Inventory Transaction: id, movement_type, status, transaction_date, created_at
- Financial Transaction: id, transaction_type, transaction_date, created_at, is_voided
- Stock-Out Request: id, request_number, status (sor_request_status), created_at

WHERE clause: `qmrl.is_active = true`
ORDER BY: `qmrl.created_at DESC, qmhq.created_at, po.po_date, invoice.invoice_date`

Add `GRANT SELECT ON qmrl_flow_chain TO authenticated;` at the end.

IMPORTANT: Do NOT try to enable RLS on the VIEW or create RLS policies on the VIEW. PostgreSQL VIEWs don't support RLS directly. The admin-only restriction will be enforced server-side in the page component (Plan 02). The VIEW uses `security_invoker = false` (default) so it inherits the underlying table RLS from the caller's session.

**Types file:** Create `types/flow-tracking.ts` with these interfaces:

```typescript
// Person display (for users with avatars)
interface FlowPerson { id: string; full_name: string; avatar_url: string | null; }

// Status display
interface FlowStatus { name: string; color: string; }

// Leaf nodes
interface FlowStockTransaction { id: string; movement_type: string; status: string; transaction_date: string; created_at: string; }

interface FlowFinancialTransaction { id: string; transaction_type: string; transaction_date: string; created_at: string; is_voided: boolean; }

interface FlowStockOutRequest { id: string; request_number: string; status: string; created_at: string; }

// Invoice (under PO)
interface FlowInvoice { id: string; invoice_number: string; status: string; invoice_date: string; due_date: string | null; is_voided: boolean; created_at: string; stock_transactions: FlowStockTransaction[]; }

// PO (under QMHQ)
interface FlowPO { id: string; po_number: string; status: string; po_date: string; expected_delivery_date: string | null; created_at: string; supplier_name: string | null; is_cancelled: boolean; invoices: FlowInvoice[]; }

// QMHQ (under QMRL)
interface FlowQMHQ { id: string; request_id: string; line_name: string; route_type: 'item' | 'expense' | 'po'; status: FlowStatus; assigned_to: FlowPerson | null; contact_person_name: string | null; created_at: string; pos: FlowPO[]; financial_transactions: FlowFinancialTransaction[]; stock_transactions: FlowStockTransaction[]; stock_out_requests: FlowStockOutRequest[]; }

// Root QMRL
interface FlowQMRL { id: string; request_id: string; title: string; priority: string; request_date: string; created_at: string; status: FlowStatus; requester: FlowPerson | null; assigned_to: FlowPerson | null; contact_person_name: string | null; qmhqs: FlowQMHQ[]; }

// The full chain type (alias for FlowQMRL)
type FlowChain = FlowQMRL;
```

Export all interfaces/types.
  </action>
  <verify>
    Run `npm run type-check` to confirm types compile without errors. Verify migration file exists at the expected path.
  </verify>
  <done>
    - Migration file creates qmrl_flow_chain VIEW with all required JOINs
    - TypeScript types model the full nested chain: FlowQMRL -> FlowQMHQ -> (FlowPO -> FlowInvoice -> FlowStockTransaction) | FlowFinancialTransaction | FlowStockTransaction | FlowStockOutRequest
    - Types exported for consumption by query function and UI components
  </done>
</task>

<task type="auto">
  <name>Task 2: Create flow chain query function with row-to-tree transformation</name>
  <files>
    lib/supabase/flow-tracking-queries.ts
  </files>
  <action>
Create `lib/supabase/flow-tracking-queries.ts` that exports a `fetchFlowChain` function.

**Function signature:**
```typescript
export async function fetchFlowChain(
  supabase: SupabaseClient,
  qmrlRequestId: string
): Promise<{ data: FlowChain | null; error: string | null }>
```

**Implementation:**
1. Query `qmrl_flow_chain` VIEW filtering by `qmrl_request_id` = `qmrlRequestId.toUpperCase().trim()`
2. If no rows returned, return `{ data: null, error: null }` (not found is not an error)
3. If error from Supabase, return `{ data: null, error: error.message }`
4. Transform flat VIEW rows into nested FlowChain structure using Map-based grouping:

**Transformation logic (critical - get this right):**

The VIEW returns flat rows with many NULL columns due to LEFT JOINs. Each row may contain QMRL + QMHQ + PO + Invoice + Stock/Financial data, or QMRL + QMHQ + NULL + NULL + NULL for QMHQs with no downstream entities.

Use Maps keyed by UUID for O(1) deduplication:
- `qmhqMap: Map<string, FlowQMHQ>` — deduplicate QMHQs
- For each QMHQ, use `poMap: Map<string, FlowPO>` — deduplicate POs within that QMHQ
- For each PO, use `invoiceMap: Map<string, FlowInvoice>` — deduplicate invoices within that PO
- Use Sets for stock/financial transaction IDs to prevent duplicates

Algorithm:
```
1. Extract QMRL fields from first row (all rows have same QMRL data)
2. For each row:
   a. If qmhq_id exists and not in qmhqMap, create FlowQMHQ and add to map
   b. If po_id exists and not in current QMHQ's poMap, create FlowPO and add
   c. If invoice_id exists and not in current PO's invoiceMap, create FlowInvoice and add
   d. If stock_id exists and not already added, add FlowStockTransaction to:
      - Invoice's stock_transactions (if invoice_id matches, for PO route stock-in)
      - QMHQ's stock_transactions (if qmhq route is 'item', for item route stock-out)
   e. If ft_id exists and not already added, add FlowFinancialTransaction to QMHQ's financial_transactions
   f. If sor_id exists and not already added, add FlowStockOutRequest to QMHQ's stock_out_requests
3. Assemble: qmrl.qmhqs = Array.from(qmhqMap.values()), each with pos/invoices/etc.
```

Import types from `@/types/flow-tracking`. Import `SupabaseClient` type from `@supabase/supabase-js`. Use `createClient` from `@/lib/supabase/server` only if needed in a wrapper; the main function takes supabase client as parameter for flexibility.

Handle edge cases:
- QMRL with zero QMHQs (returns 1 row with all QMHQ columns NULL) -> return FlowChain with empty qmhqs array
- QMHQ with NULL status (shouldn't happen but handle gracefully with fallback "Unknown" status)
- Voided invoices: still include them (user constraint: visible for audit trail)
- Cancelled POs: include and set `is_cancelled: true` based on `po.status = 'cancelled'`
  </action>
  <verify>
    Run `npm run type-check` to confirm the query function compiles. Verify the function is exported correctly by checking for the export statement.
  </verify>
  <done>
    - fetchFlowChain function queries qmrl_flow_chain VIEW by QMRL request_id
    - Transformation correctly deduplicates entities using Maps
    - Returns null data (not error) for not-found QMRL IDs
    - All entity types correctly nested: POs under QMHQs, Invoices under POs, Stock under Invoices/QMHQs, Financial under QMHQs, SORs under QMHQs
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes with no errors related to flow-tracking types or queries
2. Migration file is syntactically valid SQL (check with basic syntax review)
3. types/flow-tracking.ts exports all required interfaces
4. lib/supabase/flow-tracking-queries.ts exports fetchFlowChain
</verification>

<success_criteria>
- PostgreSQL VIEW exists in migration file with correct multi-level JOINs
- TypeScript types accurately model the nested chain structure
- Query function fetches and transforms flat rows into nested tree
- All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/39-end-to-end-flow-tracking/39-01-SUMMARY.md`
</output>
