---
phase: 07.1-attachment-item-route-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/034_qmhq_auto_stockout.sql
  - supabase/migrations/035_qmhq_items.sql
autonomous: true
user_setup: []

must_haves:
  truths:
    - "When QMHQ item route status changes to 'done' group, inventory_out transaction is auto-created"
    - "Auto-created stock-out includes correct item, warehouse, quantity from QMHQ"
    - "Multiple status changes to 'done' create only one stock-out (idempotent)"
    - "QMHQ can reference multiple items via qmhq_items junction table"
  artifacts:
    - path: "supabase/migrations/034_qmhq_auto_stockout.sql"
      provides: "PostgreSQL trigger for automatic stock-out"
      contains: "auto_stockout_on_qmhq_fulfilled"
    - path: "supabase/migrations/035_qmhq_items.sql"
      provides: "Junction table for multi-item QMHQ"
      contains: "CREATE TABLE qmhq_items"
  key_links:
    - from: "supabase/migrations/034_qmhq_auto_stockout.sql"
      to: "inventory_transactions"
      via: "INSERT triggered on qmhq UPDATE"
      pattern: "INSERT INTO inventory_transactions"
    - from: "supabase/migrations/035_qmhq_items.sql"
      to: "qmhq"
      via: "Foreign key qmhq_id"
      pattern: "REFERENCES qmhq\\(id\\)"
---

<objective>
Create database infrastructure for automatic stock-out and multi-item QMHQ support.

Purpose: When QMHQ item route requests are fulfilled (status changed to 'done'), inventory should automatically decrease. Also, QMHQ should support multiple items in a single request line.

Output: PostgreSQL trigger for auto stock-out and qmhq_items junction table.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.1-attachment-item-route-fixes/07.1-RESEARCH.md
@supabase/migrations/011_qmhq.sql
@supabase/migrations/023_inventory_transactions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Auto Stock-Out Trigger</name>
  <files>
    supabase/migrations/034_qmhq_auto_stockout.sql
  </files>
  <action>
    Create migration file supabase/migrations/034_qmhq_auto_stockout.sql with:

    ```sql
    -- Migration: 034_qmhq_auto_stockout.sql
    -- Description: Auto-create inventory_out when QMHQ item route status changes to 'done'

    -- Create trigger function
    CREATE OR REPLACE FUNCTION auto_stockout_on_qmhq_fulfilled()
    RETURNS TRIGGER AS $$
    DECLARE
      status_is_done BOOLEAN;
    BEGIN
      -- Check if new status is in 'done' group
      SELECT status_group = 'done'
      INTO status_is_done
      FROM status_config
      WHERE id = NEW.status_id;

      -- Only proceed if:
      -- 1. Status actually changed
      -- 2. New status is 'done' (fulfilled/completed)
      -- 3. Route type is 'item'
      -- 4. Item and warehouse specified (legacy single-item)
      -- 5. No stock-out exists yet for this QMHQ (idempotency)
      IF (OLD.status_id IS DISTINCT FROM NEW.status_id)
         AND status_is_done = true
         AND NEW.route_type = 'item'
         AND NEW.item_id IS NOT NULL
         AND NEW.warehouse_id IS NOT NULL
         AND NEW.quantity > 0
         AND NOT EXISTS (
           SELECT 1 FROM inventory_transactions
           WHERE qmhq_id = NEW.id
           AND movement_type = 'inventory_out'
           AND reason = 'request'
           AND is_active = true
         )
      THEN
        -- Create inventory_out transaction
        INSERT INTO inventory_transactions (
          movement_type,
          item_id,
          warehouse_id,
          quantity,
          reason,
          qmhq_id,
          transaction_date,
          notes,
          status,
          created_by
        ) VALUES (
          'inventory_out',
          NEW.item_id,
          NEW.warehouse_id,
          NEW.quantity,
          'request',
          NEW.id,
          CURRENT_DATE,
          'Auto stock-out from ' || NEW.request_id,
          'completed',
          COALESCE(NEW.updated_by, NEW.created_by)
        );

        RAISE NOTICE 'Created auto stock-out for QMHQ %', NEW.request_id;
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    -- Attach trigger to qmhq table
    DROP TRIGGER IF EXISTS qmhq_auto_stockout ON qmhq;
    CREATE TRIGGER qmhq_auto_stockout
      AFTER UPDATE ON qmhq
      FOR EACH ROW
      EXECUTE FUNCTION auto_stockout_on_qmhq_fulfilled();

    -- Comments
    COMMENT ON FUNCTION auto_stockout_on_qmhq_fulfilled() IS
      'Automatically creates inventory_out transaction when QMHQ item route status changes to done group';
    ```

    Key design decisions:
    - Uses SECURITY DEFINER to bypass RLS for system-generated transactions
    - Idempotency check prevents duplicate stock-outs if status toggled multiple times
    - Uses COALESCE for created_by to handle edge cases
    - Only triggers for legacy single-item QMHQ (NEW.item_id IS NOT NULL)
  </action>
  <verify>
    1. Run `npx supabase db reset` to apply migrations
    2. Create a QMHQ with item route (item_id, warehouse_id, quantity set)
    3. Change status to a 'done' group status
    4. Check inventory_transactions table for auto-created stock-out
    5. Change status back to 'in_progress' then to 'done' again - should NOT create duplicate
  </verify>
  <done>
    PostgreSQL trigger auto-creates inventory_out when QMHQ item route status changes to 'done' group.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Multi-Item Junction Table</name>
  <files>
    supabase/migrations/035_qmhq_items.sql
  </files>
  <action>
    Create migration file supabase/migrations/035_qmhq_items.sql with:

    ```sql
    -- Migration: 035_qmhq_items.sql
    -- Description: Junction table for multi-item QMHQ support

    -- Create qmhq_items junction table
    CREATE TABLE IF NOT EXISTS qmhq_items (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

      -- Parent QMHQ reference
      qmhq_id UUID NOT NULL REFERENCES qmhq(id) ON DELETE CASCADE,

      -- Item reference
      item_id UUID NOT NULL REFERENCES items(id) ON DELETE RESTRICT,

      -- Quantity requested
      quantity DECIMAL(15,2) NOT NULL CHECK (quantity > 0),

      -- Source warehouse for stock-out
      warehouse_id UUID REFERENCES warehouses(id),

      -- Prevent duplicate items in same QMHQ
      UNIQUE(qmhq_id, item_id),

      -- Audit fields
      created_at TIMESTAMPTZ DEFAULT NOW(),
      created_by UUID REFERENCES users(id)
    );

    -- Indexes for common queries
    CREATE INDEX IF NOT EXISTS idx_qmhq_items_qmhq_id ON qmhq_items(qmhq_id);
    CREATE INDEX IF NOT EXISTS idx_qmhq_items_item_id ON qmhq_items(item_id);
    CREATE INDEX IF NOT EXISTS idx_qmhq_items_warehouse_id ON qmhq_items(warehouse_id);

    -- RLS Policies (inherit from qmhq permissions)
    ALTER TABLE qmhq_items ENABLE ROW LEVEL SECURITY;

    -- SELECT: Same users who can view QMHQ
    CREATE POLICY qmhq_items_select ON qmhq_items
      FOR SELECT USING (
        EXISTS (
          SELECT 1 FROM qmhq
          WHERE qmhq.id = qmhq_items.qmhq_id
        )
      );

    -- INSERT: Same users who can create QMHQ
    CREATE POLICY qmhq_items_insert ON qmhq_items
      FOR INSERT WITH CHECK (
        EXISTS (
          SELECT 1 FROM qmhq
          WHERE qmhq.id = qmhq_items.qmhq_id
        )
      );

    -- UPDATE: Same users who can update QMHQ
    CREATE POLICY qmhq_items_update ON qmhq_items
      FOR UPDATE USING (
        EXISTS (
          SELECT 1 FROM qmhq
          WHERE qmhq.id = qmhq_items.qmhq_id
        )
      );

    -- DELETE: Same users who can update QMHQ
    CREATE POLICY qmhq_items_delete ON qmhq_items
      FOR DELETE USING (
        EXISTS (
          SELECT 1 FROM qmhq
          WHERE qmhq.id = qmhq_items.qmhq_id
        )
      );

    -- Comments
    COMMENT ON TABLE qmhq_items IS 'Junction table for multi-item QMHQ requests';
    COMMENT ON COLUMN qmhq_items.qmhq_id IS 'Parent QMHQ record';
    COMMENT ON COLUMN qmhq_items.item_id IS 'Requested item';
    COMMENT ON COLUMN qmhq_items.quantity IS 'Quantity requested';
    COMMENT ON COLUMN qmhq_items.warehouse_id IS 'Source warehouse for stock-out (optional, can differ per item)';
    ```

    Key design decisions:
    - CASCADE delete when parent QMHQ deleted
    - RESTRICT delete on item (cannot delete items with pending requests)
    - Per-item warehouse_id allows sourcing from different warehouses
    - UNIQUE constraint prevents duplicate items in same QMHQ
    - RLS policies inherit from parent QMHQ visibility
    - Legacy qmhq.item_id column preserved for backward compatibility
  </action>
  <verify>
    1. Run `npx supabase db reset` to apply migrations
    2. Verify table exists: `SELECT * FROM qmhq_items LIMIT 1;`
    3. Check indexes: `\d qmhq_items`
    4. Check RLS enabled: `SELECT relname, relrowsecurity FROM pg_class WHERE relname = 'qmhq_items';`
  </verify>
  <done>
    qmhq_items junction table created with proper indexes, constraints, and RLS policies.
  </done>
</task>

</tasks>

<verification>
1. npx supabase db reset - migrations apply without errors
2. Verify trigger exists: `\df auto_stockout_on_qmhq_fulfilled`
3. Verify table exists: `\d qmhq_items`
4. Test auto stock-out by changing QMHQ item route status to 'done'
5. npm run build - TypeScript compilation succeeds
</verification>

<success_criteria>
- Migration 034 creates auto_stockout_on_qmhq_fulfilled trigger function
- Migration 035 creates qmhq_items table with indexes and RLS
- Auto stock-out creates inventory_out when QMHQ item route status = done
- Idempotency prevents duplicate stock-out transactions
- Legacy qmhq.item_id still works for existing records
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-attachment-item-route-fixes/07.1-02-SUMMARY.md`
</output>
