# Phase 7.1: Attachment & Item Route Fixes - Research

**Researched:** 2026-01-29
**Domain:** File attachment management, UI component configuration, inventory workflow automation
**Confidence:** HIGH

## Summary

Phase 7.1 addresses four urgent fixes discovered post-Phase 7:

1. **Attachment Deletion** - The attachment deletion functionality is already fully implemented with RLS policies, but the UI may be hiding the delete button incorrectly
2. **Date Picker Simplification** - react-day-picker v8.10 uses `captionLayout` prop; changing from "dropdown-buttons" to "buttons" removes month/year dropdowns
3. **QMHQ Item Route Stock-Out** - Inventory transactions must be created when QMHQ item route status changes to "fulfilled"; requires PostgreSQL trigger or application logic
4. **Multi-Item Selection** - QMHQ item route should support selecting multiple items without unit price field; requires schema extension and form redesign

The standard approach combines UI configuration changes (date picker), permission verification (attachments), database triggers (status-driven stock-out), and data model enhancement (multi-item support).

**Primary recommendation:** Fix attachment UI visibility, change date picker configuration to "buttons" mode, implement status-change trigger for automatic stock-out, and extend QMHQ schema to support multiple items with a junction table.

## Standard Stack

### Core Libraries
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| react-day-picker | 8.10.1 | Calendar/date picker | Already installed; v8 API is stable |
| Next.js Server Actions | 14.2.13 | File operations | Built-in; optimal for file upload/delete |
| PostgreSQL Triggers | 18+ | Status-driven automation | Native database feature for data integrity |
| React useState | 18.3.1 | Multi-select state | Built-in hook; standard for form arrays |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Supabase RLS | Latest | Access control | Already configured for file_attachments |
| @supabase/supabase-js | Latest | Storage operations | File deletion from storage bucket |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| PostgreSQL trigger | Application logic | Triggers guarantee atomicity; app logic requires transaction management |
| Junction table | JSON array in qmhq | Junction table enables proper relational queries, validation, and audit trail |
| react-day-picker v8 | Upgrade to v9 | v9 has breaking changes; v8 works perfectly for the fix needed |

**Installation:**
```bash
# All dependencies already installed
# No new packages required
```

## Architecture Patterns

### Pattern 1: Attachment Deletion - Permission-Based UI Visibility
**What:** Show/hide delete functionality based on RLS policies
**When to use:** File operations where permissions are enforced at database level

Current RLS Policy (already in place):
```sql
-- UPDATE (soft delete): Admin and Quartermaster only
CREATE POLICY file_attachments_update ON public.file_attachments
  FOR UPDATE USING (
    public.get_user_role() IN ('admin', 'quartermaster')
  );
```

UI Pattern:
```tsx
// components/files/attachments-tab.tsx
const { user } = useAuth();
const canEdit = user?.role === 'admin' || user?.role === 'quartermaster';

<AttachmentsTab
  entityType="qmrl"
  entityId={qmrl.id}
  entityDisplayId={qmrl.request_id}
  canEdit={canEdit}
/>
```

**Current Issue:** The `canEdit` prop is likely defaulting to `true` or not being passed correctly from parent components.

**Fix:** Verify permission checks in QMRL/QMHQ detail pages pass correct `canEdit` value.

### Pattern 2: Date Picker Configuration
**What:** Use `captionLayout` prop to control calendar navigation UI
**When to use:** Simplifying calendar UX by removing dropdown selectors

Current Configuration (components/ui/calendar.tsx):
```tsx
<DayPicker
  captionLayout="dropdown-buttons"  // Shows dropdowns AND arrows
  fromYear={2020}
  toYear={2030}
  // ...
/>
```

**Fix to "buttons" mode:**
```tsx
<DayPicker
  captionLayout="buttons"  // Shows ONLY arrow navigation
  // Remove fromYear and toYear props (only needed for dropdowns)
  // ...
/>
```

Source: [react-day-picker v8 CaptionLayout documentation](https://daypicker.dev/v8/api/type-aliases/CaptionLayout)

### Pattern 3: Status-Driven Inventory Transaction
**What:** Automatically create inventory_out transaction when QMHQ item route status changes to "fulfilled"
**When to use:** Automating business logic that must always occur on status change

**Option A: PostgreSQL Trigger (RECOMMENDED)**
```sql
-- Trigger function to create stock-out when QMHQ item route is fulfilled
CREATE OR REPLACE FUNCTION auto_stockout_on_qmhq_fulfilled()
RETURNS TRIGGER AS $$
BEGIN
  -- Only trigger if:
  -- 1. Status changed
  -- 2. New status is "fulfilled" (check status_config name or group)
  -- 3. Route type is 'item'
  -- 4. Item and warehouse are specified
  IF (OLD.status_id IS DISTINCT FROM NEW.status_id)
     AND NEW.route_type = 'item'
     AND NEW.item_id IS NOT NULL
     AND NEW.warehouse_id IS NOT NULL
     AND NEW.quantity > 0
     AND EXISTS (
       SELECT 1 FROM status_config
       WHERE id = NEW.status_id
       AND status_group = 'done'  -- Or check name = 'Fulfilled'
     )
  THEN
    -- Create inventory transaction
    INSERT INTO inventory_transactions (
      movement_type,
      item_id,
      warehouse_id,
      quantity,
      reason,
      qmhq_id,
      transaction_date,
      notes,
      created_by
    ) VALUES (
      'inventory_out',
      NEW.item_id,
      NEW.warehouse_id,
      NEW.quantity,
      'request',
      NEW.id,
      CURRENT_DATE,
      'Auto stock-out from QMHQ ' || NEW.request_id,
      NEW.updated_by  -- User who changed status
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger to qmhq table
DROP TRIGGER IF EXISTS qmhq_auto_stockout ON qmhq;
CREATE TRIGGER qmhq_auto_stockout
  AFTER UPDATE ON qmhq
  FOR EACH ROW
  EXECUTE FUNCTION auto_stockout_on_qmhq_fulfilled();
```

**Option B: Application Logic**
```tsx
// In status change handler
const handleStatusChange = async (newStatusId: string) => {
  const newStatus = await getStatusById(newStatusId);

  // Start transaction
  const { error } = await supabase.rpc('update_qmhq_with_stockout', {
    qmhq_id: qmhq.id,
    new_status_id: newStatusId,
    user_id: user.id
  });
};
```

**Recommendation:** Use PostgreSQL trigger (Option A) because:
- Guarantees atomicity (status update + stock-out happen together or not at all)
- Cannot be bypassed by buggy application code
- Audit trail is automatic
- Handles edge cases (duplicate stock-outs, concurrent updates)

Sources:
- [PostgreSQL Trigger Functions](https://www.postgresql.org/docs/current/plpgsql-trigger.html)
- [PostgreSQL AFTER Triggers](https://www.datacamp.com/doc/postgresql/after-triggers)

### Pattern 4: Multi-Item Selection for QMHQ Item Route
**What:** Allow selecting multiple items in QMHQ item route form
**When to use:** Request lines that bundle multiple items together

**Current Schema (qmhq table):**
```sql
-- Single item only
item_id UUID REFERENCES items(id),
quantity DECIMAL(15,2),
warehouse_id UUID REFERENCES warehouses(id),
```

**Extended Schema with Junction Table:**
```sql
-- New table: qmhq_items (many-to-many relationship)
CREATE TABLE qmhq_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  qmhq_id UUID NOT NULL REFERENCES qmhq(id) ON DELETE CASCADE,
  item_id UUID NOT NULL REFERENCES items(id) ON DELETE RESTRICT,
  quantity DECIMAL(15,2) NOT NULL CHECK (quantity > 0),
  warehouse_id UUID REFERENCES warehouses(id),

  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id),

  -- Prevent duplicates
  UNIQUE(qmhq_id, item_id)
);

-- Index for queries
CREATE INDEX idx_qmhq_items_qmhq_id ON qmhq_items(qmhq_id);
CREATE INDEX idx_qmhq_items_item_id ON qmhq_items(item_id);

-- Keep backward compatibility: qmhq.item_id becomes deprecated
-- but don't drop it yet for migration safety
```

**Form State Management:**
```tsx
// Multi-item state (array of objects)
type SelectedItem = {
  id: string;  // Temporary ID for React key
  item_id: string;
  quantity: number;
  warehouse_id: string;
};

const [selectedItems, setSelectedItems] = useState<SelectedItem[]>([]);

// Add item
const handleAddItem = () => {
  setSelectedItems([
    ...selectedItems,
    { id: crypto.randomUUID(), item_id: '', quantity: 1, warehouse_id: '' }
  ]);
};

// Remove item
const handleRemoveItem = (id: string) => {
  setSelectedItems(selectedItems.filter(item => item.id !== id));
};

// Update item field
const handleUpdateItem = (id: string, field: keyof SelectedItem, value: any) => {
  setSelectedItems(selectedItems.map(item =>
    item.id === id ? { ...item, [field]: value } : item
  ));
};
```

**Submission:**
```tsx
const handleSubmit = async () => {
  // 1. Create QMHQ record (without item_id)
  const { data: qmhq } = await supabase
    .from('qmhq')
    .insert({ ...baseData })
    .select()
    .single();

  // 2. Create qmhq_items records
  const { error } = await supabase
    .from('qmhq_items')
    .insert(
      selectedItems.map(item => ({
        qmhq_id: qmhq.id,
        item_id: item.item_id,
        quantity: item.quantity,
        warehouse_id: item.warehouse_id,
        created_by: user.id
      }))
    );
};
```

Sources:
- [Managing Selection States in React](https://medium.com/@rakibshakib/efficiently-managing-selection-states-in-react-a-comprehensive-guide-8ed00f173adb)
- [React Multi-Select Integration](https://medium.com/@triciahughes/how-to-integrate-multiselect-into-your-react-app-d1a9997dc1e1)

### Anti-Patterns to Avoid

**Anti-Pattern 1: Storing multiple items as JSON array in qmhq.item_id**
- Why bad: Cannot query/filter by individual items, no referential integrity, breaks normalization
- Do instead: Use qmhq_items junction table

**Anti-Pattern 2: Creating stock-out in UI onClick handler**
- Why bad: User could close browser, lose connection, or bypass UI
- Do instead: Use PostgreSQL trigger that fires on status change

**Anti-Pattern 3: Changing react-day-picker version to v9**
- Why bad: Major version change requires testing all calendar components, migration effort
- Do instead: Change `captionLayout` prop in v8 (one-line fix)

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| File deletion permissions | Custom permission checker | Existing RLS policies + canEdit prop | Already implemented and tested |
| Calendar navigation | Custom month/year selector | react-day-picker captionLayout | Well-tested library handles edge cases |
| Transaction atomicity | Application-level locks | PostgreSQL trigger + transaction | Database guarantees ACID properties |
| Multi-select state | Custom array manager | React useState with array methods | Standard pattern, well understood |

**Key insight:** All fixes leverage existing infrastructure (RLS, triggers, hooks). No custom solutions needed.

## Common Pitfalls

### Pitfall 1: Attachment Delete Button Hidden by Wrong Permission Check
**What goes wrong:** Delete button doesn't appear even for admin/quartermaster
**Why it happens:** Parent component doesn't pass `canEdit={false}` explicitly, or user role isn't loaded
**How to avoid:**
```tsx
// QMRL/QMHQ detail page
const { user } = useAuth();
const canEdit = user?.role === 'admin' || user?.role === 'quartermaster';

<AttachmentsTab
  entityType="qmrl"
  entityId={qmrl.id}
  entityDisplayId={qmrl.request_id}
  canEdit={canEdit}  // MUST pass explicitly
  onFileCountChange={setFileCount}
/>
```
**Warning signs:**
- Delete icon/button missing in UI
- No error in console
- File operations work fine

### Pitfall 2: Date Picker Dropdown Props Remain After Changing captionLayout
**What goes wrong:** Changing `captionLayout="buttons"` but leaving `fromYear`/`toYear` props causes warnings
**Why it happens:** These props are only valid for dropdown modes
**How to avoid:**
```tsx
// REMOVE fromYear and toYear when using "buttons" mode
<DayPicker
  captionLayout="buttons"
  // fromYear={2020}  // DELETE THIS
  // toYear={2030}    // DELETE THIS
  // ... other props
/>
```
**Warning signs:**
- React warnings in console about unused props
- Dropdowns still appear

### Pitfall 3: Trigger Creates Duplicate Stock-Out Transactions
**What goes wrong:** Multiple inventory_out records created for same QMHQ
**Why it happens:** Trigger fires on every UPDATE, not just status changes to "fulfilled"
**How to avoid:**
```sql
-- Add idempotency check in trigger
IF NOT EXISTS (
  SELECT 1 FROM inventory_transactions
  WHERE qmhq_id = NEW.id
  AND movement_type = 'inventory_out'
  AND reason = 'request'
) THEN
  -- Create transaction
  INSERT INTO inventory_transactions (...) VALUES (...);
END IF;
```
**Warning signs:**
- Multiple stock-out records with same qmhq_id
- Inventory quantity decreases multiple times for one request

### Pitfall 4: Multi-Item Form Doesn't Validate Warehouse Stock
**What goes wrong:** User selects items that aren't available in chosen warehouse
**Why it happens:** Form doesn't check warehouse inventory before submission
**How to avoid:**
```tsx
// Validate stock availability before submit
const validateStock = async () => {
  for (const item of selectedItems) {
    const { data: stock } = await supabase
      .from('warehouse_stock')
      .select('available_quantity')
      .eq('item_id', item.item_id)
      .eq('warehouse_id', item.warehouse_id)
      .single();

    if (!stock || stock.available_quantity < item.quantity) {
      toast({
        title: 'Insufficient stock',
        description: `Item ${item.name} has only ${stock?.available_quantity || 0} units available`
      });
      return false;
    }
  }
  return true;
};
```
**Warning signs:**
- Stock-out transactions fail with negative inventory
- Database constraints violated

### Pitfall 5: Backward Compatibility Broken for Existing Single-Item QMHQ
**What goes wrong:** Existing QMHQ records with item_id don't display after schema change
**Why it happens:** Code only checks qmhq_items table, ignores legacy item_id column
**How to avoid:**
```tsx
// Migration query: Load both new and legacy item data
const { data: items } = await supabase
  .from('qmhq_items')
  .select('*')
  .eq('qmhq_id', qmhq.id);

// Fallback to legacy single item if qmhq_items is empty
if (items.length === 0 && qmhq.item_id) {
  items = [{
    id: 'legacy',
    qmhq_id: qmhq.id,
    item_id: qmhq.item_id,
    quantity: qmhq.quantity,
    warehouse_id: qmhq.warehouse_id
  }];
}
```
**Warning signs:**
- Old QMHQ records show "No items" despite having item_id
- Detail pages crash with null reference errors

## Code Examples

Verified patterns from current codebase and official sources:

### Example 1: Attachment Tab with Correct Permissions
```tsx
// Source: components/files/attachments-tab.tsx (lines 75-115)
interface AttachmentsTabProps {
  entityType: 'qmrl' | 'qmhq';
  entityId: string;
  entityDisplayId: string;
  canEdit?: boolean;  // Defaults to true if not provided
  onFileCountChange?: (count: number) => void;
}

export function AttachmentsTab({
  entityType,
  entityId,
  entityDisplayId,
  canEdit = true,  // DEFAULT IS TRUE - PROBLEM HERE
  onFileCountChange,
}: AttachmentsTabProps) {
  // ... component code

  {/* Drop Zone (only if canEdit) */}
  {canEdit && (
    <FileDropzone
      onFilesAccepted={handleFilesAccepted}
      disabled={progress.isUploading}
    />
  )}
}

// USAGE IN PARENT (QMRL detail page):
const { user } = useAuth();
const canEditAttachments = user?.role === 'admin' || user?.role === 'quartermaster';

<AttachmentsTab
  entityType="qmrl"
  entityId={qmrl.id}
  entityDisplayId={qmrl.request_id}
  canEdit={canEditAttachments}  // Must pass explicitly
  onFileCountChange={setFileCount}
/>
```

### Example 2: Simplified Date Picker (buttons-only mode)
```tsx
// Source: components/ui/calendar.tsx (current implementation)
<DayPicker
  showOutsideDays={showOutsideDays}
  weekStartsOn={1}
  showWeekNumber={false}
  captionLayout="dropdown-buttons"  // CHANGE TO "buttons"
  fromYear={2020}  // REMOVE THIS LINE
  toYear={2030}    // REMOVE THIS LINE
  className={cn("p-3", className)}
  classNames={{
    // ... styling unchanged
  }}
  components={{
    IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
    IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
  }}
  {...props}
/>
```

### Example 3: Status-Triggered Stock-Out (PostgreSQL Trigger)
```sql
-- Source: Based on PostgreSQL trigger patterns
-- Create trigger function
CREATE OR REPLACE FUNCTION auto_stockout_on_qmhq_fulfilled()
RETURNS TRIGGER AS $$
DECLARE
  status_is_fulfilled BOOLEAN;
BEGIN
  -- Check if new status is in 'done' group (fulfilled)
  SELECT status_group = 'done'
  INTO status_is_fulfilled
  FROM status_config
  WHERE id = NEW.status_id;

  -- Only proceed if:
  -- 1. Status changed
  -- 2. New status is 'done' (fulfilled/completed)
  -- 3. Route type is 'item'
  -- 4. Item and warehouse specified
  -- 5. No stock-out exists yet (idempotency)
  IF (OLD.status_id IS DISTINCT FROM NEW.status_id)
     AND status_is_fulfilled
     AND NEW.route_type = 'item'
     AND NEW.item_id IS NOT NULL
     AND NEW.warehouse_id IS NOT NULL
     AND NEW.quantity > 0
     AND NOT EXISTS (
       SELECT 1 FROM inventory_transactions
       WHERE qmhq_id = NEW.id
       AND movement_type = 'inventory_out'
       AND reason = 'request'
     )
  THEN
    -- Create inventory_out transaction
    INSERT INTO inventory_transactions (
      movement_type,
      item_id,
      warehouse_id,
      quantity,
      reason,
      qmhq_id,
      transaction_date,
      notes,
      status,
      created_by
    ) VALUES (
      'inventory_out',
      NEW.item_id,
      NEW.warehouse_id,
      NEW.quantity,
      'request',
      NEW.id,
      CURRENT_DATE,
      'Auto stock-out from QMHQ ' || NEW.request_id || ' (status changed to fulfilled)',
      'completed',
      NEW.updated_by
    );

    RAISE NOTICE 'Created stock-out transaction for QMHQ %', NEW.request_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger
DROP TRIGGER IF EXISTS qmhq_auto_stockout ON qmhq;
CREATE TRIGGER qmhq_auto_stockout
  AFTER UPDATE ON qmhq
  FOR EACH ROW
  EXECUTE FUNCTION auto_stockout_on_qmhq_fulfilled();

COMMENT ON FUNCTION auto_stockout_on_qmhq_fulfilled() IS
  'Automatically creates inventory_out transaction when QMHQ item route status changes to fulfilled';
```

### Example 4: Multi-Item Selection Form State
```tsx
// Source: Based on React best practices for multi-select
import { useState } from 'react';
import { Plus, Trash2 } from 'lucide-react';

type QMHQItem = {
  id: string;  // Client-side ID for React key
  item_id: string;
  quantity: number;
  warehouse_id: string;
};

export function MultiItemForm() {
  const [items, setItems] = useState<QMHQItem[]>([
    { id: crypto.randomUUID(), item_id: '', quantity: 1, warehouse_id: '' }
  ]);

  const handleAddItem = () => {
    setItems([
      ...items,
      { id: crypto.randomUUID(), item_id: '', quantity: 1, warehouse_id: '' }
    ]);
  };

  const handleRemoveItem = (id: string) => {
    if (items.length === 1) return; // Keep at least one
    setItems(items.filter(item => item.id !== id));
  };

  const handleUpdateItem = (id: string, field: keyof Omit<QMHQItem, 'id'>, value: any) => {
    setItems(items.map(item =>
      item.id === id ? { ...item, [field]: value } : item
    ));
  };

  return (
    <div className="space-y-4">
      {items.map((item, index) => (
        <div key={item.id} className="grid grid-cols-12 gap-4">
          <div className="col-span-5">
            <Label>Item {index + 1}</Label>
            <Select
              value={item.item_id}
              onValueChange={(value) => handleUpdateItem(item.id, 'item_id', value)}
            >
              {/* Item options */}
            </Select>
          </div>

          <div className="col-span-2">
            <Label>Quantity</Label>
            <Input
              type="number"
              min="1"
              value={item.quantity}
              onChange={(e) => handleUpdateItem(item.id, 'quantity', parseInt(e.target.value))}
            />
          </div>

          <div className="col-span-4">
            <Label>Warehouse</Label>
            <Select
              value={item.warehouse_id}
              onValueChange={(value) => handleUpdateItem(item.id, 'warehouse_id', value)}
            >
              {/* Warehouse options */}
            </Select>
          </div>

          <div className="col-span-1 flex items-end">
            <Button
              type="button"
              variant="ghost"
              size="icon"
              onClick={() => handleRemoveItem(item.id)}
              disabled={items.length === 1}
            >
              <Trash2 className="h-4 w-4" />
            </Button>
          </div>
        </div>
      ))}

      <Button
        type="button"
        variant="outline"
        onClick={handleAddItem}
        className="w-full"
      >
        <Plus className="mr-2 h-4 w-4" />
        Add Item
      </Button>
    </div>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual file deletion via API | Soft delete with RLS + 30-day grace period | Phase 4 (File Attachments) | RLS policies enforce who can delete; already correct |
| Calendar with all controls | Simplified navigation (buttons only) | This phase | Cleaner UX, less user confusion |
| Manual stock-out after status change | Automatic trigger on status = fulfilled | This phase | Prevents forgetting stock-out step, ensures data integrity |
| Single item per QMHQ | Multiple items via junction table | This phase | Supports realistic request bundling, better data model |

**Deprecated/outdated:**
- ~~captionLayout="dropdown-buttons"~~ - Use "buttons" for simpler navigation
- ~~Single qmhq.item_id column~~ - Migrate to qmhq_items junction table (keep column for backward compatibility during transition)

## Open Questions

1. **Which status name indicates "fulfilled" for QMHQ item routes?**
   - What we know: Status has `status_group` ('to_do', 'in_progress', 'done')
   - What's unclear: Should trigger fire on ANY 'done' status, or specific name like "Completed"?
   - Recommendation: Use `status_group = 'done'` to catch all completion statuses (flexible)

2. **Should multi-item QMHQ allow different warehouses per item?**
   - What we know: Current schema has single warehouse_id on qmhq table
   - What's unclear: Can items be sourced from different warehouses in one request?
   - Recommendation: Allow warehouse_id per item in qmhq_items table (more flexible, realistic)

3. **Migration path for existing single-item QMHQ records?**
   - What we know: Existing records have item_id, quantity, warehouse_id on qmhq table
   - What's unclear: Auto-migrate to qmhq_items, or handle at runtime?
   - Recommendation: Keep qmhq.item_id as fallback (don't drop), handle both in queries during transition

4. **Should stock-out transaction be cancelable if status changes back?**
   - What we know: Trigger creates inventory_out when status = done
   - What's unclear: If user changes status back to "in_progress", should stock be returned?
   - Recommendation: No auto-reversal; require manual inventory adjustment (audit trail clearer)

## Sources

### Primary (HIGH confidence)
- react-day-picker v8.10.1 - [CaptionLayout Type Documentation](https://daypicker.dev/v8/api/type-aliases/CaptionLayout)
- Codebase analysis - components/files/attachments-tab.tsx (lines 75-502)
- Codebase analysis - components/ui/calendar.tsx (lines 12-75)
- Codebase analysis - supabase/migrations/030_file_attachments.sql (RLS policies lines 80-142)
- Codebase analysis - supabase/migrations/023_inventory_transactions.sql (schema)
- Codebase analysis - supabase/migrations/011_qmhq.sql (current single-item schema)

### Secondary (MEDIUM confidence)
- [PostgreSQL Trigger Functions](https://www.postgresql.org/docs/current/plpgsql-trigger.html) - Official docs on trigger syntax
- [PostgreSQL AFTER Triggers](https://www.datacamp.com/doc/postgresql/after-triggers) - Trigger behavior examples
- [Supabase Storage Access Control](https://supabase.com/docs/guides/storage/security/access-control) - RLS for storage
- [React Selection State Management](https://medium.com/@rakibshakib/efficiently-managing-selection-states-in-react-a-comprehensive-guide-8ed00f173adb) - Multi-select patterns

### Tertiary (LOW confidence - general guidance)
- [Next.js File Upload with Server Actions](https://akoskm.com/file-upload-with-nextjs-14-and-server-actions/) - File deletion patterns
- [PostgreSQL Transactions Best Practices](https://iniakunhuda.medium.com/efficient-database-transactions-using-postgresql-best-practices-and-optimization-techniques-9652d4ce53c0) - Transaction management

## Metadata

**Confidence breakdown:**
- Attachment deletion: HIGH - Code exists and works; UI visibility issue only
- Date picker simplification: HIGH - react-day-picker v8 documentation confirms captionLayout="buttons" behavior
- Stock-out automation: HIGH - PostgreSQL trigger pattern is well-established; schema supports it
- Multi-item selection: MEDIUM - Schema extension is straightforward, but requires testing migration path

**Research date:** 2026-01-29
**Valid until:** 60 days (stable domain - React, PostgreSQL, Supabase patterns)
