---
phase: 07.1-attachment-item-route-fixes
plan: 03
subsystem: qmhq-item-route
tags: [qmhq, multi-item, item-route, junction-table]

requires:
  - 07.1-02 (Auto Stock-Out & qmhq_items Table)
provides:
  - Multi-item selection UI in QMHQ item route
  - Junction table integration for qmhq_items
  - Legacy single-item display compatibility
affects:
  - Future: Multi-item stock-out trigger (currently handles legacy only)

tech-stack:
  added: []
  patterns:
    - Multi-item dynamic form with add/remove
    - Client-side UUID for item keys
    - Controlled string input for numbers
    - Legacy fallback pattern for backward compatibility

key-files:
  created: []
  modified:
    - types/database.ts
    - app/(dashboard)/qmhq/new/[route]/page.tsx
    - app/(dashboard)/qmhq/[id]/page.tsx

decisions:
  - title: "String state for quantity inputs"
    rationale: "Allows empty placeholder display and controlled input behavior"
    date: 2026-01-29
  - title: "No unit price in item route form"
    rationale: "Unit price comes from WAC at stock-out time, not at request time"
    date: 2026-01-29
  - title: "Per-item warehouse selection is optional"
    rationale: "User can specify preferred warehouse or leave empty for any warehouse"
    date: 2026-01-29
  - title: "Legacy qmhq.item_id fallback in detail page"
    rationale: "Maintains backward compatibility with existing single-item QMHQ records"
    date: 2026-01-29

metrics:
  duration: 22min
  completed: 2026-01-29
---

# Phase 7.1 Plan 03: Multi-Item Selection for QMHQ Item Route Summary

**One-liner:** Multi-item selection UI for QMHQ item route with junction table integration and legacy fallback

## Overview

Implemented multi-item selection functionality for QMHQ item route requests, allowing users to add multiple items with quantities and optional warehouse selection in a single QMHQ line. Items are stored in the qmhq_items junction table (created in 07.1-02) and displayed with full backward compatibility for legacy single-item records.

## Objectives Completed

- [x] Add QMHQItem and QMHQItemWithRelations type definitions
- [x] Implement multi-item form with add/remove functionality
- [x] Support per-item warehouse selection (optional)
- [x] Remove unit price field from item route (WAC pricing at stock-out)
- [x] Insert items to qmhq_items junction table after QMHQ creation
- [x] Display multiple items in QMHQ detail page
- [x] Maintain backward compatibility with legacy single-item QMHQ

## Implementation Details

### Task 1: QMHQItem Type Definition

**File:** `types/database.ts`

Added TypeScript types for the qmhq_items junction table:

```typescript
// QMHQ Items junction table (for multi-item requests)
export interface QMHQItem {
  id: string;
  qmhq_id: string;
  item_id: string;
  quantity: number;
  warehouse_id: string | null;
  created_at: string;
  created_by: string | null;
}

// Extended type with relations for display
export interface QMHQItemWithRelations extends QMHQItem {
  item?: Item | null;
  warehouse?: Warehouse | null;
}
```

Also added full qmhq_items table definition to Database type for Supabase client.

### Task 2: Multi-Item Form Implementation

**File:** `app/(dashboard)/qmhq/new/[route]/page.tsx`

**Key Changes:**

1. **State Management:**
   - Replaced single-item state (`selectedItemId`, `quantity`) with `selectedItems` array
   - Added `warehouses` state for warehouse dropdown
   - Each item has client-side UUID for React keys

2. **Item Management Handlers:**
   ```typescript
   const handleAddItem = () => {
     setSelectedItems([
       ...selectedItems,
       { id: crypto.randomUUID(), item_id: '', quantity: '', warehouse_id: '' }
     ]);
   };

   const handleRemoveItem = (id: string) => {
     if (selectedItems.length === 1) return; // Keep at least one
     setSelectedItems(selectedItems.filter(item => item.id !== id));
   };

   const handleUpdateItem = (id: string, field: keyof Omit<SelectedItem, 'id'>, value: string) => {
     setSelectedItems(selectedItems.map(item =>
       item.id === id ? { ...item, [field]: value } : item
     ));
   };
   ```

3. **Data Fetching:**
   - Parallel fetch of items and warehouses when route is "item"
   - Warehouses used for optional per-item warehouse selection

4. **Validation:**
   - At least one item with valid quantity required
   - Filter validItems before insertion: `item.item_id && parseFloat(item.quantity) > 0`

5. **Insertion Logic:**
   ```typescript
   // Create QMHQ with null legacy fields
   const { data: qmhqData, error: qmhqError } = await supabase
     .from("qmhq")
     .insert({
       ...baseData,
       item_id: null,
       quantity: null,
       warehouse_id: null,
     })
     .select()
     .single();

   // Insert items into junction table
   const { error: itemsError } = await supabase
     .from("qmhq_items")
     .insert(
       validItems.map(item => ({
         qmhq_id: qmhqData.id,
         item_id: item.item_id,
         quantity: parseFloat(item.quantity),
         warehouse_id: item.warehouse_id || null,
         created_by: user.id,
       }))
     );
   ```

6. **UI:**
   - Grid layout with item number, item select, quantity, warehouse, and remove button
   - Add Another Item button with dashed border
   - No unit price field (as per requirements)
   - Info panel updated: "Stock will be automatically deducted when this request is marked as fulfilled"

### Task 3: Multi-Item Display in QMHQ Detail

**File:** `app/(dashboard)/qmhq/[id]/page.tsx`

**Key Changes:**

1. **State:** Added `qmhqItems` state for storing multiple items with relations

2. **Data Fetching with Legacy Fallback:**
   ```typescript
   if (qmhqData && qmhqData.route_type === 'item') {
     // Try to fetch from junction table
     const { data: itemsData } = await supabase
       .from('qmhq_items')
       .select(`
         *,
         item:items(id, name, sku, default_unit),
         warehouse:warehouses(id, name)
       `)
       .eq('qmhq_id', qmhqData.id);

     if (itemsData && itemsData.length > 0) {
       setQmhqItems(itemsData);
     } else if (qmhqData.item_id) {
       // Fallback for legacy single-item QMHQ
       const legacyItem = await fetchLegacyItem(qmhqData.item_id);
       const legacyWarehouse = qmhqData.warehouse_id
         ? await fetchLegacyWarehouse(qmhqData.warehouse_id)
         : null;

       setQmhqItems([{
         id: 'legacy',
         qmhq_id: qmhqData.id,
         item_id: qmhqData.item_id,
         quantity: qmhqData.quantity || 0,
         warehouse_id: qmhqData.warehouse_id,
         created_at: qmhqData.created_at,
         created_by: qmhqData.created_by,
         item: legacyItem,
         warehouse: legacyWarehouse,
       }]);
     }
   }
   ```

3. **Display:**
   - Replaced single-item card with multi-item list
   - Title shows count: "Requested Items ({qmhqItems.length})"
   - Each item displays: #, SKU, name, warehouse (if specified), quantity with unit
   - Full width (lg:col-span-2) for multi-item table

## Technical Decisions

### Why String State for Quantity Inputs?

Using string state (`quantity: string`) instead of number allows:
- Empty placeholder display before user enters value
- Controlled input behavior without auto-coercion
- Pattern established in 07-01 for number inputs

Conversion to float happens only at validation and submission.

### Why No Unit Price Field?

The item route is for inventory requests, not procurement. Pricing comes from:
- **WAC (Weighted Average Cost)** at stock-out time
- Not known/relevant at request time
- Different from PO route which has unit prices for procurement

### Why Per-Item Warehouse Selection?

Flexibility for multi-item requests where:
- Different items may come from different warehouses
- User can specify preferred warehouse or leave empty for "any warehouse"
- Stored in junction table for reference during fulfillment

### Legacy Compatibility Strategy

The detail page implements a fallback:
1. Try to load from qmhq_items (new multi-item)
2. If empty but qmhq.item_id exists, construct legacy item object
3. Display both cases identically

This ensures:
- Existing single-item QMHQ records continue to display correctly
- No migration required
- Gradual transition to multi-item system

## Files Changed

### Created
None (junction table created in 07.1-02)

### Modified

1. **types/database.ts**
   - Added QMHQItem and QMHQItemWithRelations interfaces
   - Added qmhq_items table to Database type (Row, Insert, Update, Relationships)

2. **app/(dashboard)/qmhq/new/[route]/page.tsx**
   - Added Trash2 icon import
   - Added SelectedItem type definition
   - Replaced single-item state with selectedItems array
   - Added warehouses state
   - Updated fetchRouteData to fetch warehouses
   - Added handleAddItem, handleRemoveItem, handleUpdateItem
   - Updated validation for multi-item
   - Updated insert logic to create QMHQ then insert items to junction table
   - Updated handleBack to save selectedItems
   - Replaced single-item form with multi-item grid layout

3. **app/(dashboard)/qmhq/[id]/page.tsx**
   - Added QMHQItem, Warehouse imports
   - Added QMHQItemWithRelations type
   - Added qmhqItems state
   - Updated fetchData to query qmhq_items with legacy fallback
   - Replaced single-item display with multi-item table showing all items

## Testing Performed

- [x] Type check passes
- [x] Build completes successfully
- [x] Multi-item form renders with add/remove functionality
- [x] Junction table insert tested (qmhq_items records created)
- [x] Detail page displays multiple items
- [x] Legacy single-item records display correctly

## Next Phase Readiness

**Blockers:** None

**Concerns:**
- Auto stock-out trigger (from 07.1-02) currently handles only legacy single-item QMHQ
- Multi-item trigger enhancement needed for future phase
- Documented in 07.1-02-SUMMARY.md as known limitation

**Recommendations:**
- Future phase: Update auto_stock_out_on_qmhq_done trigger to loop through qmhq_items
- Consider warehouse selection impact on stock-out logic

## Deviations from Plan

None - plan executed exactly as written.

## Commits

1. `598a521` - feat(07.1-03): add QMHQItem type definition
   - QMHQItem and QMHQItemWithRelations interfaces
   - qmhq_items table in Database type

2. `11777c2` - feat(07.1-03): implement multi-item form for QMHQ item route
   - Multi-item state management with add/remove/update handlers
   - Warehouse fetching and per-item warehouse selection
   - Updated validation and insert logic for junction table
   - Multi-item UI with grid layout

3. `549d742` - feat(07.1-03): update QMHQ detail page for multi-item display
   - QMHQItemWithRelations type with item and warehouse
   - qmhq_items fetch with legacy fallback
   - Multi-item table display replacing single-item card

## Lessons Learned

1. **Database Type Completeness:** Needed to add qmhq_items table to Database type even though migration existed - type checking caught this immediately

2. **Legacy Fallback Pattern:** Constructing legacy item object from qmhq.item_id ensures seamless backward compatibility without data migration

3. **Client-side UUID Keys:** Using crypto.randomUUID() for selectedItems array provides stable React keys before database insertion

4. **Parallel Fetching:** Fetching items and warehouses in parallel with Promise.all improves loading performance

## Phase 7.1 Progress

- [x] 07.1-01: Attachment & Calendar UX Fixes
- [x] 07.1-02: Auto Stock-Out & Multi-Item QMHQ
- [x] 07.1-03: Multi-Item Selection UI (CURRENT)
- [ ] Next: Phase complete

Phase 7.1 complete with all urgent fixes delivered!
