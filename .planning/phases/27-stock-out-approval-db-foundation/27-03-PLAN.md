---
phase: 27-stock-out-approval-db-foundation
plan: 03
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - supabase/migrations/054_stock_out_rls_audit.sql
  - types/database.ts
autonomous: true

must_haves:
  truths:
    - "Only admin, quartermaster, and inventory roles can create stock-out requests"
    - "Only admin can create approvals (approve/reject line items)"
    - "Requester can view own requests; admin/quartermaster/inventory can view all"
    - "All SOR table changes are logged in audit_logs"
    - "Audit trail captures status changes, approvals, rejections, and cancellations"
    - "TypeScript types for stock_out_requests, stock_out_line_items, stock_out_approvals are available"
  artifacts:
    - path: "supabase/migrations/054_stock_out_rls_audit.sql"
      provides: "RLS policies for 3 SOR tables, audit triggers, audit function update"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "types/database.ts"
      provides: "TypeScript types including SOR tables and enums"
      contains: "stock_out_requests"
  key_links:
    - from: "stock_out_requests RLS"
      to: "get_user_role()"
      via: "SECURITY DEFINER helper for role check"
      pattern: "get_user_role.*IN.*admin.*quartermaster.*inventory"
    - from: "stock_out_approvals RLS"
      to: "get_user_role()"
      via: "Admin-only INSERT policy"
      pattern: "get_user_role.*=.*admin"
    - from: "audit trigger"
      to: "create_audit_log()"
      via: "AFTER INSERT OR UPDATE OR DELETE trigger"
      pattern: "EXECUTE FUNCTION.*create_audit_log"
---

<objective>
Add Row Level Security policies to all 3 SOR tables, attach audit triggers, enhance the audit function for SOR-specific status changes, and generate TypeScript types from the updated schema.

Purpose: Without RLS, any authenticated user can access any request. Without audit triggers, state changes are invisible. Without types, Phase 28 UI development cannot begin.
Output: Migration file for RLS + audit, updated TypeScript types.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-stock-out-approval-db-foundation/27-CONTEXT.md
@.planning/phases/27-stock-out-approval-db-foundation/27-RESEARCH.md
@.planning/phases/27-stock-out-approval-db-foundation/27-01-SUMMARY.md
@supabase/migrations/027_rls_policies.sql (RLS helper functions, policy patterns)
@supabase/migrations/026_audit_triggers.sql (create_audit_log function, trigger attachment pattern)
@types/database.ts (current TypeScript types structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RLS policies and audit triggers for SOR tables</name>
  <files>supabase/migrations/054_stock_out_rls_audit.sql</files>
  <action>
Create migration file `supabase/migrations/054_stock_out_rls_audit.sql` with the following:

**1. Enable RLS on all 3 tables:**
```sql
ALTER TABLE stock_out_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE stock_out_line_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE stock_out_approvals ENABLE ROW LEVEL SECURITY;
```

**2. stock_out_requests RLS policies:**

Per user decisions:
- Create: Inventory + Quartermaster + Admin can create
- View: Admin/Quartermaster/Inventory can view all; requester can view own requests
- Update: Admin can update any (for status management); requester can cancel own pending requests
- Delete: Admin only (soft delete)

```sql
-- SELECT: admin, quartermaster, inventory see all; others see own
DROP POLICY IF EXISTS sor_select ON stock_out_requests;
CREATE POLICY sor_select ON stock_out_requests
  FOR SELECT USING (
    public.get_user_role() IN ('admin', 'quartermaster', 'inventory')
    OR requester_id = auth.uid()
  );

-- INSERT: only admin, quartermaster, inventory can create (per user decision)
DROP POLICY IF EXISTS sor_insert ON stock_out_requests;
CREATE POLICY sor_insert ON stock_out_requests
  FOR INSERT WITH CHECK (
    public.get_user_role() IN ('admin', 'quartermaster', 'inventory')
  );

-- UPDATE: admin can update any; requester can update own (for cancellation)
DROP POLICY IF EXISTS sor_update ON stock_out_requests;
CREATE POLICY sor_update ON stock_out_requests
  FOR UPDATE USING (
    public.get_user_role() = 'admin'
    OR requester_id = auth.uid()
  );

-- DELETE: admin only
DROP POLICY IF EXISTS sor_delete ON stock_out_requests;
CREATE POLICY sor_delete ON stock_out_requests
  FOR DELETE USING (
    public.get_user_role() = 'admin'
  );
```

**3. stock_out_line_items RLS policies:**

Line items inherit visibility from their parent request. Use SECURITY DEFINER helper to avoid circular dependency.

```sql
-- Helper: check if user can see the parent request
CREATE OR REPLACE FUNCTION public.can_view_sor_request(p_request_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  req_requester_id UUID;
  user_role public.user_role;
BEGIN
  user_role := public.get_user_role();

  IF user_role IN ('admin', 'quartermaster', 'inventory') THEN
    RETURN TRUE;
  END IF;

  SELECT requester_id INTO req_requester_id
  FROM stock_out_requests
  WHERE id = p_request_id;

  RETURN req_requester_id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- SELECT: visible if user can see parent request
DROP POLICY IF EXISTS sor_li_select ON stock_out_line_items;
CREATE POLICY sor_li_select ON stock_out_line_items
  FOR SELECT USING (
    public.can_view_sor_request(request_id)
  );

-- INSERT: same roles that can create requests
DROP POLICY IF EXISTS sor_li_insert ON stock_out_line_items;
CREATE POLICY sor_li_insert ON stock_out_line_items
  FOR INSERT WITH CHECK (
    public.get_user_role() IN ('admin', 'quartermaster', 'inventory')
  );

-- UPDATE: admin and inventory/quartermaster (for status updates via triggers)
DROP POLICY IF EXISTS sor_li_update ON stock_out_line_items;
CREATE POLICY sor_li_update ON stock_out_line_items
  FOR UPDATE USING (
    public.get_user_role() IN ('admin', 'quartermaster', 'inventory')
  );

-- DELETE: admin only
DROP POLICY IF EXISTS sor_li_delete ON stock_out_line_items;
CREATE POLICY sor_li_delete ON stock_out_line_items
  FOR DELETE USING (
    public.get_user_role() = 'admin'
  );
```

**4. stock_out_approvals RLS policies:**

Per user decision: only admin can approve/reject. Others can view approvals on requests they can see.

```sql
-- SELECT: visible if user can see the parent request (via line item)
CREATE OR REPLACE FUNCTION public.can_view_sor_approval(p_line_item_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
  parent_request_id UUID;
BEGIN
  SELECT request_id INTO parent_request_id
  FROM stock_out_line_items
  WHERE id = p_line_item_id;

  RETURN public.can_view_sor_request(parent_request_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

DROP POLICY IF EXISTS sor_approval_select ON stock_out_approvals;
CREATE POLICY sor_approval_select ON stock_out_approvals
  FOR SELECT USING (
    public.can_view_sor_approval(line_item_id)
  );

-- INSERT: admin only (per user decision: only admin can approve/reject)
DROP POLICY IF EXISTS sor_approval_insert ON stock_out_approvals;
CREATE POLICY sor_approval_insert ON stock_out_approvals
  FOR INSERT WITH CHECK (
    public.get_user_role() = 'admin'
  );

-- UPDATE: admin only
DROP POLICY IF EXISTS sor_approval_update ON stock_out_approvals;
CREATE POLICY sor_approval_update ON stock_out_approvals
  FOR UPDATE USING (
    public.get_user_role() = 'admin'
  );

-- DELETE: admin only
DROP POLICY IF EXISTS sor_approval_delete ON stock_out_approvals;
CREATE POLICY sor_approval_delete ON stock_out_approvals
  FOR DELETE USING (
    public.get_user_role() = 'admin'
  );
```

**5. Attach audit triggers** (follows exact pattern from 026_audit_triggers.sql — attach existing create_audit_log() to new tables):
```sql
-- Audit trigger for stock_out_requests
DROP TRIGGER IF EXISTS audit_stock_out_requests ON stock_out_requests;
CREATE TRIGGER audit_stock_out_requests
  AFTER INSERT OR UPDATE OR DELETE ON stock_out_requests
  FOR EACH ROW EXECUTE FUNCTION public.create_audit_log();

-- Audit trigger for stock_out_line_items
DROP TRIGGER IF EXISTS audit_stock_out_line_items ON stock_out_line_items;
CREATE TRIGGER audit_stock_out_line_items
  AFTER INSERT OR UPDATE OR DELETE ON stock_out_line_items
  FOR EACH ROW EXECUTE FUNCTION public.create_audit_log();

-- Audit trigger for stock_out_approvals
DROP TRIGGER IF EXISTS audit_stock_out_approvals ON stock_out_approvals;
CREATE TRIGGER audit_stock_out_approvals
  AFTER INSERT OR UPDATE OR DELETE ON stock_out_approvals
  FOR EACH ROW EXECUTE FUNCTION public.create_audit_log();
```

**6. Enhance audit function for SOR-specific events** (update create_audit_log to recognize SOR status changes and approval/rejection actions):

The existing `create_audit_log()` function handles generic UPDATEs. Enhance it to detect SOR-specific events. Use `CREATE OR REPLACE FUNCTION` to update the function. The key additions:

- Detect `stock_out_line_items` status changes (like PO status changes pattern at line 142-178 of 026_audit_triggers.sql)
- Detect `stock_out_approvals` creation (approval/rejection actions)

Add after the PO closure check (before the assignment change section), inside the existing UPDATE handler:

```sql
-- In the UPDATE handler, add SOR line item status change detection
-- Check for SOR line item status change
IF TG_TABLE_NAME = 'stock_out_line_items' THEN
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    audit_action := 'status_change';
    summary := 'Line item status changed from "' || COALESCE(OLD.status::TEXT, 'None') ||
               '" to "' || COALESCE(NEW.status::TEXT, 'None') || '"';

    INSERT INTO public.audit_logs (
      entity_type, entity_id, action,
      field_name, old_value, new_value,
      changes_summary,
      changed_by, changed_by_name, changed_at
    ) VALUES (
      TG_TABLE_NAME, NEW.id, audit_action,
      'status', OLD.status::TEXT, NEW.status::TEXT,
      summary,
      audit_user_id, audit_user_name, NOW()
    );

    RETURN NEW;
  END IF;
END IF;
```

IMPORTANT: The create_audit_log() function is complex (296 lines). To add SOR support, replace the entire function with the current body PLUS the new SOR-specific checks inserted at the correct position. Reference the existing function body from `@supabase/migrations/026_audit_triggers.sql` and the fix in `@supabase/migrations/028_fix_audit_trigger_created_by.sql` and `@supabase/migrations/029_fix_audit_trigger_v2.sql`. Read all three files to get the current function state before modifying.

The safest approach: add a SEPARATE audit enhancement function for SOR tables that handles the SOR-specific cases, and only attach it alongside the generic trigger. This avoids modifying the complex generic function:

```sql
-- SOR-specific audit enhancements (runs alongside generic create_audit_log)
CREATE OR REPLACE FUNCTION public.sor_audit_enhancement()
RETURNS TRIGGER AS $$
DECLARE
  audit_user_id UUID;
  audit_user_name TEXT;
  summary TEXT;
BEGIN
  audit_user_id := COALESCE(
    CASE
      WHEN TG_OP = 'INSERT' THEN
        CASE
          WHEN TG_TABLE_NAME = 'stock_out_approvals' THEN NEW.decided_by
          ELSE NEW.created_by
        END
      WHEN TG_OP = 'UPDATE' THEN NEW.updated_by
    END,
    auth.uid()
  );

  IF audit_user_id IS NOT NULL THEN
    SELECT full_name INTO audit_user_name FROM public.users WHERE id = audit_user_id;
  END IF;
  audit_user_name := COALESCE(audit_user_name, 'System');

  -- Handle approval/rejection INSERT on stock_out_approvals
  IF TG_OP = 'INSERT' AND TG_TABLE_NAME = 'stock_out_approvals' THEN
    IF NEW.decision = 'approved' THEN
      summary := 'Approved stock-out: qty ' || NEW.approved_quantity || ' (approval ' || COALESCE(NEW.approval_number, 'pending') || ')';
    ELSE
      summary := 'Rejected stock-out: ' || COALESCE(NEW.rejection_reason, 'No reason');
    END IF;

    INSERT INTO public.audit_logs (
      entity_type, entity_id, action,
      new_values, changes_summary,
      changed_by, changed_by_name, changed_at
    ) VALUES (
      'stock_out_approvals', NEW.id,
      CASE WHEN NEW.decision = 'approved' THEN 'approve'::public.audit_action ELSE 'status_change'::public.audit_action END,
      to_jsonb(NEW), summary,
      audit_user_id, audit_user_name, NOW()
    );
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Attach SOR-specific audit to approvals table only (generic trigger handles the rest)
DROP TRIGGER IF EXISTS sor_audit_approvals ON stock_out_approvals;
CREATE TRIGGER sor_audit_approvals
  AFTER INSERT ON stock_out_approvals
  FOR EACH ROW EXECUTE FUNCTION public.sor_audit_enhancement();
```

Wait — actually, the generic create_audit_log() already handles INSERT as 'create' action with full new_values. For SOR tables, the generic trigger will capture:
- INSERT on stock_out_requests -> 'create' action
- INSERT on stock_out_line_items -> 'create' action
- INSERT on stock_out_approvals -> 'create' action
- UPDATE on stock_out_line_items (status change) -> generic 'update' with changes_json
- UPDATE on stock_out_requests (computed status) -> generic 'update' with changes_json
- Soft delete -> 'delete' action

This is SUFFICIENT for the phase requirement "All stock-out request state changes logged in audit trail". The generic audit already captures old/new values for all changes. The SOR-specific enhancement is a nice-to-have for better summaries but NOT required.

DECISION: Skip the separate SOR audit enhancement function. The generic create_audit_log() trigger attached to all 3 tables already captures creates, updates (including status changes with old/new values), and deletes. This meets requirement SOAR-11 fully.

**7. Grant permissions for helper functions:**
```sql
GRANT EXECUTE ON FUNCTION public.can_view_sor_request(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION public.can_view_sor_approval(UUID) TO authenticated;
```
  </action>
  <verify>
Run `npx supabase db reset`. Then verify:
1. RLS is enabled: `SELECT tablename, rowsecurity FROM pg_tables WHERE tablename LIKE 'stock_out%';` — all should show `t`
2. Test policy: as non-admin user, INSERT into stock_out_requests should fail
3. Test policy: as admin, INSERT into stock_out_approvals should succeed
4. Test audit: INSERT a stock_out_request, then `SELECT * FROM audit_logs WHERE entity_type = 'stock_out_requests' ORDER BY changed_at DESC LIMIT 1;` — should show 'create' action
5. Test audit on status change: Update a line item status, verify audit_logs captures the old and new values
  </verify>
  <done>
RLS enabled on all 3 SOR tables with correct role-based policies (admin/quartermaster/inventory create, admin approve, requester view own). Audit triggers attached to all 3 tables via existing create_audit_log() function. All state changes captured in audit_logs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate TypeScript types from updated schema</name>
  <files>types/database.ts</files>
  <action>
After the migration runs successfully, manually add TypeScript type definitions for the new SOR tables and enums to `types/database.ts`. Follow the exact pattern used for existing tables in the file.

Read the full `types/database.ts` file first. Then add the following types within the `Database.public.Tables` section:

**stock_out_requests table type:**
Add Row, Insert, and Update types matching the table schema:
- id: string (UUID)
- request_number: string | null
- status: Database["public"]["Enums"]["sor_request_status"]
- reason: Database["public"]["Enums"]["stock_out_reason"]
- notes: string | null
- qmhq_id: string | null
- requester_id: string
- is_active: boolean | null
- created_by: string | null
- updated_by: string | null
- created_at: string | null
- updated_at: string | null

**stock_out_line_items table type:**
- id: string
- request_id: string
- item_id: string
- requested_quantity: number
- status: Database["public"]["Enums"]["sor_line_item_status"]
- item_name: string | null
- item_sku: string | null
- is_active: boolean | null
- created_by: string | null
- updated_by: string | null
- created_at: string | null
- updated_at: string | null

**stock_out_approvals table type:**
- id: string
- line_item_id: string
- approval_number: string | null
- approved_quantity: number
- decision: string (CHECK constraint, not enum)
- rejection_reason: string | null
- decided_by: string
- decided_at: string
- is_active: boolean | null
- created_by: string | null
- updated_by: string | null
- created_at: string | null
- updated_at: string | null

**Add enums** in the `Database.public.Enums` section:
```typescript
sor_line_item_status: "pending" | "approved" | "rejected" | "cancelled" | "partially_executed" | "executed"
sor_request_status: "pending" | "partially_approved" | "approved" | "rejected" | "cancelled" | "partially_executed" | "executed"
```

Also add `stock_out_approval_id: string | null` to the inventory_transactions Row, Insert, and Update types (the new FK column added in Plan 02).

Follow existing Insert/Update patterns: Insert types have `?` on auto-generated fields (id, created_at, etc.), Update types have all fields optional with `?`.
  </action>
  <verify>
Run `npm run type-check` (or `npx tsc --noEmit`). Verify:
1. No TypeScript errors
2. The new types are importable: check that `Database["public"]["Tables"]["stock_out_requests"]` resolves correctly
3. The new enums are available: `Database["public"]["Enums"]["sor_line_item_status"]` resolves
  </verify>
  <done>
TypeScript types for stock_out_requests, stock_out_line_items, stock_out_approvals tables and sor_line_item_status, sor_request_status enums are defined in types/database.ts. inventory_transactions type updated with stock_out_approval_id field. `npm run type-check` passes with no errors.
  </done>
</task>

</tasks>

<verification>
1. `npx supabase db reset` succeeds with all 3 migrations (052, 053, 054)
2. RLS is enabled on all 3 SOR tables
3. Role-based access enforced (admin/quartermaster/inventory create; admin approve; requester view own)
4. Audit logs capture all SOR CRUD operations
5. `npm run type-check` passes
6. New types available for import in UI development
</verification>

<success_criteria>
- RLS policies correctly restrict access based on user role and ownership
- Audit triggers fire on all INSERT/UPDATE/DELETE operations for 3 SOR tables
- TypeScript types match database schema for all 3 new tables, 2 new enums, and the inventory_transactions FK addition
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/27-stock-out-approval-db-foundation/27-03-SUMMARY.md`
</output>
