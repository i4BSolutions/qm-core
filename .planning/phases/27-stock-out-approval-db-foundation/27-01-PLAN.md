---
phase: 27-stock-out-approval-db-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/052_stock_out_requests.sql
autonomous: true

must_haves:
  truths:
    - "stock_out_requests table exists with request_number, reason, notes, qmhq_id fields"
    - "stock_out_line_items table exists with item_id, requested_quantity, item_name, item_sku snapshot fields"
    - "stock_out_approvals table exists with approved_quantity, approved_by, approval_number"
    - "SOR request number auto-generates as SOR-YYYY-NNNNN on insert"
    - "Approval number auto-generates as SOR-YYYY-NNNNN-A01, SOR-YYYY-NNNNN-A02 sequential per request"
    - "Line item status defaults to 'pending' and SOR request status is computed from line items"
    - "Item name and SKU are snapshotted on line item creation"
    - "QMHQ-linked SOR enforces exactly one line item"
    - "Standalone SOR allows multiple line items"
  artifacts:
    - path: "supabase/migrations/052_stock_out_requests.sql"
      provides: "SOR tables, enums, ID generation, snapshot trigger, computed status"
      contains: "CREATE TABLE stock_out_requests"
  key_links:
    - from: "stock_out_requests"
      to: "qmhq"
      via: "qmhq_id FK (nullable, UNIQUE for 1:1)"
      pattern: "qmhq_id UUID.*REFERENCES qmhq"
    - from: "stock_out_line_items"
      to: "stock_out_requests"
      via: "request_id FK"
      pattern: "request_id UUID.*REFERENCES stock_out_requests"
    - from: "stock_out_line_items"
      to: "items"
      via: "item_id FK"
      pattern: "item_id UUID.*REFERENCES items"
    - from: "stock_out_approvals"
      to: "stock_out_line_items"
      via: "line_item_id FK"
      pattern: "line_item_id UUID.*REFERENCES stock_out_line_items"
---

<objective>
Create the three core tables for the stock-out approval workflow: stock_out_requests, stock_out_line_items, and stock_out_approvals. This establishes the 4-level entity hierarchy (Request -> Line Items -> Approvals -> inventory_transactions) with auto-generated IDs, snapshot triggers, and computed request status.

Purpose: Foundation tables must exist before validation triggers, RLS policies, and audit can be layered on.
Output: Single migration file creating the complete SOR schema.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-stock-out-approval-db-foundation/27-CONTEXT.md
@.planning/phases/27-stock-out-approval-db-foundation/27-RESEARCH.md
@supabase/migrations/009_qmrl.sql (ID generation pattern: generate_qmrl_request_id)
@supabase/migrations/015_purchase_orders.sql (PO number generation pattern, approval_status enum)
@supabase/migrations/023_inventory_transactions.sql (stock_out_reason enum already exists, snapshot pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SOR enums and stock_out_requests table</name>
  <files>supabase/migrations/052_stock_out_requests.sql</files>
  <action>
Create migration file `supabase/migrations/052_stock_out_requests.sql` with the following content in this exact order:

**1. Line item status enum:**
```sql
DO $$ BEGIN
  CREATE TYPE sor_line_item_status AS ENUM (
    'pending',
    'approved',
    'rejected',
    'cancelled',
    'partially_executed',
    'executed'
  );
EXCEPTION WHEN duplicate_object THEN null;
END $$;
```
Per user decision: status flow is pending -> approved/rejected/cancelled -> partially_executed -> executed.

**2. Computed request status enum:**
```sql
DO $$ BEGIN
  CREATE TYPE sor_request_status AS ENUM (
    'pending',
    'partially_approved',
    'approved',
    'rejected',
    'cancelled',
    'partially_executed',
    'executed'
  );
EXCEPTION WHEN duplicate_object THEN null;
END $$;
```
Per user decision: SOR request status is computed from line items, not independently managed. This enum captures the aggregate states.

**3. stock_out_requests table:**
```sql
CREATE TABLE IF NOT EXISTS stock_out_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  request_number TEXT UNIQUE,  -- Auto-generated: SOR-YYYY-NNNNN

  -- Computed status (derived from line items, not set directly)
  status sor_request_status NOT NULL DEFAULT 'pending',

  -- Request metadata
  reason stock_out_reason NOT NULL,  -- Reuse existing enum from 023
  notes TEXT,

  -- Optional QMHQ link (1:1 relationship per user decision)
  qmhq_id UUID REFERENCES qmhq(id) ON DELETE SET NULL,

  -- Requester
  requester_id UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,

  -- Audit fields
  is_active BOOLEAN DEFAULT true,
  created_by UUID REFERENCES users(id),
  updated_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

Add UNIQUE constraint on qmhq_id (nullable unique — allows NULLs but enforces 1:1 when linked):
```sql
CREATE UNIQUE INDEX idx_stock_out_requests_qmhq_unique
  ON stock_out_requests(qmhq_id) WHERE qmhq_id IS NOT NULL;
```

**4. stock_out_line_items table:**
```sql
CREATE TABLE IF NOT EXISTS stock_out_line_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Parent request
  request_id UUID NOT NULL REFERENCES stock_out_requests(id) ON DELETE CASCADE,

  -- Item reference
  item_id UUID NOT NULL REFERENCES items(id) ON DELETE RESTRICT,

  -- Quantity
  requested_quantity DECIMAL(15,2) NOT NULL CHECK (requested_quantity > 0),

  -- Line item status (per user decision: pending -> approved/rejected/cancelled -> partially_executed -> executed)
  status sor_line_item_status NOT NULL DEFAULT 'pending',

  -- Snapshot fields (per user decision: snapshot item name and SKU at creation time)
  item_name TEXT,
  item_sku TEXT,

  -- Audit fields
  is_active BOOLEAN DEFAULT true,
  created_by UUID REFERENCES users(id),
  updated_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**5. stock_out_approvals table:**
Per user decision: multiple approvals per line item, each for a portion (sum of all approvals <= requested qty).
```sql
CREATE TABLE IF NOT EXISTS stock_out_approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Parent line item
  line_item_id UUID NOT NULL REFERENCES stock_out_line_items(id) ON DELETE CASCADE,

  -- Approval number: SOR-YYYY-NNNNN-A01 (auto-generated)
  approval_number TEXT UNIQUE,

  -- Approved quantity (per user decision: approved_quantity <= remaining unallotted quantity of line item)
  approved_quantity DECIMAL(15,2) NOT NULL CHECK (approved_quantity > 0),

  -- Decision
  decision TEXT NOT NULL CHECK (decision IN ('approved', 'rejected')),

  -- Rejection reason (per user decision: mandatory when rejected)
  rejection_reason TEXT,

  -- Who approved/rejected (per user decision: only admin can approve/reject)
  decided_by UUID NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
  decided_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Audit fields
  is_active BOOLEAN DEFAULT true,
  created_by UUID REFERENCES users(id),
  updated_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Constraint: rejection_reason mandatory when rejected (per user decision)
ALTER TABLE stock_out_approvals ADD CONSTRAINT rejection_reason_required
  CHECK (decision != 'rejected' OR rejection_reason IS NOT NULL);
```

**6. Indexes for all three tables:**
```sql
-- stock_out_requests indexes
CREATE INDEX idx_sor_status ON stock_out_requests(status);
CREATE INDEX idx_sor_reason ON stock_out_requests(reason);
CREATE INDEX idx_sor_requester ON stock_out_requests(requester_id);
CREATE INDEX idx_sor_is_active ON stock_out_requests(is_active) WHERE is_active = true;
CREATE INDEX idx_sor_created_at ON stock_out_requests(created_at DESC);

-- stock_out_line_items indexes
CREATE INDEX idx_sor_li_request ON stock_out_line_items(request_id);
CREATE INDEX idx_sor_li_item ON stock_out_line_items(item_id);
CREATE INDEX idx_sor_li_status ON stock_out_line_items(status);
CREATE INDEX idx_sor_li_is_active ON stock_out_line_items(is_active) WHERE is_active = true;

-- stock_out_approvals indexes
CREATE INDEX idx_sor_approval_line_item ON stock_out_approvals(line_item_id);
CREATE INDEX idx_sor_approval_decided_by ON stock_out_approvals(decided_by);
CREATE INDEX idx_sor_approval_decision ON stock_out_approvals(decision);
CREATE INDEX idx_sor_approval_is_active ON stock_out_approvals(is_active) WHERE is_active = true;
```

**7. Updated_at triggers** (reuse existing update_updated_at_column function from QMRL migration or define if not available):
```sql
CREATE TRIGGER update_sor_updated_at
  BEFORE UPDATE ON stock_out_requests
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sor_li_updated_at
  BEFORE UPDATE ON stock_out_line_items
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sor_approval_updated_at
  BEFORE UPDATE ON stock_out_approvals
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**8. SOR request number generation** (follows exact pattern from generate_qmrl_request_id):
```sql
CREATE OR REPLACE FUNCTION generate_sor_request_number()
RETURNS TRIGGER AS $$
DECLARE
  current_year TEXT;
  next_number INT;
BEGIN
  current_year := EXTRACT(YEAR FROM CURRENT_DATE)::TEXT;
  SELECT COALESCE(MAX(
    CAST(SUBSTRING(request_number FROM 'SOR-' || current_year || '-(\d+)') AS INT)
  ), 0) + 1
  INTO next_number
  FROM stock_out_requests
  WHERE request_number LIKE 'SOR-' || current_year || '-%';

  NEW.request_number := 'SOR-' || current_year || '-' || LPAD(next_number::TEXT, 5, '0');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generate_sor_request_number ON stock_out_requests;
CREATE TRIGGER trg_generate_sor_request_number
  BEFORE INSERT ON stock_out_requests
  FOR EACH ROW
  WHEN (NEW.request_number IS NULL OR NEW.request_number = '')
  EXECUTE FUNCTION generate_sor_request_number();
```

**9. Approval number generation** (per user decision: SOR-YYYY-NNNNN-A01, A02, etc.):
```sql
CREATE OR REPLACE FUNCTION generate_sor_approval_number()
RETURNS TRIGGER AS $$
DECLARE
  parent_request_number TEXT;
  next_seq INT;
BEGIN
  -- Get the parent request number via the line item
  SELECT r.request_number
  INTO parent_request_number
  FROM stock_out_requests r
  JOIN stock_out_line_items li ON li.request_id = r.id
  WHERE li.id = NEW.line_item_id;

  -- Get next sequential approval number for this request
  SELECT COALESCE(MAX(
    CAST(SUBSTRING(a.approval_number FROM '.*-A(\d+)$') AS INT)
  ), 0) + 1
  INTO next_seq
  FROM stock_out_approvals a
  JOIN stock_out_line_items li ON a.line_item_id = li.id
  JOIN stock_out_requests r ON li.request_id = r.id
  WHERE r.request_number = parent_request_number;

  NEW.approval_number := parent_request_number || '-A' || LPAD(next_seq::TEXT, 2, '0');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_generate_sor_approval_number ON stock_out_approvals;
CREATE TRIGGER trg_generate_sor_approval_number
  BEFORE INSERT ON stock_out_approvals
  FOR EACH ROW
  WHEN (NEW.approval_number IS NULL OR NEW.approval_number = '')
  EXECUTE FUNCTION generate_sor_approval_number();
```

**10. Item snapshot trigger for line items** (follows pattern from snapshot_inventory_transaction_item):
```sql
CREATE OR REPLACE FUNCTION snapshot_sor_line_item()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.item_name IS NULL OR NEW.item_sku IS NULL THEN
    SELECT name, sku
    INTO NEW.item_name, NEW.item_sku
    FROM items
    WHERE id = NEW.item_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_snapshot_sor_line_item ON stock_out_line_items;
CREATE TRIGGER trg_snapshot_sor_line_item
  BEFORE INSERT ON stock_out_line_items
  FOR EACH ROW
  EXECUTE FUNCTION snapshot_sor_line_item();
```

**11. Computed request status trigger** (per user decision: SOR request status computed from line items):
Logic:
- If ALL line items are 'pending' -> request is 'pending'
- If ALL line items are 'cancelled' -> request is 'cancelled'
- If ALL line items are 'rejected' -> request is 'rejected'
- If ALL line items are 'executed' -> request is 'executed'
- If ALL line items are in ('approved','rejected','cancelled','executed','partially_executed') and at least one is 'approved' or 'executed' or 'partially_executed' -> checks further
- If some are 'approved'/'partially_executed'/'executed' and some are 'pending' -> 'partially_approved'
- If some line items have fulfillments but not all fully executed -> 'partially_executed'
- Otherwise derive from mix

Implement as:
```sql
CREATE OR REPLACE FUNCTION compute_sor_request_status()
RETURNS TRIGGER AS $$
DECLARE
  total_count INT;
  pending_count INT;
  cancelled_count INT;
  rejected_count INT;
  approved_count INT;
  partially_executed_count INT;
  executed_count INT;
  new_status sor_request_status;
  parent_request_id UUID;
BEGIN
  -- Get the parent request_id
  IF TG_TABLE_NAME = 'stock_out_line_items' THEN
    parent_request_id := COALESCE(NEW.request_id, OLD.request_id);
  ELSIF TG_TABLE_NAME = 'stock_out_approvals' THEN
    SELECT li.request_id INTO parent_request_id
    FROM stock_out_line_items li
    WHERE li.id = COALESCE(NEW.line_item_id, OLD.line_item_id);
  END IF;

  IF parent_request_id IS NULL THEN
    RETURN COALESCE(NEW, OLD);
  END IF;

  -- Count line item statuses
  SELECT
    COUNT(*),
    COUNT(*) FILTER (WHERE status = 'pending'),
    COUNT(*) FILTER (WHERE status = 'cancelled'),
    COUNT(*) FILTER (WHERE status = 'rejected'),
    COUNT(*) FILTER (WHERE status = 'approved'),
    COUNT(*) FILTER (WHERE status = 'partially_executed'),
    COUNT(*) FILTER (WHERE status = 'executed')
  INTO total_count, pending_count, cancelled_count, rejected_count,
       approved_count, partially_executed_count, executed_count
  FROM stock_out_line_items
  WHERE request_id = parent_request_id AND is_active = true;

  -- Compute status
  IF total_count = 0 OR pending_count = total_count THEN
    new_status := 'pending';
  ELSIF cancelled_count = total_count THEN
    new_status := 'cancelled';
  ELSIF rejected_count + cancelled_count = total_count THEN
    new_status := 'rejected';
  ELSIF executed_count = total_count THEN
    new_status := 'executed';
  ELSIF partially_executed_count > 0 OR (executed_count > 0 AND executed_count < total_count) THEN
    new_status := 'partially_executed';
  ELSIF approved_count > 0 AND pending_count > 0 THEN
    new_status := 'partially_approved';
  ELSIF approved_count > 0 AND pending_count = 0 THEN
    new_status := 'approved';
  ELSE
    -- Mixed states: some approved/rejected/cancelled but no pending
    new_status := 'partially_approved';
  END IF;

  -- Update parent request status
  UPDATE stock_out_requests
  SET status = new_status,
      updated_at = NOW()
  WHERE id = parent_request_id
    AND status IS DISTINCT FROM new_status;

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger on line items status change
DROP TRIGGER IF EXISTS trg_compute_sor_status_from_li ON stock_out_line_items;
CREATE TRIGGER trg_compute_sor_status_from_li
  AFTER INSERT OR UPDATE OF status, is_active OR DELETE ON stock_out_line_items
  FOR EACH ROW
  EXECUTE FUNCTION compute_sor_request_status();
```

**12. QMHQ single-line-item enforcement** (per user decision: QMHQ-linked SOR always has exactly one line item):
```sql
CREATE OR REPLACE FUNCTION enforce_qmhq_single_line_item()
RETURNS TRIGGER AS $$
DECLARE
  linked_qmhq_id UUID;
  existing_count INT;
BEGIN
  -- Check if the parent request is linked to a QMHQ
  SELECT qmhq_id INTO linked_qmhq_id
  FROM stock_out_requests
  WHERE id = NEW.request_id;

  IF linked_qmhq_id IS NOT NULL THEN
    -- Count existing active line items (excluding current if update)
    SELECT COUNT(*) INTO existing_count
    FROM stock_out_line_items
    WHERE request_id = NEW.request_id
      AND is_active = true
      AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000');

    IF existing_count >= 1 THEN
      RAISE EXCEPTION 'QMHQ-linked stock-out requests can only have one line item';
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_enforce_qmhq_single_line_item ON stock_out_line_items;
CREATE TRIGGER trg_enforce_qmhq_single_line_item
  BEFORE INSERT ON stock_out_line_items
  FOR EACH ROW
  EXECUTE FUNCTION enforce_qmhq_single_line_item();
```

**13. Table comments:**
```sql
COMMENT ON TABLE stock_out_requests IS 'Stock-out request requiring approval before inventory can be withdrawn';
COMMENT ON TABLE stock_out_line_items IS 'Individual items within a stock-out request, each with own approval status';
COMMENT ON TABLE stock_out_approvals IS 'Approval/rejection decisions on stock-out line items, supports partial approval';
COMMENT ON COLUMN stock_out_requests.status IS 'Computed from line item statuses, not set directly';
COMMENT ON COLUMN stock_out_requests.qmhq_id IS 'Optional 1:1 link to QMHQ item route (NULL for standalone requests)';
COMMENT ON COLUMN stock_out_line_items.requested_quantity IS 'Quantity requested for stock-out, approval can be for less';
COMMENT ON COLUMN stock_out_approvals.approved_quantity IS 'Quantity approved in this approval (sum of approvals per line item must not exceed requested_quantity)';
COMMENT ON COLUMN stock_out_approvals.approval_number IS 'Auto-generated: parent SOR number + sequential suffix (SOR-YYYY-NNNNN-A01)';
```

**14. Grant permissions:**
```sql
GRANT USAGE ON TYPE sor_line_item_status TO authenticated;
GRANT USAGE ON TYPE sor_request_status TO authenticated;
```
  </action>
  <verify>
Run `npx supabase db reset` in the project root. Verify:
1. No migration errors
2. `\dt stock_out*` shows all 3 tables
3. Insert test: `INSERT INTO stock_out_requests (reason, requester_id, created_by) VALUES ('damage', (SELECT id FROM users LIMIT 1), (SELECT id FROM users LIMIT 1)) RETURNING request_number;` — should return SOR-2026-00001
4. Insert line item and verify item_name/item_sku are snapshotted
5. Insert approval and verify approval_number is auto-generated as SOR-2026-00001-A01
  </verify>
  <done>
Three tables exist (stock_out_requests, stock_out_line_items, stock_out_approvals) with all constraints, auto-generated IDs (SOR-YYYY-NNNNN format for requests, SOR-YYYY-NNNNN-A01 for approvals), item snapshot trigger, computed request status trigger, and QMHQ single-line-item enforcement. Migration runs cleanly with `npx supabase db reset`.
  </done>
</task>

</tasks>

<verification>
1. `npx supabase db reset` succeeds with no errors
2. All 3 tables exist with correct columns and constraints
3. SOR request number auto-generates correctly
4. Approval number auto-generates with parent SOR prefix
5. Item name and SKU are snapshotted on line item creation
6. QMHQ-linked SOR blocks second line item insertion
7. Request status updates automatically when line item status changes
</verification>

<success_criteria>
- stock_out_requests, stock_out_line_items, stock_out_approvals tables created with all FK relationships
- SOR-YYYY-NNNNN and SOR-YYYY-NNNNN-A01 auto-generation works
- Item snapshot trigger populates item_name and item_sku on line item insert
- Computed status trigger updates request.status based on line item statuses
- QMHQ single-line-item constraint enforced
- `npx supabase db reset` passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/27-stock-out-approval-db-foundation/27-01-SUMMARY.md`
</output>
