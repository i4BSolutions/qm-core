---
phase: 45-flow-tracking-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260214100000_flow_tracking_performance.sql
  - app/(dashboard)/admin/flow-tracking/page.tsx
  - app/(dashboard)/admin/flow-tracking/loading.tsx
autonomous: true

must_haves:
  truths:
    - "Flow tracking VIEW query uses index scans (not sequential scans) on all joined tables"
    - "The OR join on inventory_transactions is eliminated in favor of two separate LEFT JOINs"
    - "Flow tracking page shows loading skeleton while data is being fetched"
    - "Database has covering indexes on all FK columns used by the VIEW filtered on is_active = true"
  artifacts:
    - path: "supabase/migrations/20260214100000_flow_tracking_performance.sql"
      provides: "Covering indexes and optimized VIEW rewrite"
      contains: "CREATE OR REPLACE VIEW qmrl_flow_chain"
    - path: "app/(dashboard)/admin/flow-tracking/loading.tsx"
      provides: "Loading skeleton for flow tracking page"
      contains: "Skeleton"
    - path: "app/(dashboard)/admin/flow-tracking/page.tsx"
      provides: "Suspense-wrapped flow tracking results"
      contains: "Suspense"
  key_links:
    - from: "supabase/migrations/20260214100000_flow_tracking_performance.sql"
      to: "qmrl_flow_chain VIEW"
      via: "CREATE OR REPLACE VIEW"
      pattern: "CREATE OR REPLACE VIEW qmrl_flow_chain"
    - from: "app/(dashboard)/admin/flow-tracking/page.tsx"
      to: "app/(dashboard)/admin/flow-tracking/loading.tsx"
      via: "Next.js loading.tsx convention"
      pattern: "Suspense"
---

<objective>
Optimize the flow tracking VIEW for production-scale performance and add loading UX.

Purpose: The qmrl_flow_chain VIEW currently has an OR join on inventory_transactions that prevents index usage, and several join columns lack composite partial indexes. The page also blocks rendering entirely during data fetch with no loading indicator.

Output: Database migration with optimized VIEW (OR join eliminated) and covering indexes; loading skeleton for the flow tracking page.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@supabase/migrations/20260211140000_flow_tracking_view.sql
@lib/supabase/flow-tracking-queries.ts
@types/flow-tracking.ts
@app/(dashboard)/admin/flow-tracking/page.tsx
@components/ui/skeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration with covering indexes and optimized VIEW</name>
  <files>supabase/migrations/20260214100000_flow_tracking_performance.sql</files>
  <action>
Create a new migration file that:

1. **Add covering partial indexes** for all JOIN columns used by the VIEW that don't already have optimal indexes. The key optimization is partial indexes filtered on `is_active = true` which match the VIEW's filter conditions. Create these indexes (use IF NOT EXISTS):

```sql
-- QMHQ: join on qmrl_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_qmhq_qmrl_id_active
  ON qmhq(qmrl_id) WHERE is_active = true;

-- Purchase Orders: join on qmhq_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_purchase_orders_qmhq_id_active
  ON purchase_orders(qmhq_id) WHERE is_active = true;

-- Invoices: join on po_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_invoices_po_id_active
  ON invoices(po_id) WHERE is_active = true;

-- Inventory transactions: join on invoice_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_transactions_invoice_id_active
  ON inventory_transactions(invoice_id) WHERE is_active = true;

-- Inventory transactions: join on qmhq_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_inventory_transactions_qmhq_id_active
  ON inventory_transactions(qmhq_id) WHERE is_active = true;

-- Financial transactions: join on qmhq_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_financial_transactions_qmhq_id_active
  ON financial_transactions(qmhq_id) WHERE is_active = true;

-- Stock-out requests: join on qmhq_id with is_active filter
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_stock_out_requests_qmhq_id_active
  ON stock_out_requests(qmhq_id) WHERE is_active = true;

-- QMRL: covering index for the root WHERE + ORDER BY
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_qmrl_active_created_desc
  ON qmrl(created_at DESC) WHERE is_active = true;
```

2. **Rewrite the VIEW** to eliminate the OR join on inventory_transactions. The current JOIN:
```sql
LEFT JOIN inventory_transactions AS inv_trans
  ON (inv_trans.invoice_id = invoice.id OR inv_trans.qmhq_id = qmhq.id)
  AND inv_trans.is_active = true
```
PostgreSQL cannot use indexes on OR conditions. Replace with TWO separate LEFT JOINs:
```sql
-- Stock-in transactions (linked via invoice for PO route)
LEFT JOIN inventory_transactions AS stock_in_trans
  ON stock_in_trans.invoice_id = invoice.id
  AND stock_in_trans.is_active = true

-- Stock-out transactions (linked via qmhq for item route)
LEFT JOIN inventory_transactions AS stock_out_trans
  ON stock_out_trans.qmhq_id = qmhq.id
  AND stock_out_trans.is_active = true
```

Then update the SELECT clause to use COALESCE to merge the two into a single set of stock columns:
```sql
  COALESCE(stock_in_trans.id, stock_out_trans.id) AS stock_id,
  COALESCE(stock_in_trans.movement_type, stock_out_trans.movement_type) AS stock_movement_type,
  COALESCE(stock_in_trans.status, stock_out_trans.status) AS stock_status,
  COALESCE(stock_in_trans.transaction_date, stock_out_trans.transaction_date) AS stock_transaction_date,
  COALESCE(stock_in_trans.created_at, stock_out_trans.created_at) AS stock_created_at,
```

The full CREATE OR REPLACE VIEW must include ALL existing columns unchanged except the stock fields above. Copy the full VIEW definition from `20260211140000_flow_tracking_view.sql` and modify only the inventory_transactions JOIN and corresponding SELECT columns.

Also remove the ORDER BY from the VIEW definition (the client-side query already filters by specific qmrl_request_id and the TypeScript transformation doesn't depend on row order).

3. **Re-grant permissions:**
```sql
GRANT SELECT ON qmrl_flow_chain TO authenticated;
```

IMPORTANT: Since Supabase migrations run inside transactions, and CREATE INDEX CONCURRENTLY cannot run in a transaction, use regular CREATE INDEX (not CONCURRENTLY) in the migration file. The CONCURRENTLY keyword is only for production hot-patching outside migrations. Use IF NOT EXISTS on all indexes to be idempotent.

Add clear comments explaining the performance rationale: why OR joins prevent index usage, why partial indexes match the VIEW filters, and why ORDER BY was removed.
  </action>
  <verify>
Run `npm run type-check` to confirm no TypeScript errors (the VIEW change is transparent to the query layer since column aliases remain identical). Verify the migration SQL is syntactically valid by checking for balanced parentheses and correct SQL keywords. Confirm that the fetchFlowChain function in lib/supabase/flow-tracking-queries.ts still references the same column names (stock_id, stock_movement_type, etc.) â€” no changes needed there since COALESCE preserves the aliases.
  </verify>
  <done>
Migration file exists with: (1) 8 partial indexes on FK columns filtered by is_active = true, (2) rewritten VIEW with OR join eliminated via two separate LEFT JOINs using COALESCE, (3) ORDER BY removed from VIEW, (4) GRANT SELECT re-applied. The fetchFlowChain query function requires zero changes because column aliases are preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add loading skeleton and Suspense boundary to flow tracking page</name>
  <files>
    app/(dashboard)/admin/flow-tracking/loading.tsx
    app/(dashboard)/admin/flow-tracking/page.tsx
  </files>
  <action>
1. **Create `loading.tsx`** at `app/(dashboard)/admin/flow-tracking/loading.tsx`:

This is a Next.js App Router loading file that automatically wraps the page in a Suspense boundary. Create a skeleton that mirrors the flow tracking page layout:

```tsx
import { Skeleton } from "@/components/ui/skeleton";

export default function FlowTrackingLoading() {
  return (
    <div className="space-y-6">
      {/* PageHeader skeleton */}
      <div className="space-y-2">
        <div className="flex items-center gap-3">
          <Skeleton className="h-8 w-48" />
          <Skeleton className="h-6 w-16 rounded" />
        </div>
        <Skeleton className="h-5 w-80" />
      </div>

      {/* Search bar skeleton */}
      <div className="command-panel">
        <Skeleton className="h-10 w-full max-w-2xl" />
      </div>

      {/* Results skeleton - chain timeline placeholder */}
      <div className="command-panel corner-accents space-y-4">
        <Skeleton className="h-20 w-full" />
        <Skeleton className="h-16 w-11/12 ml-6" />
        <Skeleton className="h-16 w-10/12 ml-12" />
        <Skeleton className="h-16 w-10/12 ml-12" />
      </div>
    </div>
  );
}
```

2. **Update `page.tsx`** to wrap the FlowTrackingResults async component in a Suspense boundary with a results-specific loading skeleton. This ensures the search input renders immediately while the database query runs.

Modify the page to:
- Import `Suspense` from React
- Import `Skeleton` from `@/components/ui/skeleton`
- Extract `FlowTrackingResults` to use Suspense boundary with a key based on `qmrlId` (so React re-suspends on new searches)
- Create an inline `FlowTrackingResultsSkeleton` component for the Suspense fallback

The key change in the JSX:
```tsx
{qmrlId ? (
  <Suspense key={qmrlId} fallback={<FlowTrackingResultsSkeleton />}>
    <FlowTrackingResults qmrlId={qmrlId} />
  </Suspense>
) : (
  <div className="command-panel corner-accents text-center">
    <p className="text-slate-400">
      Enter a QMRL ID to view its complete downstream chain
    </p>
  </div>
)}
```

The `FlowTrackingResultsSkeleton` should render:
```tsx
function FlowTrackingResultsSkeleton() {
  return (
    <div className="space-y-4">
      <div className="command-panel corner-accents space-y-4">
        <div className="flex items-center gap-3">
          <Skeleton className="h-5 w-5 rounded-full" />
          <Skeleton className="h-6 w-40" />
          <Skeleton className="h-5 w-20 rounded" />
        </div>
        <Skeleton className="h-4 w-64" />
      </div>
      <div className="ml-6 space-y-3">
        <div className="command-panel space-y-3">
          <Skeleton className="h-5 w-32" />
          <Skeleton className="h-4 w-48" />
        </div>
        <div className="command-panel space-y-3">
          <Skeleton className="h-5 w-32" />
          <Skeleton className="h-4 w-48" />
        </div>
      </div>
    </div>
  );
}
```

This ensures the search input is immediately interactive while the chain data loads asynchronously.
  </action>
  <verify>
Run `npm run type-check` to confirm no TypeScript errors. Verify that `loading.tsx` exports a default function component. Verify that `page.tsx` imports Suspense and Skeleton, and wraps FlowTrackingResults in Suspense with the `key={qmrlId}` prop.
  </verify>
  <done>
Flow tracking page renders search input immediately without blocking. When a QMRL ID is searched, a loading skeleton appears while the VIEW query executes. The skeleton mirrors the chain timeline layout (QMRL node + indented child nodes). Next.js `loading.tsx` handles full-page loading, and inline Suspense handles search-triggered loading.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/20260214100000_flow_tracking_performance.sql`
2. Migration contains 8 partial indexes (all with `WHERE is_active = true` or `WHERE qmhq_id IS NOT NULL`)
3. VIEW rewrite uses two separate `LEFT JOIN inventory_transactions` (stock_in_trans and stock_out_trans) instead of OR condition
4. VIEW SELECT uses COALESCE for stock_id, stock_movement_type, stock_status, stock_transaction_date, stock_created_at
5. VIEW has no ORDER BY clause
6. `loading.tsx` exists and exports a Skeleton-based loading UI
7. `page.tsx` wraps FlowTrackingResults in Suspense with key prop
8. `npm run type-check` passes
</verification>

<success_criteria>
1. The OR join on inventory_transactions is eliminated from the VIEW definition
2. 8 new partial indexes exist covering all FK columns used by VIEW JOINs
3. Flow tracking page shows loading skeleton during data fetch (Suspense boundary)
4. TypeScript compilation succeeds with no new errors
5. fetchFlowChain query function requires zero modifications (column aliases preserved)
</success_criteria>

<output>
After completion, create `.planning/phases/45-flow-tracking-performance/45-01-SUMMARY.md`
</output>
