---
phase: 37-rbac-database-migration
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql
autonomous: true

must_haves:
  truths:
    - "All RLS policies reference only new role values (admin, qmrl, qmhq) - zero references to old roles"
    - "All 20 tables with RLS maintain correct access after policy recreation"
    - "can_view_sor_request() helper function uses new role values"
    - "delete_file_attachment() RPC function uses new role values"
    - "Database reset completes without errors after both migrations apply"
  artifacts:
    - path: "supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql"
      provides: "Complete RLS policy recreation for all tables using new 3-role enum"
      contains: "DROP POLICY"
  key_links:
    - from: "supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql"
      to: "public.get_user_role()"
      via: "Policy USING/WITH CHECK clauses"
      pattern: "get_user_role\\(\\) IN \\('admin'"
    - from: "supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql"
      to: "supabase/migrations/20260211120000_rbac_enum_migration.sql"
      via: "Depends on new enum existing"
      pattern: "'admin', 'qmrl', 'qmhq'"
---

<objective>
Recreate all RLS policies across 20 tables to use the new 3-role enum values, and update helper functions that contain hardcoded old role references.

Purpose: After Plan 01 migrates the enum, all RLS policies still reference old role values like 'quartermaster', 'finance', etc. These must be dropped and recreated with the new role mapping to restore access control.

Output: Single migration file that atomically drops and recreates all role-dependent RLS policies and helper functions.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/37-rbac-database-migration/37-RESEARCH.md
@.planning/phases/37-rbac-database-migration/37-01-SUMMARY.md
@supabase/migrations/027_rls_policies.sql
@supabase/migrations/030_file_attachments.sql
@supabase/migrations/031_storage_bucket_rls.sql
@supabase/migrations/036_fix_file_attachments_rls.sql
@supabase/migrations/037_file_attachments_delete_own.sql
@supabase/migrations/043_fix_file_delete_rpc.sql
@supabase/migrations/051_comments.sql
@supabase/migrations/054_stock_out_rls_audit.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Recreate all RLS policies and helper functions with new role values</name>
  <files>supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql</files>
  <action>
Create a single SQL migration file wrapped in BEGIN/COMMIT that drops and recreates ALL role-dependent RLS policies and functions. The migration must be atomic — if any statement fails, the entire transaction rolls back and default-deny keeps the database secure.

**Role mapping for policy recreation:**
- Old `'admin'` -> New `'admin'`
- Old `'quartermaster'` -> merged into `'admin'`
- Old `'finance'` -> New `'qmhq'`
- Old `'inventory'` -> New `'qmhq'`
- Old `'proposal'` -> New `'qmhq'`
- Old `'frontline'` -> New `'qmrl'`
- Old `'requester'` -> New `'qmrl'`

When mapping old policies to new:
- `IN ('admin', 'quartermaster')` becomes `= 'admin'` (both map to admin)
- `IN ('admin', 'quartermaster', 'finance', 'proposal')` becomes `IN ('admin', 'qmhq')` (admin stays, rest map to qmhq)
- `IN ('admin', 'quartermaster', 'finance', 'inventory', 'proposal', 'frontline')` becomes `true` or `IN ('admin', 'qmhq', 'qmrl')` — effectively all roles, so use `auth.uid() IS NOT NULL` for authenticated check
- `= 'requester'` becomes `= 'qmrl'`
- `IN ('proposal', 'frontline')` becomes `IN ('qmhq', 'qmrl')` — but since these are distinct roles, keep as IN

**CRITICAL SIMPLIFICATION RULE:** When all 3 roles appear in an IN clause, simplify to a simple authenticated user check rather than listing all roles. Use `auth.uid() IS NOT NULL` or just `true` (since RLS already requires authentication via Supabase).

Process each table section below. For each table: DROP all existing role-dependent policies with `DROP POLICY IF EXISTS`, then CREATE new policies.

---

**SECTION 1: USERS table** (from 027_rls_policies.sql lines 75-115)

Policies to recreate:
- `users_select_own`: No role check needed — keep as `id = auth.uid()` (UNCHANGED)
- `users_select_admin`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`
- `users_insert`: Old: `= 'admin'` -> New: `= 'admin'` (UNCHANGED)
- `users_update_own`: No role check — keep as `id = auth.uid()` (UNCHANGED)
- `users_update_admin`: Old: `= 'admin'` -> New: `= 'admin'` (UNCHANGED)
- `users_delete`: Old: `= 'admin'` -> New: `= 'admin'` (UNCHANGED)

Only `users_select_admin` needs updating.

---

**SECTION 2: DEPARTMENTS table** (from 027_rls_policies.sql lines 121-142)

- `departments_select`: `USING (true)` — no role check (UNCHANGED)
- `departments_insert`: `= 'admin'` (UNCHANGED)
- `departments_update`: `= 'admin'` (UNCHANGED)
- `departments_delete`: `= 'admin'` (UNCHANGED)

All admin-only — no changes needed. But still DROP/CREATE for consistency (ensures no stale old-enum references if function return types changed).

---

**SECTION 3: STATUS_CONFIG table** (from 027_rls_policies.sql lines 148-169)

- `status_config_select`: `USING (true)` (UNCHANGED)
- `status_config_insert`: Old: `IN ('admin', 'quartermaster', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `status_config_update`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`
- `status_config_delete`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`

---

**SECTION 4: CATEGORIES table** (from 027_rls_policies.sql lines 175-196)

Same as STATUS_CONFIG:
- `categories_select`: `USING (true)` (UNCHANGED)
- `categories_insert`: Old: `IN ('admin', 'quartermaster', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `categories_update`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`
- `categories_delete`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`

---

**SECTION 5: CONTACT_PERSONS table** (from 027_rls_policies.sql lines 202-223)

- `contact_persons_select`: `USING (true)` (UNCHANGED)
- `contact_persons_insert`: Old: `IN ('admin', 'quartermaster', 'proposal', 'frontline')` -> New: `IN ('admin', 'qmhq', 'qmrl')`  which is all roles, so simplify to `true`
- `contact_persons_update`: Same mapping -> `true`
- `contact_persons_delete`: Same mapping -> `true`

Wait — contact_persons being writable by ALL roles seems too permissive. Use the mapped values directly: `IN ('admin', 'qmhq', 'qmrl')`. Since that covers all 3 roles, the functional effect is "any authenticated user." For clarity, keep as `IN ('admin', 'qmhq', 'qmrl')` so it's explicit that roles are checked, even if all match.

---

**SECTION 6: SUPPLIERS table** (from 027_rls_policies.sql lines 229-250)

- `suppliers_select`: `USING (true)` (UNCHANGED)
- `suppliers_insert`: Old: `IN ('admin', 'quartermaster', 'finance', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `suppliers_update`: Same -> `IN ('admin', 'qmhq')`
- `suppliers_delete`: Same -> `IN ('admin', 'qmhq')`

---

**SECTION 7: ITEMS table** (from 027_rls_policies.sql lines 256-277)

- `items_select`: `USING (true)` (UNCHANGED)
- `items_insert`: Old: `IN ('admin', 'quartermaster', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `items_update`: Same -> `IN ('admin', 'qmhq')`
- `items_delete`: Same -> `IN ('admin', 'qmhq')`

---

**SECTION 8: WAREHOUSES table** (from 027_rls_policies.sql lines 283-306)

- `warehouses_select`: Old: `IN ('admin', 'quartermaster', 'inventory', 'finance', 'proposal')` -> New: `IN ('admin', 'qmhq')` (all old roles map to admin or qmhq)
- `warehouses_insert`: Old: `IN ('admin', 'quartermaster', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `warehouses_update`: Same -> `IN ('admin', 'qmhq')`
- `warehouses_delete`: Same -> `IN ('admin', 'qmhq')`

---

**SECTION 9: QMRL table** (from 027_rls_policies.sql lines 315-340)

- `qmrl_select`: Old: `IN ('admin', 'quartermaster', 'finance', 'inventory', 'proposal', 'frontline') OR (requester AND requester_id = auth.uid())` -> New: All 3 roles cover it. Simplify to: `true` (all authenticated users can see all QMRLs). The old `requester` branch for own-only was the exception, but now `qmrl` role users should see all QMRLs per Phase 38 requirements (QMRL role can view all QMRLs). So: `USING (true)`.
- `qmrl_insert`: Old: `IN ('admin', 'quartermaster', 'requester')` -> New: `IN ('admin', 'qmrl')` (admin + qmrl can create)
- `qmrl_update`: Old: `IN ('admin', 'quartermaster', 'proposal', 'frontline') OR (requester AND own)` -> New: `IN ('admin', 'qmhq', 'qmrl')` which is all roles. Use `true`.
- `qmrl_delete`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`

---

**SECTION 10: QMHQ table** (from 027_rls_policies.sql lines 349-373)

- `qmhq_select`: Old: `IN ('admin', 'quartermaster', 'finance', 'inventory', 'proposal', 'frontline') OR (requester AND owns_qmhq)` -> New: All roles. Use `true`.
- `qmhq_insert`: Old: `IN ('admin', 'quartermaster', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `qmhq_update`: Old: `IN ('admin', 'quartermaster', 'proposal', 'finance', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `qmhq_delete`: Old: `IN ('admin', 'quartermaster', 'proposal')` -> New: `IN ('admin', 'qmhq')`

---

**SECTION 11: FINANCIAL_TRANSACTIONS table** (from 027_rls_policies.sql lines 380-403)

- `financial_transactions_select`: Old: `IN ('admin', 'finance', 'quartermaster', 'inventory', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `financial_transactions_insert`: Old: `IN ('admin', 'finance')` -> New: `IN ('admin', 'qmhq')`
- `financial_transactions_update`: Same -> `IN ('admin', 'qmhq')`
- `financial_transactions_delete`: Same -> `IN ('admin', 'qmhq')`

---

**SECTION 12: PURCHASE_ORDERS table** (from 027_rls_policies.sql lines 410-433)

- `purchase_orders_select`: Old: `IN ('admin', 'quartermaster', 'finance', 'proposal', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `purchase_orders_insert`: Old: `IN ('admin', 'quartermaster', 'finance', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `purchase_orders_update`: Same -> `IN ('admin', 'qmhq')`
- `purchase_orders_delete`: Same -> `IN ('admin', 'qmhq')`

---

**SECTION 13: PO_LINE_ITEMS table** (from 027_rls_policies.sql lines 438-461)

Same as PURCHASE_ORDERS:
- All 4 policies: `IN ('admin', 'qmhq')` for select/insert/update/delete

---

**SECTION 14: INVOICES table** (from 027_rls_policies.sql lines 468-492)

- `invoices_select`: Old: `IN ('admin', 'quartermaster', 'finance', 'inventory', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `invoices_insert`: Old: `IN ('admin', 'quartermaster', 'finance')` -> New: `IN ('admin', 'qmhq')`
- `invoices_update`: Old: `IN ('admin', 'quartermaster', 'finance', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `invoices_delete`: Old: `IN ('admin', 'quartermaster', 'finance')` -> New: `IN ('admin', 'qmhq')`

---

**SECTION 15: INVOICE_LINE_ITEMS table** (from 027_rls_policies.sql lines 497-520)

Same as INVOICES — all policies: `IN ('admin', 'qmhq')`

---

**SECTION 16: INVENTORY_TRANSACTIONS table** (from 027_rls_policies.sql lines 527-550)

- `inventory_transactions_select`: Old: `IN ('admin', 'quartermaster', 'inventory', 'finance', 'proposal')` -> New: `IN ('admin', 'qmhq')`
- `inventory_transactions_insert`: Old: `IN ('admin', 'quartermaster', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `inventory_transactions_update`: Same -> `IN ('admin', 'qmhq')`
- `inventory_transactions_delete`: Same -> `IN ('admin', 'qmhq')`

---

**SECTION 17: AUDIT_LOGS table** (from 027_rls_policies.sql lines 557-568)

- `audit_logs_select`: Old: all 7 roles listed -> New: `true` (all authenticated users)
- `audit_logs_insert`: `WITH CHECK (true)` (UNCHANGED — trigger-controlled)

---

**SECTION 18: FILE_ATTACHMENTS table** (from 030, 036, 037)

The latest policy state comes from 037_file_attachments_delete_own.sql (overwrites 036 and 030).

- `file_attachments_select`: Old: `IN ('admin', 'quartermaster', 'finance', 'inventory', 'proposal', 'frontline') OR (requester AND owns)` -> New: `true` (all roles)
- `file_attachments_insert`: Old: `IN ('admin', 'quartermaster') OR (proposal/frontline AND qmrl/qmhq) OR (requester AND own qmrl)` -> New: `IN ('admin', 'qmhq') OR (get_user_role() = 'qmrl' AND entity_type = 'qmrl' AND owns_qmrl(entity_id))`

  Reasoning: admin stays admin. quartermaster->admin, proposal/frontline for qmrl/qmhq entity types: proposal->qmhq can upload to qmrl/qmhq; frontline->qmrl can upload to qmrl/qmhq. Simplify: admin and qmhq can upload to any entity. qmrl can upload to their own QMRL entities.

- `file_attachments_update`: Old (from 037): `IN ('admin', 'quartermaster') OR uploaded_by = auth.uid()` -> New: `= 'admin' OR uploaded_by = auth.uid()`

  WITH CHECK same conditions.

- `file_attachments_delete`: Old: `= 'admin'` -> New: `= 'admin'` (UNCHANGED)

---

**SECTION 19: STORAGE.OBJECTS policies** (from 031_storage_bucket_rls.sql)

- `storage_attachments_select`: Old: privileged roles + requester own check -> New: Simplify. All authenticated users can download files (mirroring file_attachments_select using `true`). Actual access control is via the file_attachments RLS. Simplify to: bucket_id = 'attachments' check only.

  Actually, keep the access control mirrored for defense-in-depth:
  - `bucket_id = 'attachments' AND EXISTS (SELECT 1 FROM public.file_attachments fa WHERE fa.storage_path = name AND fa.deleted_at IS NULL)` — if the user can see the file_attachment row (via its RLS), then they can download the storage object. Since file_attachments_select is now `true`, this effectively allows all authenticated users. But keeping the EXISTS check ensures deleted files are hidden.

- `storage_attachments_insert`: Old: admin/quartermaster + proposal/frontline for qmrl/qmhq + requester for own qmrl -> New: `bucket_id = 'attachments' AND (get_user_role() IN ('admin', 'qmhq') OR (get_user_role() = 'qmrl' AND (storage.foldername(name))[1] = 'qmrl' AND owns_qmrl(((storage.foldername(name))[2])::uuid)))`

- `storage_attachments_update`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`
- `storage_attachments_delete`: Old: `IN ('admin', 'quartermaster')` -> New: `= 'admin'`

---

**SECTION 20: COMMENTS table** (from 051_comments.sql)

- `comments_select`: Old: privileged roles + requester own check -> New: `deleted_at IS NULL AND true` (all authenticated users can see non-deleted comments). Simplify to: `deleted_at IS NULL`.
- `comments_insert`: Old: admin/quartermaster + finance/inventory + proposal/frontline for qmrl/qmhq + requester for own qmrl -> New: All 3 roles cover all cases. Simplify to `true` (any authenticated user can comment).
- `comments_update`: Old: `author_id = auth.uid() AND NOT has_replies` -> New: same (no role check) (UNCHANGED)
- `comments_delete`: Old: `= 'admin'` -> New: `= 'admin'` (UNCHANGED)

---

**SECTION 21: STOCK_OUT_REQUESTS table** (from 054_stock_out_rls_audit.sql)

- `sor_select`: Old: `IN ('admin', 'quartermaster', 'inventory') OR requester_id = auth.uid()` -> New: `IN ('admin', 'qmhq') OR requester_id = auth.uid()`
- `sor_insert`: Old: `IN ('admin', 'quartermaster', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `sor_update`: Old: `= 'admin' OR requester_id = auth.uid()` -> New: `= 'admin' OR requester_id = auth.uid()` (UNCHANGED)
- `sor_delete`: Old: `= 'admin'` -> New: `= 'admin'` (UNCHANGED)

---

**SECTION 22: STOCK_OUT_LINE_ITEMS table** (from 054_stock_out_rls_audit.sql)

- `sor_li_select`: Uses `can_view_sor_request(request_id)` — need to update the FUNCTION, not the policy
- `sor_li_insert`: Old: `IN ('admin', 'quartermaster', 'inventory')` -> New: `IN ('admin', 'qmhq')`
- `sor_li_update`: Same -> `IN ('admin', 'qmhq')`
- `sor_li_delete`: `= 'admin'` (UNCHANGED)

---

**SECTION 23: STOCK_OUT_APPROVALS table** (from 054_stock_out_rls_audit.sql)

All policies are `= 'admin'` — UNCHANGED. But still recreate for consistency.

---

**HELPER FUNCTIONS TO UPDATE:**

1. **`can_view_sor_request(UUID)`** — Old: `IN ('admin', 'quartermaster', 'inventory')` -> New: `IN ('admin', 'qmhq')`. Recreate with CREATE OR REPLACE.

2. **`delete_file_attachment(UUID, UUID)`** (from 043_fix_file_delete_rpc.sql) — Has hardcoded role checks:
   - `v_user_role IN ('admin', 'quartermaster')` -> `v_user_role IN ('admin')`
   - `v_user_role IN ('admin', 'quartermaster', 'proposal', 'frontline')` -> `v_user_role IN ('admin', 'qmhq', 'qmrl')` which is all roles, so: `TRUE`
   - `v_user_role = 'requester'` -> `v_user_role = 'qmrl'`
   - `v_user_role IN ('admin', 'quartermaster', 'proposal', 'finance', 'inventory')` -> `v_user_role IN ('admin', 'qmhq')` but also qmrl maps from frontline/requester and requester had own-only... Simplify: for QMRL entities, anyone with matching entity access; for QMHQ entities, admin and qmhq.

   Recreate the full function with new role logic:
   - Admin can delete any file
   - Original uploader can delete their own file
   - For qmrl entities: admin and qmhq can delete; qmrl can delete if they own the QMRL (requester_id = p_user_id)
   - For qmhq entities: admin and qmhq can delete

3. **`owns_qmrl(UUID)`** and **`owns_qmhq(UUID)`** — These don't reference role values directly (they check requester_id). NO CHANGES needed.

4. **`get_user_role()`** — Already recreated in Plan 01. Skip.

---

**IMPLEMENTATION STRUCTURE:**

The migration file should have clear section comments for each table, following the order above. Within each section:
```sql
-- ============================================
-- TABLE_NAME Policies
-- Old: [old access pattern]
-- New: [new access pattern]
-- ============================================
DROP POLICY IF EXISTS policy_name ON table;
-- ... drop all old policies
CREATE POLICY policy_name ON table ...;
-- ... create all new policies
```

IMPORTANT: The entire file must be wrapped in a single BEGIN/COMMIT transaction. If any policy creation fails, the whole thing rolls back and default-deny keeps the database secure (no gap).

At the end of the migration, add a verification block:
```sql
-- Verify no old role values remain in function definitions
DO $$
DECLARE
  old_role_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO old_role_count
  FROM pg_proc p
  JOIN pg_namespace n ON p.pronamespace = n.oid
  WHERE n.nspname = 'public'
    AND p.prosrc LIKE '%quartermaster%'
    AND p.proname NOT IN ('create_audit_log'); -- audit log function may reference old roles in comments only

  IF old_role_count > 0 THEN
    RAISE WARNING 'Found % public functions still referencing old role values', old_role_count;
  END IF;
END $$;
```
  </action>
  <verify>
Run `npx supabase db reset` from the project root. Both migration files (Plan 01 enum + Plan 02 policies) should apply without errors.

Then run these verification checks:
1. Grep the migration file for old role values to ensure none remain in policy definitions: `grep -c "'quartermaster'\|'frontline'\|'requester'\|'finance'\|'inventory'\|'proposal'" supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql` — should only appear in comments, DROP statements, and section headers (not in CREATE POLICY statements).
2. Verify the file has the correct number of DROP POLICY + CREATE POLICY statements.
3. Confirm `npx supabase db reset` succeeds end-to-end.
  </verify>
  <done>
Migration file exists at supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql. All RLS policies across 20 tables are recreated with new role values. Helper functions can_view_sor_request() and delete_file_attachment() are updated. Zero old role values remain in active policy or function definitions. Database reset completes without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx supabase db reset` completes without errors (both Plan 01 and Plan 02 migrations)
2. No old role values ('quartermaster', 'finance', 'inventory', 'proposal', 'frontline', 'requester') appear in CREATE POLICY or CREATE FUNCTION statements in the new migration
3. All 20 RLS-enabled tables have policies recreated
4. `can_view_sor_request()` function uses `IN ('admin', 'qmhq')` not old role values
5. `delete_file_attachment()` RPC uses new role values
6. Transaction wrapper (BEGIN/COMMIT) ensures atomicity
</verification>

<success_criteria>
- Both migration files apply cleanly on `npx supabase db reset`
- All RLS policies use only 'admin', 'qmrl', 'qmhq' as role values
- Helper functions (can_view_sor_request, delete_file_attachment) updated
- No security gaps — all tables maintain RLS enforcement
- Policies correctly map old permissions to new role structure
</success_criteria>

<output>
After completion, create `.planning/phases/37-rbac-database-migration/37-02-SUMMARY.md`
</output>
