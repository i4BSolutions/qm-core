---
phase: 37-rbac-database-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260211120000_rbac_enum_migration.sql
autonomous: true

must_haves:
  truths:
    - "Database user_role enum contains exactly 3 values: admin, qmrl, qmhq"
    - "All existing users are remapped to appropriate new roles with zero NULL values"
    - "get_user_role() function works with new enum and returns correct role"
    - "has_role() function is removed (dead code cleanup)"
    - "handle_new_user() trigger assigns 'qmrl' as default role for new signups"
  artifacts:
    - path: "supabase/migrations/20260211120000_rbac_enum_migration.sql"
      provides: "Enum migration + function updates in single transactional migration"
      contains: "CREATE TYPE public.user_role AS ENUM"
  key_links:
    - from: "supabase/migrations/20260211120000_rbac_enum_migration.sql"
      to: "public.users.role"
      via: "ALTER TABLE column swap"
      pattern: "RENAME COLUMN role_new TO role"
    - from: "supabase/migrations/20260211120000_rbac_enum_migration.sql"
      to: "public.get_user_role()"
      via: "CREATE OR REPLACE FUNCTION"
      pattern: "get_user_role.*RETURNS public.user_role"
---

<objective>
Migrate the user_role enum from 7 values to 3 values using expand-and-contract pattern, update dependent functions, and validate data integrity.

Purpose: The 7-role enum (admin, quartermaster, finance, inventory, proposal, frontline, requester) is being consolidated to 3 roles (admin, qmrl, qmhq) as part of RBAC simplification. This plan handles the core schema change.

Output: Single migration file that atomically performs enum swap, data migration, function updates, and validation.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/37-rbac-database-migration/37-RESEARCH.md
@supabase/migrations/002_users.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enum migration with data mapping and function updates</name>
  <files>supabase/migrations/20260211120000_rbac_enum_migration.sql</files>
  <action>
Create a single SQL migration file that performs the full enum migration inside a transaction (BEGIN/COMMIT). The migration must execute these steps in order:

**Step 1 - Rename old enum:**
```sql
ALTER TYPE public.user_role RENAME TO user_role_old;
```

**Step 2 - Create new enum:**
```sql
CREATE TYPE public.user_role AS ENUM ('admin', 'qmrl', 'qmhq');
```

**Step 3 - Add temporary column:**
```sql
ALTER TABLE public.users ADD COLUMN role_new public.user_role;
```

**Step 4 - Migrate data with this exact mapping:**
- admin -> admin
- quartermaster -> admin
- finance -> qmhq
- inventory -> qmhq
- proposal -> qmhq
- frontline -> qmrl
- requester -> qmrl

Use `role::text` to cast the old enum column to text for the CASE expression, then cast to new enum.

**Step 5 - Validate no NULLs:**
Use a DO block that counts NULL role_new values and RAISES EXCEPTION if count > 0. This aborts the transaction on data integrity failure.

**Step 6 - Swap columns:**
```sql
ALTER TABLE public.users DROP COLUMN role;
ALTER TABLE public.users RENAME COLUMN role_new TO role;
ALTER TABLE public.users ALTER COLUMN role SET NOT NULL;
ALTER TABLE public.users ALTER COLUMN role SET DEFAULT 'qmrl';
```

Note: Default changes from 'requester' to 'qmrl' (the equivalent new role for field operations).

**Step 7 - Recreate index:**
```sql
DROP INDEX IF EXISTS idx_users_role;
CREATE INDEX idx_users_role ON public.users(role);
```

**Step 8 - Drop old enum:**
```sql
DROP TYPE public.user_role_old;
```

**Step 9 - Drop has_role() function:**
```sql
DROP FUNCTION IF EXISTS public.has_role(user_role_old);
```
Note: The function signature uses the OLD enum type name (since it was renamed in step 1). Drop this dead code entirely.

Also try dropping with text signature as safety:
```sql
DROP FUNCTION IF EXISTS public.has_role(text);
```

**Step 10 - Recreate get_user_role() function:**
The function already returns `public.user_role` which now points to the new enum. Recreate it to ensure it's clean:
```sql
CREATE OR REPLACE FUNCTION public.get_user_role()
RETURNS public.user_role AS $$
  SELECT role FROM public.users WHERE id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER STABLE;
```

**Step 11 - Recreate handle_new_user() function:**
Update default role from 'requester' to 'qmrl':
```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email, full_name, role)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
    'qmrl'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Step 12 - Update comments:**
```sql
COMMENT ON COLUMN public.users.role IS 'User role for RBAC: admin (full access), qmrl (field operations), qmhq (HQ operations)';
COMMENT ON FUNCTION public.get_user_role IS 'Returns current authenticated user role (admin, qmrl, or qmhq)';
```

**Step 13 - Insert audit log marker:**
```sql
INSERT INTO public.audit_logs (entity_type, entity_id, action, summary, changes, created_at)
VALUES (
  'system',
  gen_random_uuid(),
  'update',
  'RBAC migration: 7 roles consolidated to 3 roles (admin, qmrl, qmhq)',
  jsonb_build_object(
    'migration', 'rbac_enum_migration',
    'old_roles', jsonb_build_array('admin', 'quartermaster', 'finance', 'inventory', 'proposal', 'frontline', 'requester'),
    'new_roles', jsonb_build_array('admin', 'qmrl', 'qmhq'),
    'mapping', jsonb_build_object(
      'admin', 'admin',
      'quartermaster', 'admin',
      'finance', 'qmhq',
      'inventory', 'qmhq',
      'proposal', 'qmhq',
      'frontline', 'qmrl',
      'requester', 'qmrl'
    )
  ),
  NOW()
);
```

The entire migration MUST be wrapped in BEGIN/COMMIT. Add a header comment block documenting the phase, purpose, role mapping, and rollback instructions (restore from pre-migration backup).

IMPORTANT: Do NOT touch RLS policies in this migration. RLS policy recreation is handled in Plan 02 (separate migration file).
  </action>
  <verify>
Run `npx supabase db reset` from the project root. The migration should apply without errors. Then verify:

1. Check enum values: The local Supabase should show the new enum with 3 values.
2. Check the migration file has no syntax errors by confirming db reset completes successfully.
3. Visually verify the migration file contains all 13 steps documented above.
  </verify>
  <done>
Migration file exists at supabase/migrations/20260211120000_rbac_enum_migration.sql. It contains: enum rename, new enum creation, temp column, data migration with correct 7-to-3 mapping, NULL validation, column swap with NOT NULL + default 'qmrl', index recreation, old enum drop, has_role() drop, get_user_role() recreation, handle_new_user() update with 'qmrl' default, updated comments, and audit log marker. All wrapped in a transaction.
  </done>
</task>

</tasks>

<verification>
1. `npx supabase db reset` completes without errors
2. Migration file contains BEGIN/COMMIT transaction wrapper
3. All 7 old role values have explicit mapping in the CASE statement
4. NULL validation DO block is present
5. has_role() function is dropped
6. get_user_role() function is recreated with new return type
7. handle_new_user() uses 'qmrl' as default role
8. Audit log marker documents the migration
</verification>

<success_criteria>
- Migration applies cleanly on `npx supabase db reset`
- user_role enum has exactly 3 values: admin, qmrl, qmhq
- has_role() function no longer exists
- get_user_role() returns new enum type
- handle_new_user() assigns 'qmrl' to new users
- Default role on users.role column is 'qmrl'
</success_criteria>

<output>
After completion, create `.planning/phases/37-rbac-database-migration/37-01-SUMMARY.md`
</output>
