---
phase: 23-comments-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/051_comments.sql
  - types/database.ts
autonomous: true

must_haves:
  truths:
    - "Comments table exists with polymorphic entity relationship"
    - "Single-level threading enforced via constraint"
    - "RLS policies mirror parent entity visibility"
    - "Soft delete with deleted_at column works"
  artifacts:
    - path: "supabase/migrations/051_comments.sql"
      provides: "Comments table, indexes, RLS policies, helper functions"
      contains: "CREATE TABLE IF NOT EXISTS public.comments"
    - path: "types/database.ts"
      provides: "Comment TypeScript type"
      contains: "export interface Comment"
  key_links:
    - from: "public.comments"
      to: "public.users"
      via: "author_id foreign key"
      pattern: "author_id UUID.*REFERENCES public.users"
    - from: "comments RLS"
      to: "owns_qmrl, owns_qmhq functions"
      via: "RLS policy using existing helpers"
      pattern: "public.owns_qmrl|public.owns_qmhq"
---

<objective>
Create the database foundation for threaded comments on QMRL, QMHQ, PO, and Invoice entities.

Purpose: Enable persistent comment storage with proper access control following existing file_attachments polymorphic pattern.
Output: Migration file with comments table, RLS policies, and TypeScript types.
</objective>

<execution_context>
@/Users/thihaaung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thihaaung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-comments-system/23-CONTEXT.md
@.planning/phases/23-comments-system/23-RESEARCH.md
@supabase/migrations/030_file_attachments.sql
@supabase/migrations/027_rls_policies.sql
@types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comments table migration</name>
  <files>supabase/migrations/051_comments.sql</files>
  <action>
Create migration file for comments table following the file_attachments polymorphic pattern.

Table structure:
- id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
- entity_type: TEXT NOT NULL CHECK (entity_type IN ('qmrl', 'qmhq', 'po', 'invoice'))
- entity_id: UUID NOT NULL (polymorphic, no FK)
- parent_id: UUID REFERENCES public.comments(id) ON DELETE RESTRICT (for threading)
- content: TEXT NOT NULL CHECK (char_length(content) > 0)
- author_id: UUID NOT NULL REFERENCES public.users(id)
- deleted_at: TIMESTAMPTZ (soft delete)
- deleted_by: UUID REFERENCES public.users(id)
- created_at: TIMESTAMPTZ DEFAULT NOW()
- updated_at: TIMESTAMPTZ DEFAULT NOW()

Add constraint to enforce single-level threading (replies cannot have replies):
```sql
-- Constraint using trigger since CHECK can't reference other rows
CREATE OR REPLACE FUNCTION public.enforce_single_level_reply()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.parent_id IS NOT NULL THEN
    -- Check if parent is itself a reply
    IF EXISTS (SELECT 1 FROM public.comments WHERE id = NEW.parent_id AND parent_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Replies cannot have nested replies (single-level threading only)';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER comments_enforce_single_level
  BEFORE INSERT ON public.comments
  FOR EACH ROW
  EXECUTE FUNCTION public.enforce_single_level_reply();
```

Add indexes:
- idx_comments_entity: ON (entity_type, entity_id) WHERE deleted_at IS NULL
- idx_comments_parent: ON (parent_id) WHERE deleted_at IS NULL
- idx_comments_author: ON (author_id)

Add helper function:
```sql
CREATE OR REPLACE FUNCTION public.comment_has_replies(comment_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.comments
    WHERE parent_id = comment_id AND deleted_at IS NULL
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

Add updated_at trigger (follow existing pattern from file_attachments).

Enable RLS on the table.
  </action>
  <verify>Run `npx supabase db reset` successfully with no errors</verify>
  <done>Comments table created with all columns, constraints, indexes, and helper functions</done>
</task>

<task type="auto">
  <name>Task 2: Add RLS policies for comments</name>
  <files>supabase/migrations/051_comments.sql</files>
  <action>
Add RLS policies to the same migration file (after table creation).

Follow the file_attachments RLS pattern exactly:

SELECT policy:
- Privileged roles (admin, quartermaster, finance, inventory, proposal, frontline) see all non-deleted comments
- Requester role:
  - Can see comments on QMRL they own (entity_type = 'qmrl' AND owns_qmrl(entity_id))
  - Can see comments on QMHQ linked to their QMRL (entity_type = 'qmhq' AND owns_qmhq(entity_id))
  - Cannot see PO or Invoice comments (per existing RLS - requesters don't have access to those entities)

INSERT policy:
- Admin, Quartermaster: can comment on any entity
- Proposal, Frontline: can comment on qmrl and qmhq
- Finance, Inventory: can comment on any entity (they need to discuss PO/Invoice)
- Requester: can only comment on their own QMRL (entity_type = 'qmrl' AND owns_qmrl(entity_id))

UPDATE policy (for soft delete):
- Users can soft-delete their own comments (author_id = auth.uid())
- Only allow setting deleted_at and deleted_by (not editing content)
- Additional check: Cannot delete if has replies (use comment_has_replies function)

DELETE policy (hard delete):
- Admin only (for cleanup)

Example SELECT policy:
```sql
CREATE POLICY comments_select ON public.comments
  FOR SELECT USING (
    deleted_at IS NULL
    AND (
      public.get_user_role() IN ('admin', 'quartermaster', 'finance', 'inventory', 'proposal', 'frontline')
      OR (
        public.get_user_role() = 'requester'
        AND entity_type = 'qmrl'
        AND public.owns_qmrl(entity_id)
      )
      OR (
        public.get_user_role() = 'requester'
        AND entity_type = 'qmhq'
        AND public.owns_qmhq(entity_id)
      )
    )
  );
```
  </action>
  <verify>After db reset, test with different roles via Supabase dashboard SQL editor</verify>
  <done>All 4 RLS policies (SELECT, INSERT, UPDATE, DELETE) created following file_attachments pattern</done>
</task>

<task type="auto">
  <name>Task 3: Add Comment TypeScript type</name>
  <files>types/database.ts</files>
  <action>
Add Comment interface to types/database.ts following existing patterns.

```typescript
export interface Comment {
  id: string;
  entity_type: 'qmrl' | 'qmhq' | 'po' | 'invoice';
  entity_id: string;
  parent_id: string | null;
  content: string;
  author_id: string;
  deleted_at: string | null;
  deleted_by: string | null;
  created_at: string;
  updated_at: string;
}

// Extended type with author relation for UI display
export interface CommentWithAuthor extends Comment {
  author: Pick<User, 'id' | 'full_name' | 'avatar_url'>;
}

// Grouped comment with replies for threaded display
export interface CommentWithReplies extends CommentWithAuthor {
  replies: CommentWithAuthor[];
}
```

Add 'comment' to EntityType if exists, or add it:
```typescript
export type CommentEntityType = 'qmrl' | 'qmhq' | 'po' | 'invoice';
```
  </action>
  <verify>Run `npm run type-check` with no errors</verify>
  <done>Comment, CommentWithAuthor, CommentWithReplies types exported from types/database.ts</done>
</task>

</tasks>

<verification>
1. `npx supabase db reset` completes without errors
2. `npm run type-check` passes
3. Supabase dashboard shows comments table with correct schema
4. RLS policies visible in dashboard under Authentication > Policies
</verification>

<success_criteria>
- Comments table exists with all columns, constraints, and indexes
- Single-level threading enforced (replies to replies blocked)
- RLS policies match file_attachments visibility pattern
- comment_has_replies helper function exists
- TypeScript types available for use in frontend
</success_criteria>

<output>
After completion, create `.planning/phases/23-comments-system/23-01-SUMMARY.md`
</output>
