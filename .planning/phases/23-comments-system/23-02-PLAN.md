---
phase: 23-comments-system
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - components/comments/index.ts
  - components/comments/comments-section.tsx
  - components/comments/comment-card.tsx
  - components/comments/comment-input.tsx
  - components/comments/delete-comment-dialog.tsx
  - components/comments/comments-skeleton.tsx
autonomous: true

must_haves:
  truths:
    - "CommentsSection component renders threaded comments"
    - "CommentCard displays author avatar, name, absolute timestamp"
    - "Reply button only appears on parent comments"
    - "Delete button disabled with tooltip when comment has replies"
    - "Delete confirmation dialog appears before deletion"
  artifacts:
    - path: "components/comments/comments-section.tsx"
      provides: "Main container with header, count, and comment list"
      exports: ["CommentsSection"]
    - path: "components/comments/comment-card.tsx"
      provides: "Individual comment display with actions"
      exports: ["CommentCard"]
    - path: "components/comments/comment-input.tsx"
      provides: "Add/reply input form"
      exports: ["CommentInput"]
    - path: "components/comments/delete-comment-dialog.tsx"
      provides: "Confirmation dialog for delete"
      exports: ["DeleteCommentDialog"]
  key_links:
    - from: "CommentsSection"
      to: "supabase.from('comments')"
      via: "fetch on mount"
      pattern: "from\\(['\"]comments['\"]\\)"
    - from: "CommentCard"
      to: "DeleteCommentDialog"
      via: "delete button onClick"
      pattern: "DeleteCommentDialog|onDelete"
---

<objective>
Create the React components for displaying and interacting with threaded comments.

Purpose: Provide reusable comment UI that can be embedded in any detail page.
Output: Complete set of comment components ready for integration.
</objective>

<execution_context>
@/Users/thihaaung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thihaaung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-comments-system/23-CONTEXT.md
@.planning/phases/23-comments-system/23-RESEARCH.md
@.planning/phases/23-comments-system/23-01-SUMMARY.md
@types/database.ts
@components/ui/dialog.tsx
@components/ui/button.tsx
@components/ui/skeleton.tsx
@app/(dashboard)/qmrl/[id]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comment display components</name>
  <files>
    components/comments/index.ts
    components/comments/comments-section.tsx
    components/comments/comment-card.tsx
    components/comments/comments-skeleton.tsx
  </files>
  <action>
Create the components/comments directory and implement display components.

**components/comments/index.ts** - Barrel export:
```typescript
export { CommentsSection } from './comments-section';
export { CommentCard } from './comment-card';
export { CommentInput } from './comment-input';
export { DeleteCommentDialog } from './delete-comment-dialog';
```

**components/comments/comments-skeleton.tsx**:
- 3 skeleton cards for loading state
- Each skeleton: avatar circle (h-8 w-8), name bar, timestamp bar, content block
- Use existing Skeleton component from @/components/ui/skeleton
- Follow existing skeleton patterns in the codebase

**components/comments/comment-card.tsx**:
Props interface:
```typescript
interface CommentCardProps {
  comment: CommentWithAuthor;
  onReply?: () => void;
  onDelete?: () => void;
  canDelete: boolean;
  hasReplies: boolean;
  isReply?: boolean;
}
```

Layout (per user decision - card-based with border and subtle shadow):
- Card container: rounded-lg border border-slate-700 bg-slate-800/30 p-4 shadow-soft
- Flex layout with avatar on left, content on right
- Avatar: h-8 w-8 rounded-full bg-amber-500/20 border border-amber-500/30 with User icon
- Author name: font-medium text-slate-200
- Timestamp: text-xs text-slate-400, use date-fns format: "MMM d, yyyy 'at' h:mm a"
- Content: text-slate-300 whitespace-pre-wrap (plain text per user decision)
- Actions row at bottom with Reply and Delete buttons

Reply button (only on parent comments - !isReply):
- variant="ghost" size="sm"
- Reply icon + "Reply" text
- text-slate-400 hover:text-amber-500

Delete button (always visible on own comments):
- variant="ghost" size="sm"
- Trash2 icon only (no text)
- Wrapped in Tooltip when hasReplies=true showing "Cannot delete: has replies"
- Disabled when hasReplies=true
- text-slate-400 hover:text-red-400 disabled:opacity-50

**components/comments/comments-section.tsx**:
Props:
```typescript
interface CommentsSectionProps {
  entityType: 'qmrl' | 'qmhq' | 'po' | 'invoice';
  entityId: string;
}
```

State:
- comments: CommentWithReplies[]
- isLoading: boolean
- replyingTo: string | null (parent comment ID when replying)
- deleteTarget: CommentWithAuthor | null (comment being deleted)

Fetch logic:
```typescript
const fetchComments = async () => {
  const supabase = createClient();
  const { data } = await supabase
    .from("comments")
    .select(`*, author:users!comments_author_id_fkey(id, full_name, avatar_url)`)
    .eq("entity_type", entityType)
    .eq("entity_id", entityId)
    .is("deleted_at", null)
    .order("created_at", { ascending: true });

  // Group into parent + replies structure
  const grouped = data?.reduce((acc, comment) => {
    if (!comment.parent_id) {
      acc.push({ ...comment, replies: [] });
    } else {
      const parent = acc.find(c => c.id === comment.parent_id);
      if (parent) parent.replies.push(comment);
    }
    return acc;
  }, [] as CommentWithReplies[]) || [];

  setComments(grouped);
};
```

Layout (per user decision - inline section at bottom):
- Container: command-panel corner-accents (matches existing panels)
- Section header: MessageSquare icon + "Comments ({count})"
- Loading: show CommentsSkeleton
- Empty: text-center with MessageSquare icon, "No comments yet" text
- Comment list: space-y-4
  - Each parent comment with CommentCard
  - Replies indented: ml-8 mt-2 border-l-2 border-slate-700 pl-4 space-y-2
- CommentInput at bottom with border-t separator

Wire up canDelete check using useAuth hook - user can only delete own comments.
  </action>
  <verify>Create test file and render CommentsSection, verify loading skeleton appears</verify>
  <done>CommentsSection renders with loading state, empty state, and threaded comments display</done>
</task>

<task type="auto">
  <name>Task 2: Create comment input and delete dialog</name>
  <files>
    components/comments/comment-input.tsx
    components/comments/delete-comment-dialog.tsx
  </files>
  <action>
**components/comments/comment-input.tsx**:
Props:
```typescript
interface CommentInputProps {
  entityType: 'qmrl' | 'qmhq' | 'po' | 'invoice';
  entityId: string;
  parentId?: string | null;
  replyingToName?: string;
  onCancel?: () => void;
  onSubmit: (comment: CommentWithAuthor) => void;
}
```

State:
- content: string
- isSubmitting: boolean

Layout:
- If replyingToName provided, show "Replying to @{name}" label with Cancel button
- Textarea: min-h-[80px] resize-none, placeholder "Add a comment..."
- Submit button: disabled when content.trim() empty or isSubmitting
- Button text: "Reply" if parentId, "Comment" otherwise

Submit logic:
```typescript
const handleSubmit = async () => {
  if (!content.trim()) return;
  setIsSubmitting(true);

  const supabase = createClient();
  const { data: userData } = await supabase.auth.getUser();

  const { data, error } = await supabase
    .from("comments")
    .insert({
      entity_type: entityType,
      entity_id: entityId,
      parent_id: parentId || null,
      content: content.trim(),
      author_id: userData.user?.id
    })
    .select(`*, author:users!comments_author_id_fkey(id, full_name, avatar_url)`)
    .single();

  if (error) {
    toast({ title: "Failed to add comment", variant: "destructive" });
  } else {
    setContent("");
    onSubmit(data);
    toast({ title: parentId ? "Reply added" : "Comment added", variant: "success" });
    if (onCancel) onCancel(); // Close reply mode
  }
  setIsSubmitting(false);
};
```

**components/comments/delete-comment-dialog.tsx**:
Props:
```typescript
interface DeleteCommentDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => Promise<void>;
  isDeleting: boolean;
}
```

Use existing Dialog components from @/components/ui/dialog.

Layout:
- DialogTitle: "Delete Comment"
- DialogDescription: "Are you sure you want to delete this comment? This action cannot be undone."
- DialogFooter with Cancel and Delete buttons
- Delete button: variant="destructive", shows Loader2 spinner when isDeleting

The delete logic lives in CommentsSection, which calls:
```typescript
const handleDelete = async (comment: CommentWithAuthor) => {
  setIsDeleting(true);
  const supabase = createClient();

  const { error } = await supabase
    .from("comments")
    .update({
      deleted_at: new Date().toISOString(),
      deleted_by: user?.id
    })
    .eq("id", comment.id);

  if (error) {
    toast({ title: "Failed to delete comment", variant: "destructive" });
  } else {
    // Remove from local state
    setComments(prev => /* filter out deleted comment or reply */);
    toast({ title: "Comment deleted" });
  }
  setIsDeleting(false);
  setDeleteTarget(null);
};
```
  </action>
  <verify>Import CommentInput into CommentsSection, test adding a new comment and replying</verify>
  <done>CommentInput handles add/reply submission, DeleteCommentDialog shows confirmation</done>
</task>

<task type="auto">
  <name>Task 3: Wire up delete and reply flows</name>
  <files>components/comments/comments-section.tsx</files>
  <action>
Complete the CommentsSection component with full delete and reply functionality.

Add delete state and handlers:
```typescript
const [deleteTarget, setDeleteTarget] = useState<CommentWithAuthor | null>(null);
const [isDeleting, setIsDeleting] = useState(false);

const handleDeleteClick = (comment: CommentWithAuthor) => {
  setDeleteTarget(comment);
};

const handleDeleteConfirm = async () => {
  if (!deleteTarget) return;
  setIsDeleting(true);

  const supabase = createClient();
  const { error } = await supabase
    .from("comments")
    .update({
      deleted_at: new Date().toISOString(),
      deleted_by: user?.id
    })
    .eq("id", deleteTarget.id);

  if (error) {
    toast({ title: "Failed to delete comment", variant: "destructive" });
  } else {
    // Update local state
    if (deleteTarget.parent_id) {
      // It's a reply - remove from parent's replies array
      setComments(prev => prev.map(c => ({
        ...c,
        replies: c.replies.filter(r => r.id !== deleteTarget.id)
      })));
    } else {
      // It's a parent - remove entirely (should not happen if has replies due to UI disable)
      setComments(prev => prev.filter(c => c.id !== deleteTarget.id));
    }
    toast({ title: "Comment deleted" });
  }

  setIsDeleting(false);
  setDeleteTarget(null);
};
```

Add reply state and handlers:
```typescript
const [replyingTo, setReplyingTo] = useState<string | null>(null);

const handleReplyClick = (commentId: string) => {
  setReplyingTo(commentId);
};

const handleNewComment = (newComment: CommentWithAuthor) => {
  if (newComment.parent_id) {
    // It's a reply - add to parent's replies array
    setComments(prev => prev.map(c =>
      c.id === newComment.parent_id
        ? { ...c, replies: [...c.replies, newComment] }
        : c
    ));
  } else {
    // It's a new parent comment
    setComments(prev => [...prev, { ...newComment, replies: [] }]);
  }
};
```

Render the DeleteCommentDialog:
```tsx
<DeleteCommentDialog
  isOpen={!!deleteTarget}
  onClose={() => setDeleteTarget(null)}
  onConfirm={handleDeleteConfirm}
  isDeleting={isDeleting}
/>
```

Render CommentInput at bottom:
```tsx
<div className="mt-4 pt-4 border-t border-slate-700">
  <CommentInput
    entityType={entityType}
    entityId={entityId}
    parentId={replyingTo}
    replyingToName={replyingTo
      ? comments.find(c => c.id === replyingTo)?.author.full_name
      : undefined
    }
    onCancel={() => setReplyingTo(null)}
    onSubmit={handleNewComment}
  />
</div>
```

Pass correct props to CommentCard:
```tsx
<CommentCard
  comment={comment}
  onReply={() => handleReplyClick(comment.id)}
  onDelete={() => handleDeleteClick(comment)}
  canDelete={user?.id === comment.author_id}
  hasReplies={comment.replies.length > 0}
/>
```
  </action>
  <verify>Test full flow: add comment, reply to comment, delete reply, verify parent cannot be deleted</verify>
  <done>Complete comment interaction flow: add, reply, delete with proper state management</done>
</task>

</tasks>

<verification>
1. CommentsSection loads and displays comments correctly
2. Reply button only appears on parent comments
3. Replying shows "Replying to @name" with cancel option
4. New comments/replies appear immediately after submission
5. Delete button disabled with tooltip when comment has replies
6. Delete confirmation dialog appears and works
7. Success toasts shown after add/reply/delete
</verification>

<success_criteria>
- All comment components created and exported
- Threaded display with replies indented under parents
- Add comment and reply flows work with optimistic updates
- Delete with confirmation, blocked when has replies
- Proper loading and empty states
- Follows existing UI patterns (command-panel, section-header)
</success_criteria>

<output>
After completion, create `.planning/phases/23-comments-system/23-02-SUMMARY.md`
</output>
