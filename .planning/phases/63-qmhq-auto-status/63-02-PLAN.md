---
phase: 63-qmhq-auto-status
plan: 02
type: execute
wave: 2
depends_on:
  - 63-01
files_modified:
  - app/(dashboard)/qmhq/[id]/page.tsx
autonomous: true
requirements:
  - AUTO-01
  - AUTO-02
  - AUTO-03
  - AUTO-04
  - AUTO-05
  - AUTO-06
  - AUTO-07
  - AUTO-08
  - AUTO-09

must_haves:
  truths:
    - "QMHQ detail page displays auto status badge alongside manual status"
    - "Item route detail page shows Item Pending/Processing/Done based on SOR state"
    - "Expense route detail page shows Expense Pending/Processing/Done based on money-in and yet-to-receive"
    - "PO route detail page shows PO Pending/Processing/Done based on PO existence and financial closure"
    - "All users who can view QMHQ detail page see the auto status badge"
  artifacts:
    - path: "app/(dashboard)/qmhq/[id]/page.tsx"
      provides: "QMHQ detail page with auto status badge integration"
      contains: "AutoStatusBadge"
  key_links:
    - from: "app/(dashboard)/qmhq/[id]/page.tsx"
      to: "lib/utils/qmhq-auto-status.ts"
      via: "import computeQmhqAutoStatus"
      pattern: "computeQmhqAutoStatus"
    - from: "app/(dashboard)/qmhq/[id]/page.tsx"
      to: "components/qmhq/auto-status-badge.tsx"
      via: "import AutoStatusBadge"
      pattern: "AutoStatusBadge"
---

<objective>
Wire auto status computation and badge display into the QMHQ detail page.

Purpose: Make the computed auto status visible on every QMHQ detail page, alongside the existing manual status. The auto status is derived on-the-fly from already-fetched child record data (no additional queries needed).
Output: Updated `app/(dashboard)/qmhq/[id]/page.tsx` with auto status badge
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-qmhq-auto-status/63-CONTEXT.md
@.planning/phases/63-qmhq-auto-status/63-01-SUMMARY.md

@app/(dashboard)/qmhq/[id]/page.tsx
@lib/utils/qmhq-auto-status.ts
@components/qmhq/auto-status-badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Compute auto status from existing page data</name>
  <files>app/(dashboard)/qmhq/[id]/page.tsx</files>
  <action>
Add auto status computation to the QMHQ detail page using a `useMemo` that derives the status from data already fetched by `fetchData()`. No additional Supabase queries needed.

**Imports to add:**
- `import { computeQmhqAutoStatus } from "@/lib/utils/qmhq-auto-status";`
- `import { AutoStatusBadge } from "@/components/qmhq/auto-status-badge";`

**Create a `useMemo` for auto status computation** (place after existing useMemo blocks like `itemsProgressData`, before the early return guards):

```typescript
const autoStatus = useMemo(() => {
  if (!qmhq) return null;

  if (qmhq.route_type === "item") {
    // Check if any SOR L1 or L2 approval exists
    const hasAnySorApproval = stockOutRequest?.line_items?.some(
      (li: any) => li.approvals?.some(
        (a: any) => a.decision === "approved" && (a.layer === "quartermaster" || a.layer === "admin")
      )
    ) ?? false;

    // Check if all SOR line items are executed (same logic as allItemsFullyIssued)
    return computeQmhqAutoStatus({
      routeType: "item",
      hasAnySorApproval,
      allSorLineItemsExecuted: allItemsFullyIssued,
    });
  }

  if (qmhq.route_type === "expense") {
    // Money-in total already computed as moneyInTotal (EUSD)
    // But moneyInTotal is defined after the early return â€” need to compute here
    const moneyInEusd = transactions
      .filter((t) => t.transaction_type === "money_in")
      .reduce((sum, t) => sum + (t.amount_eusd ?? 0), 0);
    const yetToReceiveEusd = (qmhq.amount_eusd ?? 0) - moneyInEusd;

    return computeQmhqAutoStatus({
      routeType: "expense",
      hasAnyMoneyIn: moneyInEusd > 0,
      yetToReceiveEusd,
    });
  }

  if (qmhq.route_type === "po") {
    // Check for any non-cancelled PO
    const hasNonCancelledPO = purchaseOrders.some(
      (po) => po.status !== "cancelled"
    );

    // Yet to receive and balance in hand calculations
    const moneyInEusd = transactions
      .filter((t) => t.transaction_type === "money_in")
      .reduce((sum, t) => sum + (t.amount_eusd ?? 0), 0);
    const yetToReceivePOEusd = (qmhq.amount_eusd ?? 0) - moneyInEusd;
    const balanceInHandEusd = moneyInEusd - (qmhq.total_po_committed ?? 0);

    return computeQmhqAutoStatus({
      routeType: "po",
      hasNonCancelledPO,
      yetToReceivePOEusd,
      balanceInHandEusd,
    });
  }

  return null;
}, [qmhq, stockOutRequest, allItemsFullyIssued, transactions, purchaseOrders]);
```

Note: The `moneyInTotal` variable is currently defined AFTER the early returns. The auto status useMemo is placed BEFORE the early returns (per React hooks rules), so it must compute moneyInEusd locally within the memo. This is fine since `transactions` is already in scope.
  </action>
  <verify>Run `npm run type-check` to confirm no TypeScript errors. Verify the useMemo correctly derives auto status for all three route types using existing state variables.</verify>
  <done>Auto status is computed via useMemo from existing page state. No additional Supabase queries. All 9 status transitions are derived from the correct child record data.</done>
</task>

<task type="auto">
  <name>Task 2: Display auto status badge in detail page header</name>
  <files>app/(dashboard)/qmhq/[id]/page.tsx</files>
  <action>
Add the `AutoStatusBadge` component to the QMHQ detail page header, positioned alongside the existing route type badge and manual status badge.

**Placement:** In the `header` prop of `DetailPageLayout`, inside the flex container that already holds the route type badge and ClickableStatusBadge (around line ~594-608). Add the AutoStatusBadge between the route type badge and the manual status ClickableStatusBadge.

Update the header section to:
```tsx
<div className="flex items-center gap-3 mb-2 flex-wrap">
  {/* Route Type Badge (existing) */}
  <div className={`flex items-center gap-2 px-3 py-1 rounded border ${routeColors?.bgColor}`}>
    <RouteIcon className={`h-4 w-4 ${routeColors?.color}`} />
    <span className={`text-xs font-semibold uppercase tracking-widest ${routeColors?.color}`}>
      {routeColors?.label} Route
    </span>
  </div>

  {/* Auto Status Badge (NEW) */}
  {autoStatus && <AutoStatusBadge status={autoStatus} />}

  {/* Manual Status Badge (existing) */}
  {qmhq.status && (
    <ClickableStatusBadge
      status={qmhq.status}
      entityType="qmhq"
      entityId={qmhq.id}
      onStatusChange={fetchData}
    />
  )}
</div>
```

The auto status badge sits between the route type indicator and the manual status, making it visually clear that the auto status is a computed property of the route while the manual status is user-controlled. Add `flex-wrap` to handle narrow viewports gracefully.

Per user decision: auto status is shown on detail pages only, not on list views. All users who can view the detail page see it (no permission gating needed).
  </action>
  <verify>
1. Run `npm run type-check` to confirm no TypeScript errors
2. Run `npm run build` to confirm production build succeeds
3. Verify the AutoStatusBadge renders in the header alongside the route type badge and manual status
  </verify>
  <done>
1. QMHQ detail page shows auto status badge between route type badge and manual status badge
2. Item route QMHQs display Item Pending / Item Processing / Item Done based on SOR state
3. Expense route QMHQs display Expense Pending / Expense Processing / Expense Done based on money-in and yet-to-receive
4. PO route QMHQs display PO Pending / PO Processing / PO Done based on PO existence and financial closure
5. All viewers see the auto status (no permission restriction)
6. Auto status coexists with manual status (not replacing it)
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes
2. `npm run build` succeeds
3. QMHQ detail page for an Item route QMHQ shows the auto status badge
4. QMHQ detail page for an Expense route QMHQ shows the auto status badge
5. QMHQ detail page for a PO route QMHQ shows the auto status badge
6. Auto status transitions correctly: Pending (no child records) -> Processing (some activity) -> Done (completion criteria met)
7. Manual status badge (ClickableStatusBadge) still works alongside auto status
</verification>

<success_criteria>
- Auto status badge visible on every QMHQ detail page
- Correct auto status shown for each route type based on child record state
- No regression to existing QMHQ detail page functionality
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/63-qmhq-auto-status/63-02-SUMMARY.md`
</output>
