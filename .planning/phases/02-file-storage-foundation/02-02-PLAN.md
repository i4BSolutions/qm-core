---
phase: 02-file-storage-foundation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/utils/file-validation.ts
  - lib/actions/files.ts
  - types/database.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "File extension validation rejects non-allowed file types"
    - "File size validation rejects files over 25MB"
    - "Upload action creates file_attachments record and storage object atomically"
    - "Delete action soft-deletes metadata (does not remove storage object)"
    - "Storage path generation prevents filename collisions"
    - "Application builds successfully with file attachment types"
  artifacts:
    - path: "lib/utils/file-validation.ts"
      provides: "Extension, size validation and path generation"
      exports: ["validateFileExtension", "validateFileSize", "generateStoragePath", "ALLOWED_EXTENSIONS", "MAX_FILE_SIZE"]
    - path: "lib/actions/files.ts"
      provides: "Server actions for upload and soft-delete"
      exports: ["uploadFile", "deleteFile", "getFilesByEntity"]
    - path: "types/database.ts"
      provides: "FileAttachment TypeScript type"
      contains: "file_attachments"
  key_links:
    - from: "lib/actions/files.ts"
      to: "supabase.storage.from('attachments')"
      via: "Storage SDK upload"
      pattern: "storage\\.from\\('attachments'\\)"
    - from: "lib/actions/files.ts"
      to: "file_attachments table"
      via: "Supabase client insert"
      pattern: "from\\('file_attachments'\\)"
---

<objective>
Build server-side utilities for file validation and create server actions for file upload/delete operations.

Purpose: Provides the application layer that Phase 3 UI will call to manage file attachments safely.
Output: Validation utilities, server actions, and TypeScript types for file operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-file-storage-foundation/02-CONTEXT.md
@.planning/phases/02-file-storage-foundation/02-RESEARCH.md
@.planning/phases/02-file-storage-foundation/02-01-SUMMARY.md

@lib/supabase/server.ts (for server client pattern)
@lib/utils/index.ts (for utility patterns)
@types/database.ts (for type patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file validation utilities</name>
  <files>lib/utils/file-validation.ts</files>
  <action>
Create file validation utility module with:

1. **Constants:**
   ```typescript
   export const ALLOWED_EXTENSIONS = [
     // Images
     '.jpg', '.jpeg', '.png', '.gif', '.webp',
     // PDF
     '.pdf',
     // Office modern
     '.docx', '.xlsx', '.pptx',
     // Office legacy
     '.doc', '.xls', '.ppt'
   ] as const;

   export const MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB in bytes

   export const EXTENSION_MIME_MAP: Record<string, string> = {
     '.jpg': 'image/jpeg',
     '.jpeg': 'image/jpeg',
     '.png': 'image/png',
     '.gif': 'image/gif',
     '.webp': 'image/webp',
     '.pdf': 'application/pdf',
     '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
     '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
     '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
     '.doc': 'application/msword',
     '.xls': 'application/vnd.ms-excel',
     '.ppt': 'application/vnd.ms-powerpoint',
   };
   ```

2. **Validation functions:**
   ```typescript
   export function getFileExtension(filename: string): string {
     const lastDot = filename.lastIndexOf('.');
     if (lastDot === -1) return '';
     return filename.slice(lastDot).toLowerCase();
   }

   export function validateFileExtension(filename: string): boolean {
     const ext = getFileExtension(filename);
     return ALLOWED_EXTENSIONS.includes(ext as typeof ALLOWED_EXTENSIONS[number]);
   }

   export function validateFileSize(sizeInBytes: number): boolean {
     return sizeInBytes > 0 && sizeInBytes <= MAX_FILE_SIZE;
   }

   export function validateFile(filename: string, sizeInBytes: number): {
     valid: boolean;
     error?: string;
   } {
     if (!validateFileExtension(filename)) {
       return { valid: false, error: 'File type not allowed' };
     }
     if (!validateFileSize(sizeInBytes)) {
       return { valid: false, error: 'File size exceeds 25MB limit' };
     }
     return { valid: true };
   }
   ```

3. **Path generation:**
   ```typescript
   export function generateStoragePath(
     entityType: 'qmrl' | 'qmhq',
     entityId: string,
     filename: string
   ): string {
     // Add timestamp to prevent collisions while preserving original name in metadata
     const timestamp = Date.now();
     const ext = getFileExtension(filename);
     const baseName = filename.slice(0, filename.lastIndexOf('.'));
     // Sanitize baseName for safe path (remove special chars but keep readability)
     const safeName = baseName.replace(/[^a-zA-Z0-9-_]/g, '_').slice(0, 50);
     return `${entityType}/${entityId}/${safeName}_${timestamp}${ext}`;
   }

   export function getMimeType(filename: string): string {
     const ext = getFileExtension(filename);
     return EXTENSION_MIME_MAP[ext] || 'application/octet-stream';
   }
   ```

4. **Format helpers:**
   ```typescript
   export function formatFileSize(bytes: number): string {
     if (bytes === 0) return '0 B';
     const k = 1024;
     const sizes = ['B', 'KB', 'MB', 'GB'];
     const i = Math.floor(Math.log(bytes) / Math.log(k));
     return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
   }
   ```

Include JSDoc comments for each function.
  </action>
  <verify>
Create a test: Import functions and verify:
- validateFileExtension('doc.pdf') returns true
- validateFileExtension('script.exe') returns false
- validateFileSize(1000000) returns true
- validateFileSize(30000000) returns false
- generateStoragePath creates unique paths with timestamps
  </verify>
  <done>
File validation utilities exported with extension checking, size validation, and path generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create file server actions</name>
  <files>lib/actions/files.ts</files>
  <action>
Create server actions for file operations:

1. **File structure:**
   ```typescript
   'use server';

   import { createClient } from '@/lib/supabase/server';
   import {
     validateFile,
     generateStoragePath,
     getMimeType,
   } from '@/lib/utils/file-validation';
   import { revalidatePath } from 'next/cache';
   ```

2. **uploadFile action:**
   ```typescript
   export async function uploadFile(
     formData: FormData,
     entityType: 'qmrl' | 'qmhq',
     entityId: string
   ): Promise<{ success: true; data: FileAttachment } | { success: false; error: string }> {
     const supabase = createClient();

     // Get current user
     const { data: { user }, error: authError } = await supabase.auth.getUser();
     if (authError || !user) {
       return { success: false, error: 'Not authenticated' };
     }

     // Get file from form data
     const file = formData.get('file') as File | null;
     if (!file) {
       return { success: false, error: 'No file provided' };
     }

     // Validate file
     const validation = validateFile(file.name, file.size);
     if (!validation.valid) {
       return { success: false, error: validation.error! };
     }

     // Generate storage path
     const storagePath = generateStoragePath(entityType, entityId, file.name);

     // Upload to storage
     const { error: uploadError } = await supabase.storage
       .from('attachments')
       .upload(storagePath, file, {
         cacheControl: '3600',
         upsert: false,
       });

     if (uploadError) {
       return { success: false, error: `Upload failed: ${uploadError.message}` };
     }

     // Create metadata record
     const { data, error: insertError } = await supabase
       .from('file_attachments')
       .insert({
         entity_type: entityType,
         entity_id: entityId,
         filename: file.name,
         storage_path: storagePath,
         file_size: file.size,
         mime_type: getMimeType(file.name),
         uploaded_by: user.id,
       })
       .select()
       .single();

     if (insertError) {
       // Rollback: delete uploaded file
       await supabase.storage.from('attachments').remove([storagePath]);
       return { success: false, error: `Failed to save file record: ${insertError.message}` };
     }

     revalidatePath(`/${entityType}/${entityId}`);
     return { success: true, data };
   }
   ```

3. **deleteFile action (soft delete):**
   ```typescript
   export async function deleteFile(
     fileId: string
   ): Promise<{ success: true } | { success: false; error: string }> {
     const supabase = createClient();

     // Get current user
     const { data: { user }, error: authError } = await supabase.auth.getUser();
     if (authError || !user) {
       return { success: false, error: 'Not authenticated' };
     }

     // Soft delete (RLS will verify admin/quartermaster role)
     const { data, error } = await supabase
       .from('file_attachments')
       .update({
         deleted_at: new Date().toISOString(),
         deleted_by: user.id,
         updated_at: new Date().toISOString(),
       })
       .eq('id', fileId)
       .select('entity_type, entity_id')
       .single();

     if (error) {
       return { success: false, error: `Delete failed: ${error.message}` };
     }

     // Note: Storage object NOT deleted - cleanup job handles after 30 days
     revalidatePath(`/${data.entity_type}/${data.entity_id}`);
     return { success: true };
   }
   ```

4. **getFilesByEntity query:**
   ```typescript
   export async function getFilesByEntity(
     entityType: 'qmrl' | 'qmhq',
     entityId: string
   ): Promise<{ success: true; data: FileAttachment[] } | { success: false; error: string }> {
     const supabase = createClient();

     const { data, error } = await supabase
       .from('file_attachments')
       .select('*, uploaded_by_user:users!uploaded_by(full_name, email)')
       .eq('entity_type', entityType)
       .eq('entity_id', entityId)
       .is('deleted_at', null)
       .order('uploaded_at', { ascending: false });

     if (error) {
       return { success: false, error: error.message };
     }

     return { success: true, data: data || [] };
   }
   ```

5. **getFileUrl helper:**
   ```typescript
   export async function getFileUrl(
     storagePath: string
   ): Promise<{ success: true; url: string } | { success: false; error: string }> {
     const supabase = createClient();

     const { data, error } = await supabase.storage
       .from('attachments')
       .createSignedUrl(storagePath, 3600); // 1 hour expiry

     if (error) {
       return { success: false, error: error.message };
     }

     return { success: true, url: data.signedUrl };
   }
   ```

Import FileAttachment type from database.ts (added in Task 3).
Use proper error handling with try/catch where needed.
  </action>
  <verify>
Build check: `npm run build` passes without type errors.
Manual test: Create a test script that calls uploadFile with a mock FormData.
  </verify>
  <done>
Server actions for uploadFile, deleteFile, getFilesByEntity, and getFileUrl ready for Phase 3 UI integration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add FileAttachment type to database types</name>
  <files>types/database.ts</files>
  <action>
Update types/database.ts to add the file_attachments table type:

1. **Add to Tables section:**
   ```typescript
   file_attachments: {
     Row: {
       id: string
       entity_type: 'qmrl' | 'qmhq'
       entity_id: string
       filename: string
       storage_path: string
       file_size: number
       mime_type: string
       uploaded_by: string
       uploaded_at: string
       deleted_at: string | null
       deleted_by: string | null
       created_at: string
       updated_at: string
     }
     Insert: {
       id?: string
       entity_type: 'qmrl' | 'qmhq'
       entity_id: string
       filename: string
       storage_path: string
       file_size: number
       mime_type: string
       uploaded_by: string
       uploaded_at?: string
       deleted_at?: string | null
       deleted_by?: string | null
       created_at?: string
       updated_at?: string
     }
     Update: {
       id?: string
       entity_type?: 'qmrl' | 'qmhq'
       entity_id?: string
       filename?: string
       storage_path?: string
       file_size?: number
       mime_type?: string
       uploaded_by?: string
       uploaded_at?: string
       deleted_at?: string | null
       deleted_by?: string | null
       created_at?: string
       updated_at?: string
     }
     Relationships: [
       {
         foreignKeyName: "file_attachments_uploaded_by_fkey"
         columns: ["uploaded_by"]
         isOneToOne: false
         referencedRelation: "users"
         referencedColumns: ["id"]
       },
       {
         foreignKeyName: "file_attachments_deleted_by_fkey"
         columns: ["deleted_by"]
         isOneToOne: false
         referencedRelation: "users"
         referencedColumns: ["id"]
       }
     ]
   }
   ```

2. **Add convenience type export at bottom of file:**
   ```typescript
   export type FileAttachment = Database['public']['Tables']['file_attachments']['Row'];
   export type FileAttachmentInsert = Database['public']['Tables']['file_attachments']['Insert'];
   ```

Follow existing patterns in the file for consistency.
  </action>
  <verify>
Run: `npm run type-check` passes.
Import test: `import { FileAttachment } from '@/types/database'` works in other files.
  </verify>
  <done>
FileAttachment type added to database.ts with Row, Insert, Update variants and relationship definitions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   npm run build
   npm run type-check
   ```
   Both should pass without errors.

2. **Import verification:**
   All exports accessible:
   - `import { validateFile, generateStoragePath } from '@/lib/utils/file-validation'`
   - `import { uploadFile, deleteFile, getFilesByEntity } from '@/lib/actions/files'`
   - `import { FileAttachment } from '@/types/database'`

3. **Integration test outline:**
   - Create FormData with test file
   - Call uploadFile with qmrl entity
   - Verify file appears in getFilesByEntity
   - Call deleteFile
   - Verify file no longer in getFilesByEntity (soft deleted)
</verification>

<success_criteria>
- File validation rejects .exe, .bat, files over 25MB
- File validation accepts .pdf, .docx, .jpg, .png under 25MB
- generateStoragePath produces unique paths with entity structure
- uploadFile creates both storage object and metadata record
- deleteFile only soft-deletes (sets deleted_at, does not remove storage)
- getFilesByEntity returns only non-deleted files
- `npm run build` passes without type errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-storage-foundation/02-02-SUMMARY.md`
</output>
