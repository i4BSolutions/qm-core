---
phase: 08-database-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/040_invoice_void_block_stockin.sql
  - supabase/migrations/041_invoice_void_cascade_audit.sql
autonomous: true

must_haves:
  truths:
    - "Invoices with stock-in transactions cannot be voided"
    - "Voiding an invoice logs all cascade effects to audit trail"
    - "Audit trail shows PO status change due to void"
    - "Audit trail shows PO line item invoiced_quantity changes due to void"
  artifacts:
    - path: "supabase/migrations/040_invoice_void_block_stockin.sql"
      provides: "Block invoice void when stock-in exists"
      contains: "RAISE EXCEPTION"
    - path: "supabase/migrations/041_invoice_void_cascade_audit.sql"
      provides: "Comprehensive audit logging for void cascades"
      contains: "audit_invoice_void_cascade"
  key_links:
    - from: "invoices.is_voided UPDATE"
      to: "block_invoice_void_with_stockin()"
      via: "BEFORE UPDATE trigger"
      pattern: "BEFORE UPDATE ON invoices"
    - from: "invoices.is_voided UPDATE"
      to: "audit_invoice_void_cascade()"
      via: "AFTER UPDATE trigger"
      pattern: "AFTER UPDATE ON invoices"
---

<objective>
Implement invoice void cascade controls and comprehensive audit logging.

Purpose: When an invoice is voided, the database must (1) block the void if stock has been received, and (2) log all cascade effects (PO status changes, invoiced quantity changes) to the audit trail. This ensures financial integrity and auditability.

Output: Two migration files implementing void blocking and cascade audit logging.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-database-foundation/08-CONTEXT.md
@.planning/phases/08-database-foundation/08-RESEARCH.md
@supabase/migrations/022_invoice_line_items.sql
@supabase/migrations/026_audit_triggers.sql
@supabase/migrations/025_audit_logs.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Block invoice void when stock-in exists</name>
  <files>supabase/migrations/040_invoice_void_block_stockin.sql</files>
  <action>
Create migration 040_invoice_void_block_stockin.sql that adds a BEFORE UPDATE trigger to block voiding invoices that have associated stock-in transactions.

From CONTEXT.md decisions:
- Invoices with stock-in transactions CANNOT be voided (hard block)
- Block message: "Cannot void: inventory has been received against this invoice"

Implementation:

```sql
-- Function to block void if stock-in exists
CREATE OR REPLACE FUNCTION block_invoice_void_with_stockin()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  stockin_exists BOOLEAN;
BEGIN
  -- Only check when is_voided changes to true
  IF NEW.is_voided = true AND (OLD.is_voided = false OR OLD.is_voided IS NULL) THEN
    -- Check if any stock-in transactions exist for this invoice
    SELECT EXISTS (
      SELECT 1 FROM inventory_transactions
      WHERE invoice_id = NEW.id
        AND movement_type = 'inventory_in'
        AND is_active = true
    ) INTO stockin_exists;

    IF stockin_exists THEN
      RAISE EXCEPTION 'Cannot void: inventory has been received against this invoice';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- Trigger must fire BEFORE the existing recalculate trigger
-- Use 'aa_' prefix to fire first alphabetically
DROP TRIGGER IF EXISTS aa_block_invoice_void_stockin ON invoices;
CREATE TRIGGER aa_block_invoice_void_stockin
  BEFORE UPDATE ON invoices
  FOR EACH ROW
  EXECUTE FUNCTION block_invoice_void_with_stockin();
```

Add an index on inventory_transactions(invoice_id) if not exists for efficient lookup.

Add COMMENT explaining the business rule and trigger ordering.
  </action>
  <verify>
Run `npx supabase db reset`. Then test:
```sql
-- Create test data: invoice with stock-in
-- Then attempt to void it - should fail with exception message
```
Verify trigger exists and is ordered correctly:
```sql
SELECT tgname, tgtype FROM pg_trigger WHERE tgrelid = 'invoices'::regclass ORDER BY tgname;
```
The aa_block_invoice_void_stockin trigger should appear first.
  </verify>
  <done>
- Migration creates block_invoice_void_with_stockin() function
- Trigger fires BEFORE UPDATE with 'aa_' prefix for ordering
- Invoices with stock-in cannot be voided
- Clear error message returned when void is blocked
  </done>
</task>

<task type="auto">
  <name>Task 2: Create invoice void cascade audit trigger</name>
  <files>supabase/migrations/041_invoice_void_cascade_audit.sql</files>
  <action>
Create migration 041_invoice_void_cascade_audit.sql that logs all cascade effects when an invoice is voided.

From CONTEXT.md decisions:
- Single audit entry per void (not separate entries per effect)
- Log includes ALL cascade effects in one record: void action, PO status change, Balance in Hand change
- Both old and new values captured (before/after format)
- Human-readable summary included

The existing audit trigger (create_audit_log) already logs the void action itself. This new trigger logs the CASCADE EFFECTS by querying the affected tables AFTER the cascade triggers have completed.

Implementation approach:
1. Create an AFTER UPDATE trigger that fires LAST (use 'zz_' prefix)
2. Only fire when is_voided changes to true
3. Query affected po_line_items and purchase_orders to capture their new values
4. Log each affected entity separately for full auditability (per research recommendation)

```sql
-- Function to audit invoice void cascade effects
CREATE OR REPLACE FUNCTION audit_invoice_void_cascade()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
  voiding_user_id UUID;
  voiding_user_name TEXT;
  po_line_rec RECORD;
  affected_po_ids UUID[] := ARRAY[]::UUID[];
  po_rec RECORD;
  old_po_status TEXT;
BEGIN
  -- Only act when is_voided changes to true
  IF NEW.is_voided = true AND (OLD.is_voided = false OR OLD.is_voided IS NULL) THEN

    -- Get user who voided the invoice
    voiding_user_id := COALESCE(NEW.voided_by, NEW.updated_by);
    SELECT full_name INTO voiding_user_name
    FROM public.users
    WHERE id = voiding_user_id;
    voiding_user_name := COALESCE(voiding_user_name, 'System');

    -- Log each affected PO line item's invoiced_quantity change
    -- The recalculate_po_on_invoice_void trigger has already updated these
    FOR po_line_rec IN
      SELECT DISTINCT
        pl.id,
        pl.po_id,
        pl.invoiced_quantity as new_invoiced_qty,
        ili.quantity as voided_qty,
        po.po_number
      FROM invoice_line_items ili
      JOIN po_line_items pl ON pl.id = ili.po_line_item_id
      JOIN purchase_orders po ON po.id = pl.po_id
      WHERE ili.invoice_id = NEW.id
        AND ili.is_active = true
    LOOP
      -- Log PO line item change
      INSERT INTO public.audit_logs (
        entity_type, entity_id, action,
        field_name, old_value, new_value,
        changes_summary,
        changed_by, changed_by_name, changed_at
      ) VALUES (
        'po_line_items',
        po_line_rec.id,
        'update',
        'invoiced_quantity',
        (po_line_rec.new_invoiced_qty + po_line_rec.voided_qty)::TEXT,
        po_line_rec.new_invoiced_qty::TEXT,
        'Invoiced quantity decreased from ' ||
          (po_line_rec.new_invoiced_qty + po_line_rec.voided_qty)::TEXT ||
          ' to ' || po_line_rec.new_invoiced_qty::TEXT ||
          ' due to void of invoice ' || NEW.invoice_number,
        voiding_user_id,
        voiding_user_name,
        NOW()
      );

      -- Collect unique PO IDs
      IF NOT po_line_rec.po_id = ANY(affected_po_ids) THEN
        affected_po_ids := array_append(affected_po_ids, po_line_rec.po_id);
      END IF;
    END LOOP;

    -- Log PO status changes
    -- The trigger_update_po_status has already recalculated these
    FOR po_rec IN
      SELECT id, po_number, status
      FROM public.purchase_orders
      WHERE id = ANY(affected_po_ids)
    LOOP
      -- Note: We can't know the old status directly since it was already updated
      -- Log the current (new) status with context
      INSERT INTO public.audit_logs (
        entity_type, entity_id, action,
        field_name, new_value,
        changes_summary,
        changed_by, changed_by_name, changed_at
      ) VALUES (
        'purchase_orders',
        po_rec.id,
        'status_change',
        'status',
        po_rec.status::TEXT,
        'PO ' || po_rec.po_number || ' status recalculated to "' || po_rec.status::TEXT ||
          '" due to void of invoice ' || NEW.invoice_number,
        voiding_user_id,
        voiding_user_name,
        NOW()
      );
    END LOOP;

  END IF;

  RETURN NEW;
END;
$$;

-- Attach trigger - fires AFTER existing triggers complete (zz_ prefix)
DROP TRIGGER IF EXISTS zz_audit_invoice_void_cascade ON invoices;
CREATE TRIGGER zz_audit_invoice_void_cascade
  AFTER UPDATE ON invoices
  FOR EACH ROW
  EXECUTE FUNCTION audit_invoice_void_cascade();
```

Add COMMENT explaining:
- Why AFTER UPDATE (needs to see cascade results)
- Why zz_ prefix (fires last)
- Why SECURITY DEFINER (needs to write to audit_logs)
  </action>
  <verify>
Run `npx supabase db reset`. Then test:
1. Create a PO with line items
2. Create an invoice against the PO (status should change to partially_invoiced)
3. Void the invoice
4. Query audit_logs for the cascade entries:
```sql
SELECT entity_type, action, field_name, old_value, new_value, changes_summary
FROM audit_logs
WHERE changes_summary LIKE '%void%'
ORDER BY changed_at DESC;
```
Should see entries for:
- invoices (void action - from existing trigger)
- po_line_items (invoiced_quantity change)
- purchase_orders (status_change)
  </verify>
  <done>
- Migration creates audit_invoice_void_cascade() function with SECURITY DEFINER + SET search_path
- Trigger fires AFTER UPDATE with 'zz_' prefix for ordering
- PO line item invoiced_quantity changes logged
- PO status changes logged
- All entries link back to the voided invoice number
  </done>
</task>

</tasks>

<verification>
End-to-end void cascade test:

1. Setup test data:
```sql
-- Requires existing PO with line items and invoice
-- (Use UI or direct SQL to create)
```

2. Test void block (when stock-in exists):
```sql
-- Create stock-in from invoice
INSERT INTO inventory_transactions (
  movement_type, item_id, warehouse_id, quantity, invoice_id, ...
) VALUES ('inventory_in', ..., invoice_id, ...);

-- Try to void - should fail
UPDATE invoices SET is_voided = true, void_reason = 'Test' WHERE id = invoice_id;
-- Expected: ERROR: Cannot void: inventory has been received against this invoice
```

3. Test void success (no stock-in):
```sql
-- Delete stock-in for test
DELETE FROM inventory_transactions WHERE invoice_id = invoice_id;

-- Void should succeed
UPDATE invoices SET is_voided = true, void_reason = 'Test', voided_by = user_id WHERE id = invoice_id;

-- Check audit trail
SELECT * FROM audit_logs WHERE entity_id = invoice_id OR changes_summary LIKE '%invoice%' ORDER BY changed_at DESC LIMIT 10;
```

4. Verify VOID requirements:
- VOID-01: PO status recalculated (check purchase_orders.status)
- VOID-02: Balance in Hand automatic (generated column, verify qmhq.balance_in_hand unchanged since PO commitment unchanged)
- VOID-03: Already existed, verify po_line_items.invoiced_quantity decreased
- VOID-04: Audit trail shows all cascade effects
</verification>

<success_criteria>
- [ ] Migration 040 blocks void when stock-in exists with clear error message
- [ ] Migration 041 logs all cascade effects to audit_logs
- [ ] Trigger ordering correct: aa_block first, invoice_void_recalculate second, zz_audit_cascade last
- [ ] PO line item invoiced_quantity changes appear in audit_logs
- [ ] PO status changes appear in audit_logs
- [ ] Human-readable summaries include invoice number reference
- [ ] SECURITY DEFINER function has SET search_path protection
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-foundation/08-02-SUMMARY.md`
</output>
