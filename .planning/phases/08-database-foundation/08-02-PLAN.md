---
phase: 08-database-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/039_invoice_void_cascade_audit.sql
autonomous: true

must_haves:
  truths:
    - "Voiding an invoice creates audit log entry for the void action"
    - "Voiding an invoice creates audit log entries for affected PO line items"
    - "Voiding an invoice creates audit log entry for PO status change"
    - "All cascade audit entries reference the voided invoice"
  artifacts:
    - path: "supabase/migrations/039_invoice_void_cascade_audit.sql"
      provides: "Invoice void cascade audit trigger"
      contains: "audit_invoice_void_cascade"
  key_links:
    - from: "invoices.is_voided"
      to: "audit_logs"
      via: "zz_audit_invoice_void_cascade trigger"
      pattern: "INSERT INTO audit_logs.*entity_type.*invoices"
---

<objective>
Create audit logging trigger for invoice void cascade effects to satisfy VOID-04.

Purpose: When an invoice is voided, users need to see an audit trail showing all affected entities (invoice itself, PO line items invoiced_quantity changes, PO status changes). This provides full traceability for financial auditing.

Output: Migration file with new trigger function that logs cascade effects.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-database-foundation/08-RESEARCH.md

@supabase/migrations/022_invoice_line_items.sql
@supabase/migrations/026_audit_triggers.sql
@supabase/migrations/025_audit_logs.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invoice void cascade audit trigger</name>
  <files>supabase/migrations/039_invoice_void_cascade_audit.sql</files>
  <action>
Create migration file with new trigger function and trigger:

```sql
-- Migration: 039_invoice_void_cascade_audit.sql
-- Description: Audit logging for invoice void cascade effects (VOID-04)

-- Helper function to get user name for audit (if not already exists)
CREATE OR REPLACE FUNCTION get_user_name_for_audit(p_user_id UUID)
RETURNS TEXT AS $$
DECLARE
  user_name TEXT;
BEGIN
  IF p_user_id IS NULL THEN
    RETURN 'System';
  END IF;

  SELECT full_name INTO user_name
  FROM users
  WHERE id = p_user_id;

  RETURN COALESCE(user_name, 'Unknown User');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = pg_catalog, public;

-- Trigger function for invoice void cascade audit
CREATE OR REPLACE FUNCTION audit_invoice_void_cascade()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
  voiding_user_id UUID;
  voiding_user_name TEXT;
  affected_po_line_ids UUID[];
  affected_po_ids UUID[];
  po_line_rec RECORD;
  po_rec RECORD;
  old_invoiced_qty DECIMAL(15,2);
  new_invoiced_qty DECIMAL(15,2);
  old_po_status TEXT;
  new_po_status TEXT;
BEGIN
  -- Only act when is_voided changes to true
  IF NEW.is_voided = true AND (OLD.is_voided = false OR OLD.is_voided IS NULL) THEN

    -- Get user who voided the invoice
    voiding_user_id := COALESCE(NEW.voided_by, NEW.updated_by);
    voiding_user_name := get_user_name_for_audit(voiding_user_id);

    -- Log the void action itself (main invoice void entry)
    INSERT INTO audit_logs (
      entity_type, entity_id, action,
      old_values, new_values,
      changes_summary,
      changed_by, changed_by_name, changed_at
    ) VALUES (
      'invoices', NEW.id, 'void',
      jsonb_build_object(
        'is_voided', OLD.is_voided,
        'invoice_number', OLD.invoice_number,
        'total_amount', OLD.total_amount
      ),
      jsonb_build_object(
        'is_voided', NEW.is_voided,
        'voided_at', NEW.voided_at,
        'void_reason', NEW.void_reason
      ),
      'Invoice ' || NEW.invoice_number || ' voided: ' || COALESCE(NEW.void_reason, 'No reason provided'),
      voiding_user_id, voiding_user_name, NOW()
    );

    -- Get all affected PO line items (before recalculation)
    -- Note: recalculate_po_on_invoice_void runs BEFORE this trigger (alphabetically)
    -- So we need to query current state which is already recalculated
    FOR po_line_rec IN
      SELECT DISTINCT
        pl.id,
        pl.po_id,
        pl.invoiced_quantity as current_invoiced_qty,
        pl.item_name,
        ili.quantity as invoice_line_qty
      FROM invoice_line_items ili
      JOIN po_line_items pl ON pl.id = ili.po_line_item_id
      WHERE ili.invoice_id = NEW.id
        AND ili.is_active = true
    LOOP
      -- Log PO line item invoiced_quantity change
      -- The old quantity was current + invoice_line_qty (since recalculation already happened)
      old_invoiced_qty := po_line_rec.current_invoiced_qty + po_line_rec.invoice_line_qty;
      new_invoiced_qty := po_line_rec.current_invoiced_qty;

      INSERT INTO audit_logs (
        entity_type, entity_id, action,
        field_name, old_value, new_value,
        changes_summary,
        changed_by, changed_by_name, changed_at
      ) VALUES (
        'po_line_items', po_line_rec.id, 'update',
        'invoiced_quantity',
        old_invoiced_qty::TEXT,
        new_invoiced_qty::TEXT,
        'Invoiced quantity reduced from ' || old_invoiced_qty || ' to ' || new_invoiced_qty ||
        ' for item "' || COALESCE(po_line_rec.item_name, 'Unknown') || '" due to invoice ' || NEW.invoice_number || ' void',
        voiding_user_id, voiding_user_name, NOW()
      );

      -- Collect affected PO ID
      IF NOT (po_line_rec.po_id = ANY(COALESCE(affected_po_ids, ARRAY[]::UUID[]))) THEN
        affected_po_ids := array_append(COALESCE(affected_po_ids, ARRAY[]::UUID[]), po_line_rec.po_id);
      END IF;
    END LOOP;

    -- Log PO status changes for affected POs
    -- Note: PO status is recalculated by trigger_update_po_status when invoiced_quantity changes
    FOR po_rec IN
      SELECT id, po_number, status
      FROM purchase_orders
      WHERE id = ANY(COALESCE(affected_po_ids, ARRAY[]::UUID[]))
    LOOP
      -- Note: We can't know the old status here since the cascade already happened
      -- Log the current (new) status with context that it was recalculated
      INSERT INTO audit_logs (
        entity_type, entity_id, action,
        field_name, new_value,
        changes_summary,
        changed_by, changed_by_name, changed_at
      ) VALUES (
        'purchase_orders', po_rec.id, 'status_change',
        'status',
        po_rec.status::TEXT,
        'PO ' || po_rec.po_number || ' status recalculated to "' || po_rec.status || '" due to invoice ' || NEW.invoice_number || ' void',
        voiding_user_id, voiding_user_name, NOW()
      );
    END LOOP;

  END IF;

  RETURN NEW;
END;
$$;

-- Attach trigger (fires AFTER existing triggers due to 'zz_' prefix)
-- Alphabetical ordering: invoice_void_recalculate (BEFORE) runs first,
-- then audit_invoices (AFTER) runs, then this trigger (AFTER with zz_ prefix)
DROP TRIGGER IF EXISTS zz_audit_invoice_void_cascade ON invoices;
CREATE TRIGGER zz_audit_invoice_void_cascade
  AFTER UPDATE ON invoices
  FOR EACH ROW
  EXECUTE FUNCTION audit_invoice_void_cascade();

-- Comments
COMMENT ON FUNCTION audit_invoice_void_cascade() IS
  'Creates detailed audit trail when invoice is voided, logging the void action and all cascade effects (PO line item quantity changes, PO status recalculations)';
COMMENT ON TRIGGER zz_audit_invoice_void_cascade ON invoices IS
  'Fires after invoice void to log cascade effects. Prefixed with zz_ to ensure it runs after other triggers.';
```

Key design decisions:
- Uses AFTER UPDATE to capture state after other triggers have run
- Prefixed with 'zz_' to ensure alphabetical ordering puts it last
- Uses SECURITY DEFINER with SET search_path for security
- Logs invoice void, PO line item changes, and PO status changes
- References invoice number in all summary texts for traceability
  </action>
  <verify>
Run `npx supabase db reset` to apply migrations.
Check migration applies without errors.
Verify trigger exists: `SELECT * FROM pg_trigger WHERE tgname = 'zz_audit_invoice_void_cascade';`
Verify function exists: `SELECT * FROM pg_proc WHERE proname = 'audit_invoice_void_cascade';`
  </verify>
  <done>
Migration 039 exists with audit_invoice_void_cascade trigger function that logs invoice void, PO line item changes, and PO status changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify invoice void cascade end-to-end</name>
  <files>supabase/migrations/039_invoice_void_cascade_audit.sql</files>
  <action>
Create a test scenario to verify the complete void cascade works:

1. Find an existing invoice to void (or note that a test invoice would be needed):
```sql
-- Check for existing invoices that can be voided
SELECT i.id, i.invoice_number, i.is_voided, i.total_amount,
       COUNT(ili.id) as line_items
FROM invoices i
LEFT JOIN invoice_line_items ili ON ili.invoice_id = i.id
WHERE i.is_voided = false
GROUP BY i.id, i.invoice_number, i.is_voided, i.total_amount
LIMIT 5;
```

2. If test data exists, void an invoice and verify cascade:
```sql
-- Void the invoice (replace with actual ID)
UPDATE invoices
SET is_voided = true,
    void_reason = 'Test void for cascade verification',
    voided_by = (SELECT id FROM users LIMIT 1),
    updated_by = (SELECT id FROM users LIMIT 1)
WHERE id = 'INVOICE_ID_HERE';
```

3. Verify audit logs were created:
```sql
-- Check for audit entries
SELECT entity_type, entity_id, action, changes_summary, changed_at
FROM audit_logs
WHERE changes_summary LIKE '%void%'
ORDER BY changed_at DESC
LIMIT 10;
```

4. Verify PO status was recalculated:
```sql
-- Check PO status for affected POs
SELECT po.id, po.po_number, po.status
FROM purchase_orders po
JOIN po_line_items pli ON pli.po_id = po.id
JOIN invoice_line_items ili ON ili.po_line_item_id = pli.id
JOIN invoices i ON i.id = ili.invoice_id
WHERE i.invoice_number = 'INVOICE_NUMBER_HERE';
```

5. Verify invoiced_quantity was reduced:
```sql
-- Check PO line item invoiced quantities
SELECT pli.id, pli.item_name, pli.quantity, pli.invoiced_quantity
FROM po_line_items pli
JOIN invoice_line_items ili ON ili.po_line_item_id = pli.id
JOIN invoices i ON i.id = ili.invoice_id
WHERE i.invoice_number = 'INVOICE_NUMBER_HERE';
```

Document the verification results. If no test data exists, note that the trigger is ready for integration testing when Phase 12 (Invoice Void Cascade UI) is implemented.
  </action>
  <verify>
Trigger function exists and compiles.
If test data available: void operation creates audit entries for invoice, PO line items, and PO status.
If no test data: Document that trigger is ready for integration testing.
  </verify>
  <done>
Invoice void cascade creates audit trail entries for:
- Invoice void action
- PO line item invoiced_quantity changes
- PO status recalculations
  </done>
</task>

</tasks>

<verification>
- Migration 039 applies cleanly via `npx supabase db reset`
- Trigger zz_audit_invoice_void_cascade exists on invoices table
- Function audit_invoice_void_cascade exists with SECURITY DEFINER and SET search_path
- Voiding an invoice creates multiple audit_logs entries (invoice, PO line items, PO status)
</verification>

<success_criteria>
1. Voiding an invoice creates audit log for the void action itself
2. Voiding an invoice creates audit logs for each affected PO line item's invoiced_quantity change
3. Voiding an invoice creates audit log for each affected PO's status recalculation
4. All audit entries include reference to the voided invoice number in changes_summary
5. Audit entries have correct changed_by from voided_by field
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-foundation/08-02-SUMMARY.md`
</output>
