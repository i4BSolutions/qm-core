---
phase: 62-frontend-permission-enforcement
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/supabase/middleware.ts
  - app/(dashboard)/qmhq/layout.tsx
  - app/(dashboard)/admin/flow-tracking/layout.tsx
  - app/(dashboard)/dashboard/page.tsx
  - components/layout/header.tsx
  - lib/hooks/use-permissions.ts
autonomous: true
requirements: [PERM-05, PERM-06]

must_haves:
  truths:
    - "Sidebar hides resources where user has Block permission (already implemented in Phase 61 — must remain working)"
    - "Navigating directly to a blocked resource URL redirects the user to /dashboard"
    - "Middleware enforces permission-based route blocking without role column"
    - "Header displays the user's highest access level label instead of a placeholder"
  artifacts:
    - path: "lib/supabase/middleware.ts"
      provides: "Permission-based route blocking via user_permissions table"
      contains: "user_permissions"
    - path: "app/(dashboard)/qmhq/layout.tsx"
      provides: "Server-side permission guard for QMHQ pages"
      contains: "has_permission"
    - path: "app/(dashboard)/admin/flow-tracking/layout.tsx"
      provides: "Server-side permission guard for admin pages"
      contains: "has_permission"
    - path: "components/layout/header.tsx"
      provides: "Permission-based role label in user dropdown"
    - path: "lib/hooks/use-permissions.ts"
      provides: "Route-to-resource mapping utility for client-side redirect guards"
  key_links:
    - from: "lib/supabase/middleware.ts"
      to: "user_permissions table"
      via: "Supabase query in middleware"
      pattern: "from.*user_permissions"
    - from: "app/(dashboard)/qmhq/layout.tsx"
      to: "has_permission SQL function"
      via: "RPC call in server component"
      pattern: "rpc.*has_permission|from.*user_permissions"
---

<objective>
Wire permission-based route guards at the middleware and layout levels so blocked users are redirected away from resources they cannot access.

Purpose: PERM-05 (sidebar hiding) is already done. This plan completes PERM-06 (page redirects) by replacing the commented-out role-based guards in middleware.ts, layout.tsx files, and dashboard/page.tsx with permission-matrix lookups. Also fixes the header's placeholder role label.

Output: Middleware and layout guards redirect blocked users; header shows access level label.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-permission-management-ui/61-01-SUMMARY.md
@.planning/phases/60-rls-policy-rewrite/60-01-SUMMARY.md
@lib/hooks/use-permissions.ts
@lib/supabase/middleware.ts
@components/layout/sidebar.tsx
@components/layout/header.tsx
@components/providers/auth-provider.tsx
@types/database.ts (lines 2421-2515 for PermissionResource type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Middleware permission-based route blocking and layout guards</name>
  <files>
    lib/supabase/middleware.ts
    app/(dashboard)/qmhq/layout.tsx
    app/(dashboard)/admin/flow-tracking/layout.tsx
    app/(dashboard)/dashboard/page.tsx
  </files>
  <action>
Replace the commented-out role-based route blocking in middleware.ts with permission-matrix lookups.

**middleware.ts changes:**

1. Remove the `ROLE_BLOCKED_ROUTES` constant entirely (dead code since Phase 60).

2. After the `is_active` check (line 68-75), add a permission-based route check:
   - Define a `ROUTE_RESOURCE_MAP` that maps URL path prefixes to `PermissionResource` values:
     ```
     /dashboard -> system_dashboard
     /qmrl -> qmrl
     /qmhq -> qmhq
     /po -> po
     /invoice -> invoice
     /inventory/stock-in -> stock_in
     /inventory/stock-out-requests -> sor
     /inventory/stock-out -> sor  (execution queue)
     /inventory -> inventory_dashboard
     /warehouse -> warehouse
     /item -> item
     /admin -> admin
     ```
   - Query `user_permissions` for the current user: `supabase.from("user_permissions").select("resource, level").eq("user_id", user.id)`
   - Build a `Map<string, string>` from resource to level.
   - Check the request pathname against `ROUTE_RESOURCE_MAP` (longest prefix match first — check `/inventory/stock-in` before `/inventory`).
   - If the matched resource has level `'block'` (or no row found, which means block by fail-closed design), redirect to `/dashboard`.
   - If redirecting to `/dashboard` but dashboard itself is blocked, redirect to `/qmrl` as fallback.
   - Skip permission check for the root path `/` (it redirects to dashboard anyway).

3. Remove the commented-out role-based block (lines 77-90) and the `TODO Phase 62` comment.

**layout.tsx changes (qmhq/layout.tsx):**

Replace the commented-out role guard with a permission-based check using the Supabase server client:
```typescript
const { data: perm } = await supabase
  .from("user_permissions")
  .select("level")
  .eq("user_id", user.id)
  .eq("resource", "qmhq")
  .single();

if (!perm || perm.level === "block") {
  redirect("/dashboard");
}
```
Remove the TODO Phase 62 comments and the commented-out old code.

**layout.tsx changes (admin/flow-tracking/layout.tsx):**

Same pattern but check for `admin` resource with `edit` level:
```typescript
const { data: perm } = await supabase
  .from("user_permissions")
  .select("level")
  .eq("user_id", user.id)
  .eq("resource", "admin")
  .single();

if (!perm || perm.level !== "edit") {
  redirect("/dashboard");
}
```
Remove the TODO Phase 62 comments and the commented-out old code.

**dashboard/page.tsx changes:**

The dashboard page has a TODO Phase 62 for role-based redirect. Replace with permission check:
```typescript
const { data: perm } = await supabase
  .from("user_permissions")
  .select("level")
  .eq("user_id", user.id)
  .eq("resource", "system_dashboard")
  .single();

if (!perm || perm.level === "block") {
  redirect("/qmrl");
}
```
Remove the TODO Phase 62 comment. Keep the existing profile fetch for `full_name` (needed for greeting).
  </action>
  <verify>
1. `npm run type-check` passes
2. `npm run build` passes
3. Grep for `ROLE_BLOCKED_ROUTES` returns zero results
4. Grep for `TODO Phase 62` in modified files returns zero results
  </verify>
  <done>
Middleware blocks navigation to resources where the user has Block permission. Layout guards redirect blocked users from QMHQ and admin pages. Dashboard redirects blocked users to /qmrl. No role-based route guards remain in middleware or layouts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Header role label and route-to-resource mapping utility</name>
  <files>
    components/layout/header.tsx
    lib/hooks/use-permissions.ts
  </files>
  <action>
**header.tsx changes:**

1. Import `useResourcePermissions` from `@/lib/hooks/use-permissions`.

2. In the Header component, call `const { isAdmin, canEdit } = useResourcePermissions();`.

3. Replace the two `{/* TODO Phase 62: display permission-based role label */}` placeholders with a computed label:
   - If `isAdmin` (has edit on admin resource): display `"Administrator"`
   - Else: display `"Operator"` (all non-admin users are operators)

4. Replace the hardcoded `"Not signed in"` with this label (only show when user is truthy).

5. Replace the hardcoded `"—"` in the dropdown role badge with this same label.

6. Remove the TODO Phase 62 comments.

**lib/hooks/use-permissions.ts changes:**

Add a `ROUTE_RESOURCE_MAP` export that maps URL path prefixes to `PermissionResource` values. This will be used by Plan 02 for client-side page guard components:

```typescript
/**
 * Maps URL path prefixes to their controlling PermissionResource.
 * Ordered by specificity (longest prefix first) for correct matching.
 * Used by middleware (server) and page guards (client).
 */
export const ROUTE_RESOURCE_MAP: { prefix: string; resource: DbPermissionResource }[] = [
  { prefix: '/inventory/stock-in', resource: 'stock_in' },
  { prefix: '/inventory/stock-out-requests', resource: 'sor' },
  { prefix: '/inventory/stock-out', resource: 'sor' },
  { prefix: '/inventory', resource: 'inventory_dashboard' },
  { prefix: '/dashboard', resource: 'system_dashboard' },
  { prefix: '/qmrl', resource: 'qmrl' },
  { prefix: '/qmhq', resource: 'qmhq' },
  { prefix: '/po', resource: 'po' },
  { prefix: '/invoice', resource: 'invoice' },
  { prefix: '/warehouse', resource: 'warehouse' },
  { prefix: '/item', resource: 'item' },
  { prefix: '/admin', resource: 'admin' },
];

/**
 * Find the permission resource controlling a given URL path.
 * Returns undefined if no route matches (unprotected page).
 */
export function getResourceForRoute(pathname: string): DbPermissionResource | undefined {
  const match = ROUTE_RESOURCE_MAP.find(
    (entry) => pathname === entry.prefix || pathname.startsWith(entry.prefix + '/')
  );
  return match?.resource;
}
```
  </action>
  <verify>
1. `npm run type-check` passes
2. `npm run build` passes
3. Grep for `TODO Phase 62` in header.tsx returns zero results
4. Grep for `"Not signed in"` in header.tsx returns zero results (replaced with dynamic label)
  </verify>
  <done>
Header displays "Administrator" for admin users and "Operator" for others. A reusable ROUTE_RESOURCE_MAP and getResourceForRoute() utility is exported for use by page-level guards and Plan 02.
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` — zero TypeScript errors
2. `npm run build` — clean build
3. Grep for `ROLE_BLOCKED_ROUTES` across codebase — zero results
4. Grep for `TODO Phase 62` in all modified files — zero results
5. `ROUTE_RESOURCE_MAP` exported from `lib/hooks/use-permissions.ts`
6. Middleware queries `user_permissions` and redirects blocked users
7. Layout guards use `user_permissions` table instead of role column
</verification>

<success_criteria>
- Navigating to /qmhq when user has Block on qmhq redirects to /dashboard
- Navigating to /admin/* when user lacks Edit on admin redirects to /dashboard
- Navigating to /dashboard when user has Block on system_dashboard redirects to /qmrl
- Header shows "Administrator" or "Operator" based on permission level
- Sidebar filtering (Phase 61) continues to work unchanged
- Build and type-check pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/62-frontend-permission-enforcement/62-01-SUMMARY.md`
</output>
