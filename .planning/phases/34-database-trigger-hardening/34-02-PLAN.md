---
phase: 34-database-trigger-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/061_auto_populate_qmhq_link.sql
  - supabase/migrations/062_idempotency_constraint_execution.sql
autonomous: true

must_haves:
  truths:
    - "QMHQ link auto-populates from SOR chain when inventory_out transaction is created with stock_out_approval_id"
    - "Cannot execute the same approval twice (duplicate completed transactions for same approval are blocked)"
    - "Manual stock-outs without approval_id are unaffected by the idempotency constraint"
    - "Auto-population does not override explicitly set qmhq_id"
  artifacts:
    - path: "supabase/migrations/061_auto_populate_qmhq_link.sql"
      provides: "BEFORE INSERT trigger for QMHQ auto-population"
      contains: "auto_populate_qmhq_from_sor"
    - path: "supabase/migrations/062_idempotency_constraint_execution.sql"
      provides: "Partial unique index for idempotent execution"
      contains: "idx_unique_approval_execution"
  key_links:
    - from: "supabase/migrations/061_auto_populate_qmhq_link.sql"
      to: "inventory_transactions"
      via: "BEFORE INSERT trigger"
      pattern: "trg_auto_populate_qmhq_from_sor"
    - from: "supabase/migrations/061_auto_populate_qmhq_link.sql"
      to: "stock_out_requests.qmhq_id"
      via: "JOIN chain: approvals -> line_items -> requests"
      pattern: "JOIN stock_out_line_items.*JOIN stock_out_requests"
    - from: "supabase/migrations/062_idempotency_constraint_execution.sql"
      to: "inventory_transactions"
      via: "Partial unique index"
      pattern: "CREATE UNIQUE INDEX.*stock_out_approval_id.*WHERE.*completed.*is_active"
---

<objective>
Add QMHQ auto-population trigger and idempotency constraint to inventory_transactions: the trigger auto-fills qmhq_id from the SOR chain when a stock-out approval is executed, and the unique index prevents the same approval from being executed twice.

Purpose: Prevent orphaned transactions (missing QMHQ link) and duplicate execution of the same approval during per-line-item execution.
Output: Two SQL migration files adding new database artifacts.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key existing code to reference:
@supabase/migrations/023_inventory_transactions.sql — inventory_transactions table schema (has qmhq_id FK and stock_out_approval_id FK)
@supabase/migrations/052_stock_out_requests.sql — SOR tables: stock_out_requests (has qmhq_id), stock_out_line_items, stock_out_approvals
@supabase/migrations/053_stock_out_validation.sql — Existing fulfillment triggers and approval linkage
@.planning/phases/34-database-trigger-hardening/34-RESEARCH.md — Full research with verified patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QMHQ auto-population trigger for SOR-linked transactions</name>
  <files>supabase/migrations/061_auto_populate_qmhq_link.sql</files>
  <action>
Create migration `061_auto_populate_qmhq_link.sql` with a BEFORE INSERT trigger on inventory_transactions that auto-populates qmhq_id from the SOR chain.

**Function: `auto_populate_qmhq_from_sor()`**

Guard clauses (return NEW early):
1. `IF NEW.movement_type != 'inventory_out' THEN RETURN NEW;` — only for stock-outs
2. `IF NEW.stock_out_approval_id IS NULL THEN RETURN NEW;` — only for SOR-linked transactions
3. `IF NEW.qmhq_id IS NOT NULL THEN RETURN NEW;` — don't override if explicitly set

Main logic:
```sql
-- Look up QMHQ from approval -> line item -> request
SELECT r.qmhq_id INTO sor_qmhq_id
FROM stock_out_approvals a
JOIN stock_out_line_items li ON a.line_item_id = li.id
JOIN stock_out_requests r ON li.request_id = r.id
WHERE a.id = NEW.stock_out_approval_id;

-- Auto-populate (may be NULL if SOR not linked to QMHQ — that's OK)
NEW.qmhq_id := sor_qmhq_id;
```

**Trigger definition:**
```sql
DROP TRIGGER IF EXISTS trg_auto_populate_qmhq_from_sor ON inventory_transactions;
CREATE TRIGGER trg_auto_populate_qmhq_from_sor
  BEFORE INSERT ON inventory_transactions
  FOR EACH ROW
  EXECUTE FUNCTION auto_populate_qmhq_from_sor();
```

**Also: Backfill existing transactions** that have stock_out_approval_id but missing qmhq_id:
```sql
UPDATE inventory_transactions it
SET qmhq_id = r.qmhq_id
FROM stock_out_approvals a
JOIN stock_out_line_items li ON a.line_item_id = li.id
JOIN stock_out_requests r ON li.request_id = r.id
WHERE it.stock_out_approval_id = a.id
  AND it.movement_type = 'inventory_out'
  AND it.qmhq_id IS NULL
  AND r.qmhq_id IS NOT NULL;
```

Add migration header comment and COMMENT ON FUNCTION explaining the auto-population purpose.
  </action>
  <verify>
Run `npx supabase db reset` from project root. Verify no SQL errors. Check trigger exists:
```bash
grep "trg_auto_populate_qmhq_from_sor" supabase/migrations/061_auto_populate_qmhq_link.sql
```
Check function has the 3-table JOIN chain:
```bash
grep -c "JOIN" supabase/migrations/061_auto_populate_qmhq_link.sql
```
Should return at least 2 (the approval->line_item->request joins).
  </verify>
  <done>
BEFORE INSERT trigger `trg_auto_populate_qmhq_from_sor` exists on inventory_transactions. When a stock-out transaction is created with a stock_out_approval_id, qmhq_id is auto-populated from the SOR chain (approval -> line item -> request -> qmhq_id). Existing orphaned transactions are backfilled. Explicitly set qmhq_id is not overridden.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create idempotency constraint preventing duplicate approval execution</name>
  <files>supabase/migrations/062_idempotency_constraint_execution.sql</files>
  <action>
Create migration `062_idempotency_constraint_execution.sql` with a partial unique index that prevents the same approval from being executed more than once.

**Partial unique index:**
```sql
CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_approval_execution
  ON inventory_transactions(stock_out_approval_id)
  WHERE movement_type = 'inventory_out'
    AND status = 'completed'
    AND is_active = true;
```

This enforces: for any given `stock_out_approval_id`, at most ONE row can exist with `movement_type = 'inventory_out'`, `status = 'completed'`, AND `is_active = true`.

**Why partial unique index:**
- NULL values for `stock_out_approval_id` are ignored (PostgreSQL standard: NULL != NULL), so manual stock-outs are unaffected
- Cancelled/pending transactions don't count — only completed ones enforce uniqueness
- Soft-deleted transactions (is_active = false) don't count — allows re-execution after correction

**Before adding the index, check for and clean existing duplicates:**
```sql
-- Identify duplicates (if any)
-- Mark older duplicates as inactive, keeping only the most recent
WITH duplicates AS (
  SELECT id,
    ROW_NUMBER() OVER (
      PARTITION BY stock_out_approval_id
      ORDER BY created_at DESC
    ) as rn
  FROM inventory_transactions
  WHERE stock_out_approval_id IS NOT NULL
    AND movement_type = 'inventory_out'
    AND status = 'completed'
    AND is_active = true
)
UPDATE inventory_transactions
SET is_active = false,
    notes = COALESCE(notes || ' | ', '') || 'Auto-deactivated: duplicate execution (Phase 34 data migration)'
WHERE id IN (SELECT id FROM duplicates WHERE rn > 1);
```

Add migration header comment and COMMENT ON INDEX explaining the idempotency purpose.
  </action>
  <verify>
Run `npx supabase db reset` from project root. Verify no SQL errors. Check index exists:
```bash
grep "idx_unique_approval_execution" supabase/migrations/062_idempotency_constraint_execution.sql
```
Verify it's a partial unique index:
```bash
grep -c "WHERE" supabase/migrations/062_idempotency_constraint_execution.sql
```
Should return at least 2 (one for the duplicate cleanup CTE, one for the unique index).
  </verify>
  <done>
Partial unique index `idx_unique_approval_execution` exists on inventory_transactions, preventing duplicate completed executions for the same stock_out_approval_id. Manual stock-outs (NULL approval_id) are unaffected. Pre-existing duplicates are cleaned up. Index applies cleanly.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx supabase db reset` runs without errors (both migrations apply cleanly)
2. Function `auto_populate_qmhq_from_sor()` exists and fires BEFORE INSERT on inventory_transactions
3. The function follows the JOIN chain: stock_out_approvals -> stock_out_line_items -> stock_out_requests to get qmhq_id
4. Index `idx_unique_approval_execution` exists as a partial unique index on `stock_out_approval_id`
5. The index WHERE clause filters for `movement_type = 'inventory_out' AND status = 'completed' AND is_active = true`
6. Backfill query populates qmhq_id for existing SOR-linked transactions
</verification>

<success_criteria>
- QMHQ link auto-populates from SOR chain during transaction creation (SC4)
- Cannot execute the same approval twice — unique index prevents duplicates (SC5)
- Manual stock-outs and non-completed transactions are unaffected by constraints
- Existing data is cleaned up/backfilled before constraints are applied
</success_criteria>

<output>
After completion, create `.planning/phases/34-database-trigger-hardening/34-02-SUMMARY.md`
</output>
