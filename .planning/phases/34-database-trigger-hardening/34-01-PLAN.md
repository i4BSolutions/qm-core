---
phase: 34-database-trigger-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/058_advisory_lock_stock_validation.sql
  - supabase/migrations/059_row_lock_status_aggregation.sql
  - supabase/migrations/060_require_approval_id_for_request.sql
autonomous: true

must_haves:
  truths:
    - "Concurrent stock-out executions for the same item cannot create negative stock"
    - "Concurrent line item status changes produce correct parent request status aggregation"
    - "Over-execution of the same approval is blocked even under concurrent transactions"
    - "Request-based stock-outs (reason='request') always have a stock_out_approval_id"
  artifacts:
    - path: "supabase/migrations/058_advisory_lock_stock_validation.sql"
      provides: "Advisory locks on validate_stock_out_quantity() and validate_sor_fulfillment()"
      contains: "pg_advisory_xact_lock"
    - path: "supabase/migrations/059_row_lock_status_aggregation.sql"
      provides: "Row-level locking in compute_sor_request_status()"
      contains: "FOR UPDATE"
    - path: "supabase/migrations/060_require_approval_id_for_request.sql"
      provides: "CHECK constraint and data migration for approval_id requirement"
      contains: "check_approval_id_for_request"
  key_links:
    - from: "supabase/migrations/058_advisory_lock_stock_validation.sql"
      to: "validate_stock_out_quantity()"
      via: "CREATE OR REPLACE FUNCTION"
      pattern: "pg_advisory_xact_lock.*hashtext.*item_id"
    - from: "supabase/migrations/058_advisory_lock_stock_validation.sql"
      to: "validate_sor_fulfillment()"
      via: "CREATE OR REPLACE FUNCTION"
      pattern: "pg_advisory_xact_lock.*hashtext.*stock_out_approval_id"
    - from: "supabase/migrations/059_row_lock_status_aggregation.sql"
      to: "compute_sor_request_status()"
      via: "CREATE OR REPLACE FUNCTION"
      pattern: "SELECT.*FROM stock_out_requests.*FOR UPDATE"
---

<objective>
Add concurrency controls to existing database triggers: advisory locks for stock validation and fulfillment validation, row-level locking for status aggregation, and a CHECK constraint requiring approval_id on request-based stock-outs.

Purpose: Prevent race conditions (negative stock, stale status reads, over-execution) and orphaned request-based transactions during concurrent per-line-item execution.
Output: Three SQL migration files that harden existing triggers for concurrent safety.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key existing code to reference:
@supabase/migrations/024_inventory_wac_trigger.sql — Contains current validate_stock_out_quantity() (lines 282-313) and get_warehouse_stock() (lines 261-279)
@supabase/migrations/052_stock_out_requests.sql — Contains current compute_sor_request_status() (lines 271-340)
@supabase/migrations/053_stock_out_validation.sql — Contains current validate_sor_fulfillment() (lines 248-302)
@supabase/migrations/023_inventory_transactions.sql — inventory_transactions table schema (has stock_out_approval_id added by 053)
@.planning/phases/34-database-trigger-hardening/34-RESEARCH.md — Full research with verified patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add advisory locks to stock validation and fulfillment triggers</name>
  <files>supabase/migrations/058_advisory_lock_stock_validation.sql</files>
  <action>
Create migration `058_advisory_lock_stock_validation.sql` that replaces two existing functions with advisory-lock-hardened versions:

**1. Replace `validate_stock_out_quantity()`** (originally in 024):
- Add `lock_key BIGINT` to DECLARE block
- After the `IF NEW.status != 'completed'` guard, add:
  ```sql
  lock_key := hashtext(NEW.item_id::text);
  PERFORM pg_advisory_xact_lock(lock_key);
  ```
- Keep ALL existing logic unchanged (movement_type check, status check, get_warehouse_stock call, UPDATE old quantity add-back, quantity validation)
- Lock serializes concurrent stock-out validation for the same item
- Lock auto-releases on COMMIT/ROLLBACK

**2. Replace `validate_sor_fulfillment()`** (originally in 053):
- Add `lock_key BIGINT` to DECLARE block
- After the `IF NEW.stock_out_approval_id IS NULL` guard, add:
  ```sql
  lock_key := hashtext(NEW.stock_out_approval_id::text);
  PERFORM pg_advisory_xact_lock(lock_key);
  ```
- Keep ALL existing logic unchanged (approval lookup, decision check, total_executed sum, over-execution check)
- Lock serializes concurrent execution validation for the same approval

Both functions use `hashtext(uuid::text)` for collision-resistant lock key generation. Do NOT change trigger definitions (they already exist on inventory_transactions). Only replace the function bodies.

Add migration header comment explaining this is Phase 34 hardening. Add COMMENT ON FUNCTION for both functions documenting the advisory lock purpose.
  </action>
  <verify>
Run `npx supabase db reset` from project root. Verify no SQL errors. Check that both functions exist with advisory lock calls:
```bash
grep -c "pg_advisory_xact_lock" supabase/migrations/058_advisory_lock_stock_validation.sql
```
Should return 2 (one per function).
  </verify>
  <done>
Both `validate_stock_out_quantity()` and `validate_sor_fulfillment()` contain `pg_advisory_xact_lock(hashtext(...))` calls that serialize concurrent access. All existing validation logic is preserved. Migration applies cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add row-level locking to status aggregation and CHECK constraint for approval requirement</name>
  <files>supabase/migrations/059_row_lock_status_aggregation.sql, supabase/migrations/060_require_approval_id_for_request.sql</files>
  <action>
**Migration 059: Row-level locking for status aggregation**

Create `059_row_lock_status_aggregation.sql` that replaces `compute_sor_request_status()` (originally in 052):
- Add `parent_request_record RECORD` to DECLARE block
- After determining `parent_request_id` (the existing IF/ELSIF block), add row lock BEFORE the COUNT aggregation:
  ```sql
  -- Lock parent request row to prevent concurrent status updates
  SELECT * INTO parent_request_record
  FROM stock_out_requests
  WHERE id = parent_request_id
  FOR UPDATE;
  ```
- Keep ALL existing status computation logic unchanged (COUNT with FILTER, status priority chain, UPDATE with IS DISTINCT FROM)
- The FOR UPDATE lock ensures only one trigger at a time reads child line item statuses for a given parent request
- Lock ordering: line item (already locked by trigger context) -> parent request (acquired here) — this prevents deadlocks per research Pitfall 2

Add migration header comment and COMMENT ON FUNCTION.

**Migration 060: CHECK constraint for approval_id on request-based stock-outs**

Create `060_require_approval_id_for_request.sql` with TWO steps:

Step 1 — Data migration (fix any orphaned transactions BEFORE adding constraint):
```sql
-- Fix orphaned transactions: inventory_out with reason='request' but no approval_id
-- Change reason to 'adjustment' so they bypass the new constraint
UPDATE inventory_transactions
SET reason = 'adjustment',
    notes = COALESCE(notes || ' | ', '') || 'Auto-fixed: was reason=request without approval_id (Phase 34 data migration)'
WHERE movement_type = 'inventory_out'
  AND reason = 'request'
  AND stock_out_approval_id IS NULL
  AND is_active = true;
```

Step 2 — Add CHECK constraint:
```sql
ALTER TABLE inventory_transactions
  ADD CONSTRAINT check_approval_id_for_request
  CHECK (
    movement_type != 'inventory_out'
    OR reason != 'request'
    OR stock_out_approval_id IS NOT NULL
  );
```

Add COMMENT ON CONSTRAINT explaining it ensures request-based stock-outs always link to an approval.

This is critical: the data migration MUST run before the constraint. Put both in the same migration file to ensure atomicity.
  </action>
  <verify>
Run `npx supabase db reset` from project root. Verify no SQL errors. Verify constraint exists:
```bash
grep "check_approval_id_for_request" supabase/migrations/060_require_approval_id_for_request.sql
```
Verify row lock exists:
```bash
grep "FOR UPDATE" supabase/migrations/059_row_lock_status_aggregation.sql
```
  </verify>
  <done>
`compute_sor_request_status()` acquires `SELECT FOR UPDATE` on parent request before aggregating child statuses. CHECK constraint `check_approval_id_for_request` prevents creating inventory_out with reason='request' without a stock_out_approval_id. Data migration handles any pre-existing orphaned records. All three migrations apply cleanly in sequence.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx supabase db reset` runs without errors (all 3 migrations apply cleanly)
2. `validate_stock_out_quantity()` contains `pg_advisory_xact_lock(hashtext(NEW.item_id::text))`
3. `validate_sor_fulfillment()` contains `pg_advisory_xact_lock(hashtext(NEW.stock_out_approval_id::text))`
4. `compute_sor_request_status()` contains `SELECT * INTO parent_request_record FROM stock_out_requests WHERE id = parent_request_id FOR UPDATE`
5. `check_approval_id_for_request` constraint exists on `inventory_transactions`
6. No orphaned inventory_out records with reason='request' and NULL stock_out_approval_id remain
</verification>

<success_criteria>
- Advisory locks serialize concurrent stock validation (SC1) and over-execution checks (SC1 supplement)
- Row-level locking prevents stale reads in parent status aggregation (SC2)
- CHECK constraint enforces approval_id requirement for request-based stock-outs (SC3)
- All existing trigger behavior is preserved — only concurrency controls added
</success_criteria>

<output>
After completion, create `.planning/phases/34-database-trigger-hardening/34-01-SUMMARY.md`
</output>
