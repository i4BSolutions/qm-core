---
phase: 29-deletion-protection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/057_deletion_protection.sql
autonomous: true

must_haves:
  truths:
    - "Item deactivation is blocked when referenced by active QMHQ, PO line items, inventory transactions, or stock-out line items"
    - "Status deactivation is blocked when assigned to any active QMRL or QMHQ"
    - "Category deactivation is blocked when assigned to any active QMRL, QMHQ, or item"
    - "Department deactivation is blocked when assigned to any active user, QMRL, or contact person"
    - "Contact person deactivation is blocked when referenced by any active QMRL or QMHQ"
    - "Supplier deactivation is blocked when referenced by any active PO"
  artifacts:
    - path: "supabase/migrations/057_deletion_protection.sql"
      provides: "All deletion protection triggers for 6 entity types"
      contains: "block_item_deactivation"
  key_links:
    - from: "supabase/migrations/057_deletion_protection.sql"
      to: "items table"
      via: "BEFORE UPDATE trigger on is_active change"
      pattern: "WHEN \\(OLD\\.is_active = true AND NEW\\.is_active = false\\)"
    - from: "supabase/migrations/057_deletion_protection.sql"
      to: "status_config table"
      via: "BEFORE UPDATE trigger on is_active change"
      pattern: "block_status_deactivation"
---

<objective>
Create database triggers that prevent deactivation of master data entities when they are actively referenced by other records.

Purpose: Protect referential integrity by blocking soft-delete (is_active = false) when active references exist, satisfying DPRT-01 through DPRT-06.
Output: Single migration file with 6 trigger functions and 6 BEFORE UPDATE triggers.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-deletion-protection/29-RESEARCH.md

Reference existing trigger pattern:
@supabase/migrations/040_invoice_void_block_stockin.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deletion protection migration with all 6 entity triggers</name>
  <files>supabase/migrations/057_deletion_protection.sql</files>
  <action>
Create a single migration file with 6 BEFORE UPDATE trigger functions and their corresponding triggers. Each trigger fires ONLY when `OLD.is_active = true AND NEW.is_active = false` (using WHEN clause for efficiency). Each function uses `SELECT EXISTS(... LIMIT 1)` pattern for early exit.

Follow the existing pattern from `040_invoice_void_block_stockin.sql` exactly (function naming, RAISE EXCEPTION style, trigger naming with `aa_` prefix for ordering before audit triggers).

All error messages MUST be exactly: `'Cannot delete: this item is in use'` (generic, per DPRT-07).

**1. Items** (`block_item_deactivation`):
Check these tables for active references:
- `qmhq` WHERE `item_id = OLD.id AND is_active = true`
- `qmhq_items` JOIN `qmhq` WHERE `qi.item_id = OLD.id AND q.is_active = true`
- `po_line_items` JOIN `purchase_orders` WHERE `pli.item_id = OLD.id AND po.is_active = true AND pli.is_active = true`
- `inventory_transactions` WHERE `item_id = OLD.id AND is_active = true`
- `stock_out_line_items` WHERE `item_id = OLD.id AND is_active = true`

**2. Status Config** (`block_status_deactivation`):
- `qmrl` WHERE `status_id = OLD.id AND is_active = true`
- `qmhq` WHERE `status_id = OLD.id AND is_active = true`

**3. Categories** (`block_category_deactivation`):
- `qmrl` WHERE `category_id = OLD.id AND is_active = true`
- `qmhq` WHERE `category_id = OLD.id AND is_active = true`
- `items` WHERE `category_id = OLD.id AND is_active = true`

**4. Departments** (`block_department_deactivation`):
- `users` WHERE `department_id = OLD.id AND is_active = true`
- `qmrl` WHERE `department_id = OLD.id AND is_active = true`
- `contact_persons` WHERE `department_id = OLD.id AND is_active = true`

**5. Contact Persons** (`block_contact_person_deactivation`):
- `qmrl` WHERE `contact_person_id = OLD.id AND is_active = true`
- `qmhq` WHERE `contact_person_id = OLD.id AND is_active = true`

**6. Suppliers** (`block_supplier_deactivation`):
- `purchase_orders` WHERE `supplier_id = OLD.id AND is_active = true`

For each entity, create:
```sql
CREATE OR REPLACE FUNCTION block_{entity}_deactivation()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$ ... $$;

CREATE TRIGGER aa_block_{entity}_deactivation
  BEFORE UPDATE ON {table}
  FOR EACH ROW
  WHEN (OLD.is_active = true AND NEW.is_active = false)
  EXECUTE FUNCTION block_{entity}_deactivation();
```

Use `aa_` prefix on trigger names to ensure they fire before audit triggers (alphabetical ordering).

Add partial indexes for efficient reference checking where they don't already exist:
```sql
CREATE INDEX IF NOT EXISTS idx_{ref_table}_{fk_col}_active
  ON {ref_table}({fk_col}) WHERE is_active = true;
```
Only create indexes that don't already exist. Check migration files for existing indexes before adding.
  </action>
  <verify>
Run `npx supabase db reset` in the project directory to verify the migration applies cleanly without errors. Check that all 6 trigger functions and 6 triggers are created.
  </verify>
  <done>
Migration file exists at supabase/migrations/057_deletion_protection.sql with 6 trigger functions and 6 BEFORE UPDATE triggers. Each trigger blocks deactivation only when active references exist, uses generic error message, and fires only on is_active true->false transition.
  </done>
</task>

</tasks>

<verification>
1. Migration applies cleanly: `npx supabase db reset` succeeds
2. Each trigger function checks only `is_active = true` references
3. All error messages are exactly `'Cannot delete: this item is in use'`
4. WHEN clause on all triggers: `OLD.is_active = true AND NEW.is_active = false`
5. Trigger names use `aa_` prefix for ordering before audit triggers
</verification>

<success_criteria>
All 6 deletion protection triggers are created and the migration applies without errors. Any attempt to set is_active = false on a referenced entity will be blocked with the generic error message.
</success_criteria>

<output>
After completion, create `.planning/phases/29-deletion-protection/29-01-SUMMARY.md`
</output>
