---
phase: 29-deletion-protection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/057_deletion_protection.sql
autonomous: true

must_haves:
  truths:
    - "Item deactivation is blocked when referenced by active QMHQ, QMHQ items, PO line items, inventory transactions, or stock-out line items"
    - "Status deactivation is blocked when assigned to any active QMRL or QMHQ"
    - "Category deactivation is blocked when assigned to any active QMRL, QMHQ, or item"
    - "Department deactivation is blocked when assigned to any active user, QMRL, or contact person"
    - "Contact person deactivation is blocked when referenced by any active QMRL or QMHQ"
    - "Supplier deactivation is blocked when referenced by any active PO"
  artifacts:
    - path: "supabase/migrations/057_deletion_protection.sql"
      provides: "All deletion protection triggers for 6 entity types"
      contains: "block_item_deactivation"
  key_links:
    - from: "supabase/migrations/057_deletion_protection.sql"
      to: "items table"
      via: "BEFORE UPDATE trigger on is_active change"
      pattern: "WHEN \\(OLD\\.is_active = true AND NEW\\.is_active = false\\)"
    - from: "supabase/migrations/057_deletion_protection.sql"
      to: "status_config table"
      via: "BEFORE UPDATE trigger on is_active change"
      pattern: "block_status_deactivation"
    - from: "supabase/migrations/057_deletion_protection.sql"
      to: "stock_out_line_items table"
      via: "Reference check inside block_item_deactivation"
      pattern: "stock_out_line_items"
---

<objective>
Create database triggers that prevent deactivation of master data entities when they are actively referenced by other records.

Purpose: Protect referential integrity by blocking soft-delete (is_active = false) when active references exist, satisfying DPRT-01 through DPRT-06.
Output: Single migration file with 6 trigger functions and 6 BEFORE UPDATE triggers.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-deletion-protection/29-RESEARCH.md

Reference existing trigger pattern:
@supabase/migrations/040_invoice_void_block_stockin.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deletion protection triggers for Items, Status Config, and Categories</name>
  <files>supabase/migrations/057_deletion_protection.sql</files>
  <action>
Create the migration file `supabase/migrations/057_deletion_protection.sql`. This task adds the first 3 of 6 trigger functions (10 reference checks total). Task 2 will append the remaining 3.

Follow the existing pattern from `040_invoice_void_block_stockin.sql` exactly (function naming, RAISE EXCEPTION style, trigger naming with `aa_` prefix for ordering before audit triggers).

Each trigger fires ONLY when `OLD.is_active = true AND NEW.is_active = false` (using WHEN clause). Each function uses `SELECT EXISTS(... LIMIT 1)` pattern for early exit.

All error messages MUST be exactly: `'Cannot delete: this item is in use'` (generic, per DPRT-07).

**1. Items** (`block_item_deactivation`) -- 5 reference checks:
- `qmhq` WHERE `item_id = OLD.id AND is_active = true`
- `qmhq_items` JOIN `qmhq` WHERE `qi.item_id = OLD.id AND q.is_active = true`
- `po_line_items` JOIN `purchase_orders` WHERE `pli.item_id = OLD.id AND po.is_active = true AND pli.is_active = true`
- `inventory_transactions` WHERE `item_id = OLD.id AND is_active = true`
- `stock_out_line_items` WHERE `item_id = OLD.id AND is_active = true`

**2. Status Config** (`block_status_deactivation`) -- 2 reference checks:
- `qmrl` WHERE `status_id = OLD.id AND is_active = true`
- `qmhq` WHERE `status_id = OLD.id AND is_active = true`

**3. Categories** (`block_category_deactivation`) -- 3 reference checks:
- `qmrl` WHERE `category_id = OLD.id AND is_active = true`
- `qmhq` WHERE `category_id = OLD.id AND is_active = true`
- `items` WHERE `category_id = OLD.id AND is_active = true`

For each entity, create:
```sql
CREATE OR REPLACE FUNCTION block_{entity}_deactivation()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$ ... $$;

CREATE TRIGGER aa_block_{entity}_deactivation
  BEFORE UPDATE ON {table}
  FOR EACH ROW
  WHEN (OLD.is_active = true AND NEW.is_active = false)
  EXECUTE FUNCTION block_{entity}_deactivation();
```

Use `aa_` prefix on trigger names to ensure they fire before audit triggers (alphabetical ordering).

**Indexes to add** (partial indexes for efficient reference checking). The following indexes are needed but DO NOT already exist -- add all of them:
```sql
-- For item reference checks:
CREATE INDEX IF NOT EXISTS idx_qmhq_item_id_active ON qmhq(item_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_po_line_items_item_id_active ON po_line_items(item_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_inventory_transactions_item_id_active ON inventory_transactions(item_id) WHERE is_active = true;
-- Note: idx_sor_li_item already exists on stock_out_line_items(item_id) and idx_sor_li_is_active covers is_active filtering
-- Note: idx_qmhq_items_item_id already exists on qmhq_items(item_id)

-- For status reference checks:
CREATE INDEX IF NOT EXISTS idx_qmrl_status_id_active ON qmrl(status_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_qmhq_status_id_active ON qmhq(status_id) WHERE is_active = true;

-- For category reference checks:
CREATE INDEX IF NOT EXISTS idx_qmrl_category_id_active ON qmrl(category_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_qmhq_category_id_active ON qmhq(category_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_items_category_id_active ON items(category_id) WHERE is_active = true;
```

**Existing indexes that cover these tables (DO NOT recreate):**
- `idx_qmhq_item_id` on qmhq(item_id) -- exists but not partial
- `idx_qmhq_items_item_id` on qmhq_items(item_id) -- exists, non-partial is fine for JOIN
- `idx_po_line_items_item_id` on po_line_items(item_id) -- exists but not partial
- `idx_inventory_transactions_item_id` on inventory_transactions(item_id) -- exists but not partial
- `idx_sor_li_item` on stock_out_line_items(item_id) -- exists
- `idx_qmrl_status` on qmrl(status_id) -- exists but not partial
- `idx_qmhq_status_id` on qmhq(status_id) -- exists but not partial
- `idx_qmrl_category` on qmrl(category_id) -- exists but not partial
- `idx_qmhq_category_id` on qmhq(category_id) -- exists but not partial
- `idx_items_category_id` on items(category_id) -- exists but not partial
  </action>
  <verify>
Verify the migration file exists and contains 3 trigger functions (block_item_deactivation, block_status_deactivation, block_category_deactivation) and 3 corresponding BEFORE UPDATE triggers with aa_ prefix. Verify stock_out_line_items is included in block_item_deactivation.
  </verify>
  <done>
Migration file contains triggers for items (5 reference checks including stock_out_line_items), status_config (2 reference checks), and categories (3 reference checks) with correct WHEN clause, aa_ prefix, and partial indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deletion protection triggers for Departments, Contact Persons, and Suppliers</name>
  <files>supabase/migrations/057_deletion_protection.sql</files>
  <action>
Append to the existing migration file `supabase/migrations/057_deletion_protection.sql` the remaining 3 trigger functions (6 reference checks total).

Same patterns as Task 1: WHEN clause, `aa_` prefix, SELECT EXISTS with LIMIT 1, generic error message `'Cannot delete: this item is in use'`.

**4. Departments** (`block_department_deactivation`) -- 3 reference checks:
- `users` WHERE `department_id = OLD.id AND is_active = true`
- `qmrl` WHERE `department_id = OLD.id AND is_active = true`
- `contact_persons` WHERE `department_id = OLD.id AND is_active = true`

**5. Contact Persons** (`block_contact_person_deactivation`) -- 2 reference checks:
- `qmrl` WHERE `contact_person_id = OLD.id AND is_active = true`
- `qmhq` WHERE `contact_person_id = OLD.id AND is_active = true`

**6. Suppliers** (`block_supplier_deactivation`) -- 1 reference check:
- `purchase_orders` WHERE `supplier_id = OLD.id AND is_active = true`

**Indexes to add** (partial indexes for efficient reference checking):
```sql
-- For department reference checks:
CREATE INDEX IF NOT EXISTS idx_users_department_id_active ON users(department_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_qmrl_department_id_active ON qmrl(department_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_contact_persons_department_id_active ON contact_persons(department_id) WHERE is_active = true;

-- For contact person reference checks:
CREATE INDEX IF NOT EXISTS idx_qmrl_contact_person_id_active ON qmrl(contact_person_id) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_qmhq_contact_person_id_active ON qmhq(contact_person_id) WHERE is_active = true;

-- For supplier reference checks:
CREATE INDEX IF NOT EXISTS idx_purchase_orders_supplier_id_active ON purchase_orders(supplier_id) WHERE is_active = true;
```

**Existing indexes that cover these tables (DO NOT recreate):**
- `idx_users_department` on users(department_id) -- exists but not partial
- `idx_qmrl_department` on qmrl(department_id) -- exists but not partial
- `idx_contact_persons_department` on contact_persons(department_id) -- exists but not partial
- `idx_purchase_orders_supplier_id` on purchase_orders(supplier_id) -- exists but not partial
  </action>
  <verify>
Run `npx supabase db reset` in the project directory to verify the complete migration (all 6 triggers from Task 1 + Task 2) applies cleanly without errors. Verify all 6 trigger functions and 6 triggers exist.
  </verify>
  <done>
Migration file contains all 6 trigger functions and 6 BEFORE UPDATE triggers. `npx supabase db reset` succeeds. All 16 reference checks are in place across items (5), status_config (2), categories (3), departments (3), contact_persons (2), suppliers (1).
  </done>
</task>

</tasks>

<verification>
1. Migration applies cleanly: `npx supabase db reset` succeeds
2. Each trigger function checks only `is_active = true` references
3. All error messages are exactly `'Cannot delete: this item is in use'`
4. WHEN clause on all triggers: `OLD.is_active = true AND NEW.is_active = false`
5. Trigger names use `aa_` prefix for ordering before audit triggers
6. block_item_deactivation includes stock_out_line_items reference check
7. All 16 reference checks present across 6 entities
</verification>

<success_criteria>
All 6 deletion protection triggers are created and the migration applies without errors. Any attempt to set is_active = false on a referenced entity will be blocked with the generic error message.
</success_criteria>

<output>
After completion, create `.planning/phases/29-deletion-protection/29-01-SUMMARY.md`
</output>
