---
phase: 05-management-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/033_dashboard_functions.sql
  - lib/actions/dashboard.ts
  - lib/hooks/use-interval.ts
  - lib/hooks/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "RPC function get_qmrl_status_counts returns counts grouped by to_do, in_progress, done"
    - "RPC function get_qmhq_status_counts returns counts grouped by to_do, in_progress, done"
    - "RPC function get_low_stock_alerts returns items with stock <= 10 with severity levels"
    - "Server action getDashboardData fetches all 5 data types in parallel"
    - "useInterval hook provides polling capability with proper cleanup"
  artifacts:
    - path: "supabase/migrations/033_dashboard_functions.sql"
      provides: "PostgreSQL RPC functions for dashboard aggregations"
      contains: "get_qmrl_status_counts"
    - path: "lib/actions/dashboard.ts"
      provides: "Server action for dashboard data fetching"
      exports: ["getDashboardData", "DashboardData"]
    - path: "lib/hooks/use-interval.ts"
      provides: "Polling hook with ref pattern"
      exports: ["useInterval"]
  key_links:
    - from: "lib/actions/dashboard.ts"
      to: "supabase.rpc"
      via: "RPC calls for aggregations"
      pattern: "supabase\\.rpc\\('get_"
---

<objective>
Create the data layer for the management dashboard: PostgreSQL RPC functions for efficient aggregations and a server action that fetches all dashboard data in parallel.

Purpose: Enable efficient, single-round-trip data fetching for dashboard KPIs and activity feeds without client-side filtering.
Output: Migration file with 3 RPC functions, server action with parallel fetching, reusable polling hook.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-management-dashboard/05-CONTEXT.md
@.planning/phases/05-management-dashboard/05-RESEARCH.md
@supabase/migrations/003_status_config.sql
@supabase/migrations/023_inventory_transactions.sql
@supabase/migrations/025_audit_logs.sql
@lib/supabase/server.ts
@types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL RPC functions for dashboard aggregations</name>
  <files>supabase/migrations/033_dashboard_functions.sql</files>
  <action>
Create migration file with three SECURITY DEFINER functions:

1. `get_qmrl_status_counts()` - Returns TABLE(status_group text, count bigint)
   - LEFT JOIN status_config with qmrl on status_id
   - Filter: entity_type = 'qmrl', is_active = true (both tables)
   - GROUP BY status_group
   - ORDER BY to_do -> in_progress -> done (CASE expression)

2. `get_qmhq_status_counts()` - Same structure as QMRL but for qmhq table
   - Filter: entity_type = 'qmhq', is_active = true

3. `get_low_stock_alerts(threshold integer DEFAULT 10)` - Returns TABLE with:
   - item_id, item_name, item_sku
   - warehouse_id, warehouse_name
   - current_stock numeric
   - severity text ('out_of_stock', 'critical', 'warning')

   Implementation:
   - CTE to calculate stock per item/warehouse from inventory_transactions
   - SUM inventory_in - SUM inventory_out WHERE status = 'completed' AND is_active = true
   - Filter for stock <= threshold
   - Severity: 0 = out_of_stock, 1-4 = critical, 5-10 = warning
   - ORDER BY severity (out_of_stock first), then name

All functions: LANGUAGE sql STABLE SECURITY DEFINER

Grant EXECUTE to authenticated role.

Reference the RESEARCH.md code examples for exact SQL patterns.
  </action>
  <verify>
SQL syntax review - functions follow PostgreSQL RPC patterns from research.
Check: All 3 functions defined with correct return types and security settings.
  </verify>
  <done>
Migration file 033_dashboard_functions.sql exists with get_qmrl_status_counts, get_qmhq_status_counts, get_low_stock_alerts functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server action and useInterval hook</name>
  <files>lib/actions/dashboard.ts, lib/hooks/use-interval.ts, lib/hooks/index.ts</files>
  <action>
1. Create `lib/actions/dashboard.ts`:
   - 'use server' directive
   - Import createClient from @/lib/supabase/server
   - Define DashboardData interface:
     ```typescript
     export interface DashboardData {
       qmrlStats: { status_group: string; count: number }[];
       qmhqStats: { status_group: string; count: number }[];
       lowStockAlerts: Array<{
         item_id: string;
         item_name: string;
         item_sku: string;
         warehouse_id: string;
         warehouse_name: string;
         current_stock: number;
         severity: 'out_of_stock' | 'critical' | 'warning';
       }>;
       recentAudits: Array<{
         id: string;
         action: string;
         entity_type: string;
         changes_summary: string | null;
         changed_by_name: string | null;
         changed_at: string;
       }>;
       recentStockMovements: Array<{
         id: string;
         movement_type: 'inventory_in' | 'inventory_out';
         item_name: string | null;
         quantity: number;
         warehouse_name: string;
         transaction_date: string;
         created_by_name: string;
       }>;
     }
     ```
   - Export getDashboardData function using parallel fetching pattern:
     - Initiate all 5 promises BEFORE any await
     - Use Promise.all to await together
     - RPC calls: get_qmrl_status_counts, get_qmhq_status_counts, get_low_stock_alerts
     - Direct queries: audit_logs (limit 5, order by changed_at DESC), inventory_transactions with joins (limit 10, order by transaction_date DESC)
     - For inventory_transactions, join warehouses and users tables for names
   - Handle null/error cases gracefully (return empty arrays)

2. Create `lib/hooks/use-interval.ts`:
   - 'use client' directive
   - useRef to store callback (prevents stale closures)
   - First useEffect: update ref when callback changes
   - Second useEffect: setInterval with delay, return cleanup function
   - If delay is null, disable interval
   - Export useInterval function

3. Update `lib/hooks/index.ts`:
   - Add export for use-interval

Reference RESEARCH.md code examples for exact implementation patterns.
  </action>
  <verify>
Run `npm run type-check` - no TypeScript errors in new files.
Check: DashboardData interface properly typed, server action uses parallel fetching, useInterval uses ref pattern.
  </verify>
  <done>
Server action getDashboardData exists and fetches 5 data types in parallel. useInterval hook exported from lib/hooks.
  </done>
</task>

</tasks>

<verification>
1. Migration file syntax is valid PostgreSQL
2. Server action compiles without TypeScript errors
3. useInterval hook properly exported
4. Parallel fetching pattern used (no sequential awaits)
</verification>

<success_criteria>
- 033_dashboard_functions.sql contains 3 RPC functions with correct signatures
- lib/actions/dashboard.ts exports getDashboardData with DashboardData type
- lib/hooks/use-interval.ts exports useInterval with ref-based callback pattern
- npm run type-check passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-management-dashboard/05-01-SUMMARY.md`
</output>
