---
phase: 30-user-deactivation
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - app/(dashboard)/admin/users/page.tsx
  - app/(dashboard)/admin/users/deactivate-user-dialog.tsx
  - app/(auth)/login/page.tsx
  - app/(dashboard)/qmhq/new/page.tsx
  - app/(dashboard)/qmhq/[id]/edit/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can deactivate a user via action menu with confirmation dialog and optional reason"
    - "Admin can reactivate a deactivated user via action menu with confirmation"
    - "Deactivated users appear in the user list with Inactive badge and dimmed/grayed rows"
    - "Admin cannot deactivate their own account (button hidden or disabled for self)"
    - "Login page shows specific deactivation message when redirected with reason=deactivated"
    - "Assignment dropdowns consistently filter out deactivated users"
    - "Historical records (detail pages, audit logs) still show deactivated user names"
  artifacts:
    - path: "app/(dashboard)/admin/users/deactivate-user-dialog.tsx"
      provides: "Confirmation dialog with optional reason field for deactivation"
      min_lines: 60
    - path: "app/(dashboard)/admin/users/page.tsx"
      provides: "Updated users page showing all users with inactive badges and dimmed rows"
      contains: "is_active"
    - path: "app/(auth)/login/page.tsx"
      provides: "Login page with deactivation-specific error message"
      contains: "deactivated"
  key_links:
    - from: "app/(dashboard)/admin/users/page.tsx"
      to: "/api/admin/deactivate-user"
      via: "fetch in deactivate handler"
      pattern: "api/admin/deactivate-user"
    - from: "app/(dashboard)/admin/users/page.tsx"
      to: "/api/admin/reactivate-user"
      via: "fetch in reactivate handler"
      pattern: "api/admin/reactivate-user"
    - from: "app/(auth)/login/page.tsx"
      to: "URL searchParams"
      via: "reason=deactivated query param"
      pattern: "reason.*deactivated"
---

<objective>
Implement the user deactivation UI on the admin users page (confirmation dialog, action menu changes, inactive badges, dimmed rows), update the login page to show deactivation-specific messages, and audit dropdown filtering for consistency.

Purpose: Give admins a clear, safe way to deactivate/reactivate users with visual feedback, and ensure deactivated users see a meaningful message when blocked from login.

Output: Updated users page with full deactivation UX, new confirmation dialog component, updated login page, and consistent dropdown filtering.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-user-deactivation/30-01-SUMMARY.md
@app/(dashboard)/admin/users/page.tsx
@app/(dashboard)/admin/users/user-dialog.tsx
@app/(auth)/login/page.tsx
@components/invoice/void-invoice-dialog.tsx
@components/stock-out-requests/rejection-dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deactivation confirmation dialog and update users page</name>
  <files>
    app/(dashboard)/admin/users/deactivate-user-dialog.tsx
    app/(dashboard)/admin/users/page.tsx
  </files>
  <action>
**Create DeactivateUserDialog** at `app/(dashboard)/admin/users/deactivate-user-dialog.tsx`:
- Follow the VoidInvoiceDialog pattern (Dialog, DialogContent, DialogHeader, DialogFooter, AlertTriangle icon)
- Props: `{ open, onOpenChange, userName: string, onConfirm: (reason?: string) => Promise<void>, isLoading?: boolean }`
- Contains an OPTIONAL reason Textarea field (label: "Why are you deactivating this user?" with "(optional)" text — per locked decision the reason is optional, unlike VoidInvoiceDialog which requires it)
- Warning banner: "This will immediately sign out {userName} from all active sessions and prevent future login."
- Confirm button: destructive variant, text "Deactivate User"
- Reset reason on close (same pattern as VoidInvoiceDialog handleClose)

**Overhaul the users page** (`app/(dashboard)/admin/users/page.tsx`):

1. **Remove the deactivated user filter** — Change line 58 from `.neq("is_active", false)` to remove that filter entirely (or add no filter on is_active). Fetch ALL users so deactivated ones appear in the list.

2. **Add "Inactive" badge and row dimming** — In the columns definition:
   - In the `full_name` column cell (lines 131-142), wrap the content so that if `!row.original.is_active`, the entire row text is dimmed with `opacity-50` class, AND show a `<Badge variant="outline" className="text-red-400 border-red-500/30 text-xs ml-2">Inactive</Badge>` next to the name
   - Use a single source of truth: `const isInactive = !row.original.is_active` at the top of each cell renderer

3. **Update action menu** (lines 176-209):
   - Import `useAuth` from auth-provider to get current user ID
   - For active users (`is_active === true`): Show "Deactivate" action (replaces current "Deactivate" button which does a direct update). This should open the DeactivateUserDialog instead of calling handleDelete directly
   - For inactive users (`is_active === false`): Show "Reactivate" action (green text, with RotateCcw icon from lucide-react)
   - Hide the Deactivate action for the current user's own row (`row.original.id === currentUser?.id`) — per locked decision: admins cannot deactivate their own account
   - Keep the Edit action for both active and inactive users

4. **Add dialog state** — Add state for the deactivation dialog:
   ```tsx
   const [deactivateDialogOpen, setDeactivateDialogOpen] = useState(false);
   const [deactivatingUser, setDeactivatingUser] = useState<UserWithDepartment | null>(null);
   ```

5. **Replace handleDelete** with two new handlers:
   - `handleDeactivate(reason?: string)` — calls `fetch("/api/admin/deactivate-user", { method: "POST", body: { user_id: deactivatingUser.id, reason } })`, shows success/error toast, refreshes data
   - `handleReactivate(userId: string)` — calls `fetch("/api/admin/reactivate-user", { method: "POST", body: { user_id: userId } })`, shows success toast ("User reactivated"), refreshes data. Use `window.confirm("Reactivate this user? They will be able to log in again.")` for simple confirmation (no custom dialog needed for reactivation)

6. **Update stats cards** — The "Total Users" card should show total count. Consider adding an "Inactive" count card or updating existing card to show "X Active / Y Total".

7. **Render the dialog** at bottom of the component, after the UserDialog:
   ```tsx
   <DeactivateUserDialog
     open={deactivateDialogOpen}
     onOpenChange={setDeactivateDialogOpen}
     userName={deactivatingUser?.full_name || ""}
     onConfirm={handleDeactivate}
     isLoading={...}
   />
   ```
  </action>
  <verify>
    Run `npm run type-check` to verify all TypeScript compiles. Verify the dialog component file exists. Verify the users page no longer filters out inactive users.
  </verify>
  <done>
    Users page shows all users (active + inactive). Inactive users have dimmed rows and "Inactive" badge. Action menu shows Deactivate (with confirmation dialog and optional reason) for active users and Reactivate for inactive users. Admin's own row has no Deactivate option. Deactivation calls /api/admin/deactivate-user, reactivation calls /api/admin/reactivate-user.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update login page with deactivation-specific error message</name>
  <files>app/(auth)/login/page.tsx</files>
  <action>
Update the login page to detect the `reason=deactivated` URL parameter and show the specific deactivation message.

1. Import `useSearchParams` from `next/navigation`
2. At the top of the component, read the search params:
   ```tsx
   const searchParams = useSearchParams();
   const deactivatedReason = searchParams.get("reason") === "deactivated";
   ```
3. Add a `useEffect` that sets the message state when `deactivatedReason` is true:
   ```tsx
   useEffect(() => {
     if (deactivatedReason) {
       setMessage({
         type: "error",
         text: "Your account has been deactivated. Contact your administrator.",
       });
     }
   }, [deactivatedReason]);
   ```
   This exact message text is per the locked decision.

4. The existing message display (lines 297-308) will render this automatically since it uses the same `message` state.

5. Also update the OTP verification error handling: After successful OTP verification, the auth-provider will fetch the user profile. If the user was deactivated between receiving the OTP and verifying it, the middleware will catch it on the next navigation. No additional handling needed in the login page for this edge case.

6. Wrap the component in a `<Suspense>` boundary if `useSearchParams` requires it (Next.js App Router may require this for client components using searchParams). If so, create a wrapper:
   ```tsx
   import { Suspense } from "react";

   function LoginContent() { /* existing component body */ }

   export default function LoginPage() {
     return <Suspense><LoginContent /></Suspense>;
   }
   ```
  </action>
  <verify>
    Run `npm run type-check`. Verify the login page compiles. Check that the string "Your account has been deactivated" appears in the file.
  </verify>
  <done>
    Login page shows "Your account has been deactivated. Contact your administrator." when accessed with ?reason=deactivated URL param. This is the exact message from the locked decision. Normal login flow unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit and fix user dropdown filtering consistency</name>
  <files>
    app/(dashboard)/qmhq/new/page.tsx
    app/(dashboard)/qmhq/[id]/edit/page.tsx
  </files>
  <action>
Audit all places that query `from("users")` for dropdown population and ensure consistent `.eq("is_active", true)` filtering. Currently there is an inconsistency:

**Already correct (use `.eq("is_active", true)`):**
- `app/(dashboard)/qmrl/new/page.tsx` line 105: `.eq("is_active", true)` -- GOOD
- `app/(dashboard)/qmrl/[id]/edit/page.tsx` line 149: `.eq("is_active", true)` -- GOOD

**Inconsistent (use `.neq("is_active", false)` — functionally same but inconsistent pattern):**
- `app/(dashboard)/qmhq/new/page.tsx` line 172: `.neq("is_active", false)` -- Change to `.eq("is_active", true)`
- `app/(dashboard)/qmhq/[id]/edit/page.tsx` line 132: `.neq("is_active", false)` -- Change to `.eq("is_active", true)`

**Display queries (do NOT filter — these show historical data):**
- `app/(dashboard)/qmrl/page.tsx` line 97: users fetched for filter dropdown — this should stay as-is (it uses `.eq("is_active", true)` which is correct for dropdown)
- `app/(dashboard)/qmhq/page.tsx` line 76: FK join for display — no is_active filter needed (correct, shows historical attribution)
- `app/(dashboard)/qmrl/[id]/page.tsx` line 124: FK join for display — no filter needed (correct)
- `app/(dashboard)/qmhq/[id]/page.tsx` line 149-150: FK joins for display — no filter needed (correct)

**Admin users page (special case — now shows all):**
- `app/(dashboard)/admin/users/page.tsx` line 58: Will be updated in Task 1 to show all users (no is_active filter)

Only modify the two QMHQ files listed above. Change `.neq("is_active", false)` to `.eq("is_active", true)` for consistency. This is functionally equivalent but standardizes the pattern across the codebase.

This ensures: dropdown/assignment selects only show active users, while FK-joined display queries (detail pages, list pages) continue to show all user names regardless of active status — preserving historical data attribution per the success criteria.
  </action>
  <verify>
    Run `npm run type-check` to verify changes compile. Grep for `neq("is_active", false)` in the app directory — should only appear in `admin/users/page.tsx` (if it still uses it for departments) and `admin/departments/department-dialog.tsx`. The two QMHQ files should now use `.eq("is_active", true)`.
  </verify>
  <done>
    All user dropdown queries consistently use `.eq("is_active", true)`. Historical display queries (FK joins on detail/list pages) do not filter by is_active, preserving deactivated user attribution. Pattern is uniform across QMRL and QMHQ forms.
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes
2. `npm run build` succeeds
3. Users page shows deactivated users with badge and dimming
4. DeactivateUserDialog component exists with optional reason field
5. Login page contains deactivated-specific message
6. Grep confirms consistent dropdown filtering pattern
</verification>

<success_criteria>
- Admin can deactivate a user via action menu → confirmation dialog with optional reason → calls API → user appears dimmed with Inactive badge
- Admin can reactivate a user via action menu → simple confirmation → calls API → user row returns to normal
- Admin's own row has no Deactivate option
- Login page at /login?reason=deactivated shows "Your account has been deactivated. Contact your administrator."
- All user dropdowns use .eq("is_active", true) consistently
- Historical FK joins on detail pages preserve deactivated user names
</success_criteria>

<output>
After completion, create `.planning/phases/30-user-deactivation/30-02-SUMMARY.md`
</output>
