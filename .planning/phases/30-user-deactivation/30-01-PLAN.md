---
phase: 30-user-deactivation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/admin/deactivate-user/route.ts
  - app/api/admin/reactivate-user/route.ts
  - lib/supabase/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Deactivate API sets is_active=false and bans user via Supabase Admin API"
    - "Reactivate API sets is_active=true and unbans user via Supabase Admin API"
    - "Middleware blocks deactivated users on every protected request and redirects to login"
    - "Admin cannot deactivate their own account (API-level guard)"
  artifacts:
    - path: "app/api/admin/deactivate-user/route.ts"
      provides: "POST endpoint for user deactivation with ban + session kill"
      exports: ["POST"]
    - path: "app/api/admin/reactivate-user/route.ts"
      provides: "POST endpoint for user reactivation with unban"
      exports: ["POST"]
    - path: "lib/supabase/middleware.ts"
      provides: "Enhanced middleware checking is_active on every request"
      contains: "is_active"
  key_links:
    - from: "app/api/admin/deactivate-user/route.ts"
      to: "supabase.auth.admin"
      via: "ban_duration + signOut"
      pattern: "auth\\.admin\\.(updateUserById|signOut)"
    - from: "lib/supabase/middleware.ts"
      to: "public.users"
      via: "is_active check query"
      pattern: "is_active"
---

<objective>
Create backend API routes for user deactivation/reactivation and enhance middleware to enforce login blocking for deactivated users.

Purpose: Provide the server-side enforcement layer that prevents deactivated users from accessing the system, and gives admins the API to toggle user active status with proper session invalidation.

Output: Two API routes and an enhanced middleware function.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/api/admin/invite-user/route.ts
@lib/supabase/middleware.ts
@middleware.ts
@components/providers/auth-provider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deactivate and reactivate API routes</name>
  <files>
    app/api/admin/deactivate-user/route.ts
    app/api/admin/reactivate-user/route.ts
  </files>
  <action>
Create two API route handlers following the exact pattern from `app/api/admin/invite-user/route.ts` (admin role verification via server client, then service-role admin client for privileged operations).

**POST /api/admin/deactivate-user** — accepts `{ user_id: string, reason?: string }`:
1. Verify requesting user is admin (same pattern as invite-user/route.ts lines 8-24)
2. Guard: if `user_id === currentUser.id`, return 400 "Cannot deactivate your own account" (per locked decision: admins cannot deactivate themselves)
3. Using service-role admin client:
   a. Set `is_active = false` on `public.users` table for `user_id`
   b. If reason provided, store in a `deactivation_reason` field (add to update if column exists, otherwise skip — the reason is primarily for the confirmation dialog UX, not stored)
   c. Call `supabaseAdmin.auth.admin.updateUserById(user_id, { ban_duration: '876600h' })` to ban (100 years, effectively permanent)
   d. Call `supabaseAdmin.auth.admin.signOut(user_id, 'global')` to kill all active sessions immediately
4. Return `{ success: true }` on success, appropriate error responses on failure

**POST /api/admin/reactivate-user** — accepts `{ user_id: string }`:
1. Verify requesting user is admin (same pattern)
2. Using service-role admin client:
   a. Set `is_active = true` on `public.users` table for `user_id`
   b. Call `supabaseAdmin.auth.admin.updateUserById(user_id, { ban_duration: 'none' })` to unban
3. Return `{ success: true }` on success

Both routes use `createClient` from `@supabase/supabase-js` (NOT the server helper) for the admin client, with `SUPABASE_SERVICE_ROLE_KEY`, exactly like invite-user/route.ts line 35-38.

Note: The `signOut` admin method signature is `supabaseAdmin.auth.admin.signOut(user_id)` with scope 'global' — check the Supabase JS client API. If the method only accepts userId as string, call it as `supabaseAdmin.auth.admin.signOut(user_id)`. Wrap in try/catch since the user may not have active sessions.
  </action>
  <verify>
    Run `npm run type-check` to verify TypeScript compiles. Verify both route files exist and export POST handlers.
  </verify>
  <done>
    Both API routes compile without errors. Deactivate route guards against self-deactivation, sets is_active=false, bans via admin API, and kills sessions. Reactivate route sets is_active=true and unbans.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance middleware to check is_active status</name>
  <files>lib/supabase/middleware.ts</files>
  <action>
Modify `updateSession()` in `lib/supabase/middleware.ts` to check the user's `is_active` status from the `public.users` table after the existing `supabase.auth.getUser()` call (line 39).

After the existing user check block (line 47-52), add:

```
// If user exists and route is protected, check if user is still active
if (user && !isPublicRoute) {
  const { data: profile } = await supabase
    .from("users")
    .select("is_active")
    .eq("id", user.id)
    .single();

  if (profile && profile.is_active === false) {
    // Force sign out the deactivated user
    await supabase.auth.signOut();
    const url = request.nextUrl.clone();
    url.pathname = "/login";
    url.searchParams.set("reason", "deactivated");
    return NextResponse.redirect(url);
  }
}
```

This runs on every protected request. When a deactivated user's access token hasn't expired yet (Supabase tokens last up to 60 minutes), this middleware catches them and redirects to `/login?reason=deactivated`.

Keep the existing login redirect logic (line 47-52) unchanged. The new check goes between the "no user" redirect and the "user on login page" redirect.

Performance note: This adds one small query per request. The `users` table has an index on `id` (PK) so it's a simple index lookup. The ban_duration from Task 1 will prevent token refresh after expiry, so this middleware check is the bridge for the 0-60 minute window.
  </action>
  <verify>
    Run `npm run type-check` and `npm run build` to verify the middleware compiles and builds correctly. The build will catch any issues with the middleware matcher or imports.
  </verify>
  <done>
    Middleware queries public.users.is_active for every authenticated request to a protected route. Deactivated users are signed out and redirected to /login?reason=deactivated. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run type-check` passes
2. `npm run build` succeeds (middleware changes are build-critical)
3. Both API route files exist at correct paths
4. Middleware contains is_active check logic
</verification>

<success_criteria>
- Deactivate API: POST /api/admin/deactivate-user sets is_active=false, bans user, kills sessions, guards self-deactivation
- Reactivate API: POST /api/admin/reactivate-user sets is_active=true, unbans user
- Middleware: Every protected request checks is_active, deactivated users redirected to /login?reason=deactivated
</success_criteria>

<output>
After completion, create `.planning/phases/30-user-deactivation/30-01-SUMMARY.md`
</output>
