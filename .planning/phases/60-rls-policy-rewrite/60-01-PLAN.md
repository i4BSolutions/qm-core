---
phase: 60-rls-policy-rewrite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260221100000_rls_permission_matrix_rewrite.sql
  - types/database.ts
autonomous: true
requirements:
  - PERM-09

must_haves:
  truths:
    - "A user with Edit permission on a resource can insert, update, and select records for that resource"
    - "A user with View permission on a resource can only select — insert and update return permission denied"
    - "A user with Block permission on a resource receives no rows on select and permission denied on mutations"
    - "No RLS policy in the database references get_user_role() — all use has_permission()"
    - "The users.role column and user_role enum no longer exist"
    - "All trigger functions remain SECURITY DEFINER and continue to bypass RLS"
    - "Reference/config tables (departments, status_config, categories, contact_persons, suppliers, standard_units) are readable by all authenticated users and writable only by admin-permissioned users"
  artifacts:
    - path: "supabase/migrations/20260221100000_rls_permission_matrix_rewrite.sql"
      provides: "Complete RLS policy rewrite for all tables plus role column drop"
      contains: "has_permission"
    - path: "types/database.ts"
      provides: "Updated types with role column removed from User type"
      contains: "UserPermission"
  key_links:
    - from: "supabase/migrations/20260221100000_rls_permission_matrix_rewrite.sql"
      to: "supabase/migrations/20260221000000_permission_schema.sql"
      via: "has_permission() function defined in Phase 59"
      pattern: "has_permission\\("
---

<objective>
Replace all 100+ existing RLS policies across all tables with permission-matrix-aware policies using `has_permission()`, drop the legacy `users.role` column and `get_user_role()` function, and update helper functions that reference old role checks.

Purpose: Transition database authorization from fixed 3-role RBAC to per-user per-resource permission matrix. After this migration, Edit=CRUD, View=read-only, Block=no access for every resource.

Output: A single migration file that drops all existing policies, creates fresh permission-matrix policies for every RLS-enabled table, drops legacy role infrastructure, and updates helper functions.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-rls-policy-rewrite/60-CONTEXT.md
@.planning/phases/59-permission-schema-migration/59-01-SUMMARY.md
@supabase/migrations/20260221000000_permission_schema.sql
@supabase/migrations/20260211120001_rbac_rls_policy_recreation.sql
@supabase/migrations/20260219100000_rbac_role_restrictions.sql
@supabase/migrations/20260219110000_users_display_info_read.sql
@supabase/migrations/035_qmhq_items.sql
@supabase/migrations/20260216100000_standard_units.sql
@types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS permission-matrix migration</name>
  <files>supabase/migrations/20260221100000_rls_permission_matrix_rewrite.sql</files>
  <action>
Create a single migration file that performs a clean-slate RLS rewrite. The entire migration MUST be wrapped in `BEGIN; ... COMMIT;` for atomicity. Structure the migration in these sections:

**SECTION A: Drop ALL existing RLS policies on ALL tables**

For every table below, use `DROP POLICY IF EXISTS` to remove every existing policy. Reference the policy names from the current codebase:

Tables and their existing policy names to drop:
- `users`: users_select_own, users_select_all_authenticated, users_insert, users_update_own, users_update_admin, users_delete
- `departments`: departments_select, departments_insert, departments_update, departments_delete
- `status_config`: status_config_select, status_config_insert, status_config_update, status_config_delete
- `categories`: categories_select, categories_insert, categories_update, categories_delete
- `contact_persons`: contact_persons_select, contact_persons_insert, contact_persons_update, contact_persons_delete
- `suppliers`: suppliers_select, suppliers_insert, suppliers_update, suppliers_delete
- `items`: items_select, items_insert, items_update, items_delete
- `warehouses`: warehouses_select, warehouses_insert, warehouses_update, warehouses_delete
- `qmrl`: qmrl_select, qmrl_insert, qmrl_update, qmrl_delete
- `qmhq`: qmhq_select, qmhq_insert, qmhq_update, qmhq_delete
- `financial_transactions`: financial_transactions_select, financial_transactions_insert, financial_transactions_update, financial_transactions_delete
- `purchase_orders`: purchase_orders_select, purchase_orders_insert, purchase_orders_update, purchase_orders_delete
- `po_line_items`: po_line_items_select, po_line_items_insert, po_line_items_update, po_line_items_delete
- `invoices`: invoices_select, invoices_insert, invoices_update, invoices_delete
- `invoice_line_items`: invoice_line_items_select, invoice_line_items_insert, invoice_line_items_update, invoice_line_items_delete
- `inventory_transactions`: inventory_transactions_select, inventory_transactions_insert, inventory_transactions_update, inventory_transactions_delete
- `audit_logs`: audit_logs_select, audit_logs_insert
- `file_attachments`: file_attachments_select, file_attachments_insert, file_attachments_update, file_attachments_delete
- `comments`: comments_select, comments_insert, comments_update, comments_delete
- `stock_out_requests`: sor_select, sor_insert, sor_update, sor_delete
- `stock_out_line_items`: sor_li_select, sor_li_insert, sor_li_update, sor_li_delete
- `stock_out_approvals`: sor_approval_select, sor_approval_insert, sor_approval_update, sor_approval_delete
- `qmhq_items`: qmhq_items_select, qmhq_items_insert, qmhq_items_update, qmhq_items_delete
- `standard_units`: standard_units_select, standard_units_insert, standard_units_update, standard_units_delete
- `system_config`: system_config_select, system_config_insert, system_config_update, system_config_delete (if table still exists)
- `user_permissions`: admin_full_access_permissions, users_read_own_permissions
- `storage.objects`: storage_attachments_select, storage_attachments_insert, storage_attachments_update, storage_attachments_delete

**SECTION B: Create fresh permission-matrix policies**

Use `has_permission(resource, level)` as the single authorization gate. The mapping from table to permission_resource is:

**Resource-mapped tables (standard pattern):**
For each of these tables, create 4 policies:
- `{table}_perm_select`: `USING (has_permission('{resource}', 'view'))` — view or edit can read
- `{table}_perm_insert`: `WITH CHECK (has_permission('{resource}', 'edit'))` — only edit can write
- `{table}_perm_update`: `USING (has_permission('{resource}', 'edit'))` — only edit can write
- `{table}_perm_delete`: `USING (has_permission('{resource}', 'edit'))` — only edit can write

Table-to-resource mapping:
| Table | Resource |
|-------|----------|
| qmrl | qmrl |
| qmhq | qmhq |
| qmhq_items | qmhq (child inherits parent) |
| financial_transactions | money_transactions |
| purchase_orders | po |
| po_line_items | po (child inherits parent) |
| invoices | invoice |
| invoice_line_items | invoice (child inherits parent) |
| inventory_transactions | inv_transactions |
| stock_out_requests | sor |
| stock_out_line_items | sor (child inherits parent) |
| items | item |
| warehouses | warehouse |

**SOR approvals (layer-specific):**
`stock_out_approvals` has special handling per CONTEXT.md:
- SELECT: `has_permission('sor_l1', 'view') OR has_permission('sor_l2', 'view') OR has_permission('sor_l3', 'view')` — view on ANY layer lets you see approvals
- INSERT: Must check layer. Since the DB trigger auto-assigns layer based on parent_approval_id, the INSERT policy should allow if user has edit on sor_l1 OR sor_l2 OR sor_l3. The trigger handles which layer is valid.
- UPDATE: Same as INSERT — `has_permission('sor_l1', 'edit') OR has_permission('sor_l2', 'edit') OR has_permission('sor_l3', 'edit')`
- DELETE: `has_permission('admin', 'edit')` — admin only

**Reference/config tables (universally readable, admin-writable):**
For departments, status_config, categories, contact_persons, suppliers, standard_units, system_config (if exists):
- SELECT: `USING (true)` — all authenticated users can read
- INSERT: `WITH CHECK (has_permission('admin', 'edit'))`
- UPDATE: `USING (has_permission('admin', 'edit'))`
- DELETE: `USING (has_permission('admin', 'edit'))`

**Users table — controlled by 'admin' resource:**
- SELECT: `USING (true)` — all authenticated users can read all user rows (required for collaboration features like comments, assignment display)
- INSERT: `WITH CHECK (has_permission('admin', 'edit'))`
- UPDATE: `USING (has_permission('admin', 'edit') OR id = auth.uid())` — admin can update any user, users can update own profile
- DELETE: `USING (has_permission('admin', 'edit'))`

**user_permissions table — admin-only for both read and write (per CONTEXT.md decision):**
- SELECT: `USING (has_permission('admin', 'edit'))` — admin only, users cannot read their own permission rows directly
- INSERT: `WITH CHECK (has_permission('admin', 'edit'))`
- UPDATE: `USING (has_permission('admin', 'edit'))`
- DELETE: `USING (has_permission('admin', 'edit'))`

IMPORTANT: The has_permission() function reads from user_permissions. If the SELECT policy on user_permissions uses has_permission(), you create a circular dependency / infinite recursion. The solution: use a direct subquery instead of has_permission() for user_permissions policies:
```sql
CREATE POLICY user_permissions_perm_select ON public.user_permissions
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.user_permissions up
      WHERE up.user_id = auth.uid()
        AND up.resource = 'admin'
        AND up.level = 'edit'
    )
  );
```
Apply this direct-query pattern to ALL four policies on user_permissions (SELECT, INSERT, UPDATE, DELETE) to avoid recursion through has_permission().

**Audit logs:**
- SELECT: `USING (true)` — all authenticated users can read
- INSERT: `WITH CHECK (true)` — triggers control insert (SECURITY DEFINER)

**File attachments:**
- SELECT: `USING (deleted_at IS NULL)` — all authenticated users can view non-deleted files (file access mirrors parent entity which is enforced at application level)
- INSERT: `WITH CHECK (true)` — all authenticated users can upload (parent entity access checked at application level)
- UPDATE: `USING (has_permission('admin', 'edit') OR uploaded_by = auth.uid())` — admin or original uploader can soft-delete
- DELETE: `USING (has_permission('admin', 'edit'))` — hard delete admin only

**Comments:**
- SELECT: `USING (deleted_at IS NULL)` — all authenticated users can view non-deleted comments
- INSERT: `WITH CHECK (true)` — all authenticated users can comment
- UPDATE: `USING (author_id = auth.uid() AND NOT public.comment_has_replies(id))` — own comments without replies
- DELETE: `USING (has_permission('admin', 'edit'))` — admin hard delete only

**Storage.objects (storage bucket):**
- SELECT: `TO authenticated USING (bucket_id = 'attachments' AND EXISTS (SELECT 1 FROM public.file_attachments fa WHERE fa.storage_path = name AND fa.deleted_at IS NULL))` — download if file exists and not deleted
- INSERT: `TO authenticated WITH CHECK (bucket_id = 'attachments')` — any authenticated user can upload to attachments bucket
- UPDATE: `TO authenticated USING (bucket_id = 'attachments' AND has_permission('admin', 'edit'))` — admin only
- DELETE: `TO authenticated USING (bucket_id = 'attachments' AND has_permission('admin', 'edit'))` — admin only

**SECTION C: Update helper functions**

1. **Update `can_view_sor_request()`** — Replace `get_user_role()` with `has_permission('sor', 'view')`:
```sql
CREATE OR REPLACE FUNCTION public.can_view_sor_request(p_request_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  -- Users with SOR view permission can see all requests
  IF has_permission('sor', 'view') THEN
    RETURN TRUE;
  END IF;
  -- Others can view only their own requests
  RETURN EXISTS (
    SELECT 1 FROM stock_out_requests
    WHERE id = p_request_id AND requester_id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

Note: `can_view_sor_request()` is used by sor_li_select policy. However, since we're now using `has_permission('sor', 'view')` directly for stock_out_line_items SELECT, this function may become unused. Still update it for safety, but the new SOR line items SELECT policy should use `has_permission('sor', 'view')` directly (not this helper).

Also note: `can_view_sor_approval()` was used by sor_approval_select. Update or drop it similarly — the new stock_out_approvals SELECT uses the layer-specific has_permission checks directly.

2. **Update `delete_file_attachment()`** — Replace `role::TEXT` lookup and role string comparisons with permission checks:
```sql
-- Replace v_user_role = 'admin' with:
--   check_user_permission(p_user_id, 'admin') = 'edit'
-- Replace v_user_role = 'qmhq' with:
--   check_user_permission(p_user_id, 'qmhq') = 'edit'
-- Replace v_user_role = 'qmrl' with:
--   check_user_permission(p_user_id, 'qmrl') IN ('edit', 'view')
-- Remove SELECT role::TEXT INTO v_user_role FROM public.users
```

3. **Drop `can_view_sor_approval()`** if it exists — no longer needed, replaced by layer-specific permission checks.

4. **Drop `owns_qmrl()`** if it exists — no longer needed, old own-records pattern removed.

**SECTION D: Drop legacy role infrastructure**

1. Drop `get_user_role()` function
2. Drop `users.role` column
3. Drop `user_role` enum type

Order matters: drop the function first (nothing references it after policy rewrite), then the column, then the enum.

```sql
DROP FUNCTION IF EXISTS public.get_user_role();
ALTER TABLE public.users DROP COLUMN IF EXISTS role;
DROP TYPE IF EXISTS public.user_role;
```

**SECTION E: Verification block**

Add a DO block that:
1. Checks no public functions reference `get_user_role` in their source (pg_proc.prosrc)
2. Checks no policies reference `get_user_role` in their definitions (pg_policies view)
3. Checks the `users.role` column no longer exists
4. RAISEs NOTICE on success or WARNING on issues found

Use `RAISE NOTICE` not `RAISE EXCEPTION` — per CONTEXT.md, no verification block that aborts the transaction.
  </action>
  <verify>
Verify the migration file exists and is syntactically valid:
1. File exists at supabase/migrations/20260221100000_rls_permission_matrix_rewrite.sql
2. File contains BEGIN and COMMIT
3. File contains has_permission references
4. File does NOT reference get_user_role in any CREATE POLICY statement
5. File drops users.role column
6. Count of CREATE POLICY statements should be approximately 100+ (4 policies per ~25 tables)
  </verify>
  <done>
A single migration file exists that:
- Drops all existing RLS policies across all RLS-enabled tables
- Creates fresh permission-matrix-aware policies using has_permission() for every table
- Updates helper functions (can_view_sor_request, delete_file_attachment) to use permission checks instead of role checks
- Drops get_user_role(), users.role column, and user_role enum
- Is wrapped in a transaction for atomicity
- Uses direct subquery (not has_permission) for user_permissions table policies to avoid recursion
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TypeScript types and verify build</name>
  <files>types/database.ts</files>
  <action>
Update `types/database.ts` to reflect the role column removal:

1. Find the `User` type and remove the `role` field (and any `UserRole` type or `user_role` references)
2. Find the `UserInsert` type and remove the `role` field
3. Find the `UserUpdate` type and remove the `role` field
4. Remove the `UserRole` type alias if it exists (it was `'admin' | 'qmrl' | 'qmhq'`)
5. Keep all `PermissionResource`, `PermissionLevel`, `UserPermission` types (added in Phase 59 — they stay)

Then run `npm run type-check` to verify no TypeScript files reference the removed `role` field. If there are type errors:
- Search for `user.role`, `currentUser?.role`, `get_user_role`, `UserRole` in the codebase
- For any file that reads `user.role`, replace with the appropriate permission check pattern. However, do NOT refactor frontend permission logic here — that is Phase 62's job. If frontend files reference `user.role`, comment out or use a temporary compatibility approach:
  - If the reference is in a type import only, just remove the import
  - If the reference is in runtime code checking `role === 'admin'`, this MUST be fixed for the build to pass. Replace with a TODO comment and a fallback that doesn't break the build (e.g., default to false with `// TODO Phase 62: replace with permission check`)

Run `npm run type-check` and `npm run lint` to confirm the build passes.
  </action>
  <verify>
Run:
- `npm run type-check` — must pass with zero errors
- `npm run lint` — must pass
- `grep -r "user_role\|UserRole\|get_user_role\|\.role" types/database.ts` — should return no role-related matches (only permission types remain)
  </verify>
  <done>
TypeScript types updated: User/UserInsert/UserUpdate types no longer have a `role` field, `UserRole` type removed, build passes with `npm run type-check` and `npm run lint`.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/20260221100000_rls_permission_matrix_rewrite.sql`
2. Migration is wrapped in BEGIN/COMMIT transaction
3. All CREATE POLICY statements use `has_permission()` (except user_permissions which uses direct subquery, and audit_logs/file_attachments/comments which use `true` or specific non-role conditions)
4. No CREATE POLICY references `get_user_role()`
5. Migration drops `get_user_role()` function, `users.role` column, and `user_role` enum
6. `npm run type-check` passes
7. `npm run lint` passes
8. TypeScript User type no longer has `role` field
</verification>

<success_criteria>
- Every RLS-enabled table has fresh permission-matrix-aware policies
- has_permission() is the sole authorization gate (no get_user_role() references remain)
- The legacy role column, enum, and function are dropped
- TypeScript types compile cleanly without role references
- Helper functions (can_view_sor_request, delete_file_attachment) use permission checks
</success_criteria>

<output>
After completion, create `.planning/phases/60-rls-policy-rewrite/60-01-SUMMARY.md`
</output>
