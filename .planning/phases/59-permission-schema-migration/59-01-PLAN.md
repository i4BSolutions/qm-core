---
phase: 59-permission-schema-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260221000000_permission_schema.sql
  - supabase/migrations/20260221000001_permission_data_migration.sql
  - types/database.ts
autonomous: true
requirements:
  - PERM-01
  - PERM-10

must_haves:
  truths:
    - "A user_permissions table exists with one row per user per resource (16 resources x N users)"
    - "Every existing user has exactly 16 permission rows migrated from their old role"
    - "Admin-role users have Edit on all 16 resources"
    - "QMRL-role users have Edit/View/Block mapped per CONTEXT.md specification"
    - "QMHQ-role users have Edit/View/Block mapped per CONTEXT.md specification"
    - "New users created via auth trigger get 16 Block permission rows by default"
    - "The 16 resource identifiers are enforced by a CHECK constraint or enum"
    - "A helper function exists to check a user's permission level for a given resource"
  artifacts:
    - path: "supabase/migrations/20260221000000_permission_schema.sql"
      provides: "user_permissions table, resource enum/constraint, access level enum/constraint, helper functions"
      contains: "user_permissions"
    - path: "supabase/migrations/20260221000001_permission_data_migration.sql"
      provides: "Backfill of all existing users with 16 permission rows each, based on their current role"
      contains: "INSERT INTO public.user_permissions"
    - path: "types/database.ts"
      provides: "TypeScript types for user_permissions table and enums"
      contains: "UserPermission"
  key_links:
    - from: "supabase/migrations/20260221000001_permission_data_migration.sql"
      to: "users.role"
      via: "Role-to-permission mapping query"
      pattern: "CASE.*role.*WHEN.*admin.*WHEN.*qmrl.*WHEN.*qmhq"
    - from: "supabase/migrations/20260221000000_permission_schema.sql"
      to: "handle_new_user()"
      via: "Updated trigger that inserts 16 Block rows for new signups"
      pattern: "INSERT INTO public.user_permissions"
---

<objective>
Create the permission matrix database schema and migrate all existing users from the 3-role system to per-user per-resource permissions.

Purpose: This is the foundation for the entire v1.13 permission system. Phase 60 (RLS rewrite), Phase 61 (management UI), and Phase 62 (frontend enforcement) all depend on this table existing with data.

Output: Two SQL migrations (schema + data backfill), updated TypeScript types, and helper functions for permission checking.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/59-permission-schema-migration/59-CONTEXT.md

Key existing files to reference:
@supabase/migrations/20260211120000_rbac_enum_migration.sql (current 3-role enum: admin, qmrl, qmhq)
@supabase/migrations/002_users.sql (users table structure, get_user_role() and has_role() functions)
@lib/hooks/use-permissions.ts (current frontend permission matrix — shows resource mapping)
@types/database.ts (TypeScript types, UserRole type at line ~2256)
@app/api/admin/invite-user/route.ts (user creation flow that sets role)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create permission schema migration with table, enums, constraints, and helper functions</name>
  <files>supabase/migrations/20260221000000_permission_schema.sql</files>
  <action>
Create a single atomic migration that establishes the permission matrix schema.

**1. Create resource identifier enum:**
```sql
CREATE TYPE public.permission_resource AS ENUM (
  'system_dashboard',
  'qmrl',
  'qmhq',
  'money_transactions',
  'inv_transactions',
  'po',
  'invoice',
  'stock_in',
  'sor',
  'sor_l1',
  'sor_l2',
  'sor_l3',
  'warehouse',
  'inventory_dashboard',
  'item',
  'admin'
);
```

**2. Create access level enum:**
```sql
CREATE TYPE public.permission_level AS ENUM ('edit', 'view', 'block');
```

**3. Create user_permissions table:**
```sql
CREATE TABLE public.user_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  resource public.permission_resource NOT NULL,
  level public.permission_level NOT NULL DEFAULT 'block',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, resource)
);
```

- Composite unique on (user_id, resource) ensures one row per user per resource.
- ON DELETE CASCADE so when a user is deleted, permissions are cleaned up.
- Default level is 'block' (fail closed).

**4. Add indexes:**
- `CREATE INDEX idx_user_permissions_user ON public.user_permissions(user_id);`
- `CREATE INDEX idx_user_permissions_resource ON public.user_permissions(resource);`
- `CREATE INDEX idx_user_permissions_user_resource ON public.user_permissions(user_id, resource);` (covers common lookup pattern)

**5. Add updated_at trigger:**
```sql
CREATE TRIGGER trg_user_permissions_updated_at
  BEFORE UPDATE ON public.user_permissions
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();
```

**6. Create helper function `check_user_permission()`:**
```sql
CREATE OR REPLACE FUNCTION public.check_user_permission(
  p_user_id UUID,
  p_resource public.permission_resource
)
RETURNS public.permission_level AS $$
DECLARE
  result public.permission_level;
BEGIN
  SELECT level INTO result
  FROM public.user_permissions
  WHERE user_id = p_user_id AND resource = p_resource;

  -- Missing row = block (fail closed)
  RETURN COALESCE(result, 'block');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

**7. Create helper function `has_permission()` for RLS use (Phase 60 will call this):**
```sql
CREATE OR REPLACE FUNCTION public.has_permission(
  p_resource public.permission_resource,
  p_level public.permission_level
)
RETURNS BOOLEAN AS $$
DECLARE
  user_level public.permission_level;
BEGIN
  SELECT level INTO user_level
  FROM public.user_permissions
  WHERE user_id = auth.uid() AND resource = p_resource;

  -- Missing row = block
  IF user_level IS NULL THEN
    RETURN false;
  END IF;

  -- 'edit' grants everything, 'view' grants view only, 'block' grants nothing
  IF p_level = 'block' THEN
    -- Checking for block: user IS blocked if level = 'block' or missing
    RETURN user_level = 'block';
  ELSIF p_level = 'view' THEN
    -- Checking for view: user has view if level is 'view' or 'edit'
    RETURN user_level IN ('view', 'edit');
  ELSIF p_level = 'edit' THEN
    -- Checking for edit: user must have 'edit'
    RETURN user_level = 'edit';
  END IF;

  RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

**8. Create trigger function to ensure exactly 16 rows per user:**
```sql
CREATE OR REPLACE FUNCTION public.ensure_complete_permissions()
RETURNS TRIGGER AS $$
DECLARE
  permission_count INTEGER;
  resource_count INTEGER;
BEGIN
  -- Count total enum values
  SELECT COUNT(*) INTO resource_count
  FROM unnest(enum_range(NULL::public.permission_resource));

  -- Count user's permissions
  SELECT COUNT(*) INTO permission_count
  FROM public.user_permissions
  WHERE user_id = NEW.user_id;

  -- This is a validation check, not enforcement
  -- Actual insertion of 16 rows happens in the application or migration
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

Actually, skip the validation trigger — it complicates row-by-row inserts. Instead, use a simpler approach: create a function `create_default_permissions(p_user_id UUID)` that inserts all 16 resource rows with 'block' level:

```sql
CREATE OR REPLACE FUNCTION public.create_default_permissions(p_user_id UUID)
RETURNS VOID AS $$
BEGIN
  INSERT INTO public.user_permissions (user_id, resource, level)
  SELECT p_user_id, r, 'block'::public.permission_level
  FROM unnest(enum_range(NULL::public.permission_resource)) AS r
  ON CONFLICT (user_id, resource) DO NOTHING;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**9. Update `handle_new_user()` to also create default permissions:**

Replace the existing function so that when a new auth.users row is created, it:
1. Inserts the users row (as before, with role = 'qmrl' for backward compat until role column is dropped)
2. Calls `create_default_permissions(NEW.id)` to insert 16 Block rows

```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email, full_name, role)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
    'qmrl'
  );

  -- Create default permissions (all Block — admin must explicitly grant)
  PERFORM public.create_default_permissions(NEW.id);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**10. Add RLS policies for user_permissions table itself:**
- Enable RLS on user_permissions.
- Admin can do everything (checked via `get_user_role() = 'admin'` for now, will be updated to permission-based in Phase 60).
- Non-admin users can SELECT their own rows only (`user_id = auth.uid()`).
- No insert/update/delete for non-admins.

```sql
ALTER TABLE public.user_permissions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "admin_full_access_permissions" ON public.user_permissions
  FOR ALL USING (public.get_user_role() = 'admin');

CREATE POLICY "users_read_own_permissions" ON public.user_permissions
  FOR SELECT USING (user_id = auth.uid());
```

**11. Add table and column comments.**

**IMPORTANT — Do NOT drop the `role` column.** The 100+ existing RLS policies use `get_user_role()` which reads `users.role`. Dropping it now would break all authorization. Phase 60 will rewrite RLS policies to use `has_permission()` and then drop the role column.

**IMPORTANT — Do NOT update `has_role()` or `get_user_role()`.** These functions still work and are needed by existing RLS policies until Phase 60 rewrites them.

Wrap the entire migration in a transaction (BEGIN/COMMIT).
  </action>
  <verify>
Run `npx supabase db reset` locally (or apply the migration). Verify:
1. `\d public.user_permissions` shows the table with correct columns and constraints
2. `SELECT * FROM pg_type WHERE typname IN ('permission_resource', 'permission_level')` confirms both enum types exist
3. `SELECT public.create_default_permissions('{some-user-id}')` successfully inserts 16 rows
4. `SELECT COUNT(DISTINCT resource) FROM public.user_permissions WHERE user_id = '{some-user-id}'` returns 16
5. The unique constraint on (user_id, resource) prevents duplicates
  </verify>
  <done>
The user_permissions table exists with (user_id, resource, level) structure, both enum types are created, helper functions check_user_permission() and has_permission() are available for Phase 60, create_default_permissions() inserts 16 Block rows, handle_new_user() trigger creates permissions for new signups, and RLS on the table itself restricts non-admin access to own rows only.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate existing users to permission matrix and update TypeScript types</name>
  <files>
    supabase/migrations/20260221000001_permission_data_migration.sql
    types/database.ts
  </files>
  <action>
**Part A: Data migration (SQL)**

Create a migration that backfills all existing users with 16 permission rows based on their current `role` value.

**Role mapping (from 59-CONTEXT.md decisions):**

**admin role** → Edit on all 16 resources:
- system_dashboard: edit
- qmrl: edit
- qmhq: edit
- money_transactions: edit
- inv_transactions: edit
- po: edit
- invoice: edit
- stock_in: edit
- sor: edit
- sor_l1: edit
- sor_l2: edit
- sor_l3: edit
- warehouse: edit
- inventory_dashboard: edit
- item: edit
- admin: edit

**qmrl role** → Edit on QMRL, QMHQ, Dashboard. View on PO, Invoice, Item, Warehouse. Block on rest:
- system_dashboard: edit
- qmrl: edit
- qmhq: edit
- money_transactions: block
- inv_transactions: block
- po: view
- invoice: view
- stock_in: block
- sor: block
- sor_l1: block
- sor_l2: block
- sor_l3: block
- warehouse: view
- inventory_dashboard: block
- item: view
- admin: block

**qmhq role** → Edit on QMHQ, PO, Invoice, Money Txns, Stock In, Inv Txns, SOR, SOR-L1/L2/L3, Item, Warehouse, Inv Dashboard. View on QMRL, Dashboard. Block on Admin:
- system_dashboard: view
- qmrl: view
- qmhq: edit
- money_transactions: edit
- inv_transactions: edit
- po: edit
- invoice: edit
- stock_in: edit
- sor: edit
- sor_l1: edit
- sor_l2: edit
- sor_l3: edit
- warehouse: edit
- inventory_dashboard: edit
- item: edit
- admin: block

**Unknown/NULL role** → View on system_dashboard only, Block on everything else.

The migration should:

1. Wrap in BEGIN/COMMIT.
2. For each existing user (SELECT id, role FROM public.users WHERE is_active = true), insert 16 permission rows using the mapping above.
3. Also handle inactive users — they still need permission rows for data integrity, but all set to Block.
4. Use INSERT ... ON CONFLICT DO NOTHING to be idempotent (safe to re-run).
5. Validate after insertion:
   - Count total permission rows = (total users) * 16
   - If mismatch, RAISE EXCEPTION to abort transaction
6. Insert an audit_logs entry recording the migration event.

Use a CTE-based approach for clarity:

```sql
WITH role_permissions AS (
  -- Define the complete mapping as a VALUES list
  SELECT * FROM (VALUES
    ('admin'::public.user_role, 'system_dashboard'::public.permission_resource, 'edit'::public.permission_level),
    ('admin', 'qmrl', 'edit'),
    -- ... all 48 rows (3 roles x 16 resources)
    ('qmhq', 'admin', 'block')
  ) AS t(role, resource, level)
)
INSERT INTO public.user_permissions (user_id, resource, level)
SELECT u.id, rp.resource, rp.level
FROM public.users u
JOIN role_permissions rp ON u.role = rp.role
WHERE u.is_active = true
ON CONFLICT (user_id, resource) DO NOTHING;
```

For inactive users:
```sql
INSERT INTO public.user_permissions (user_id, resource, level)
SELECT u.id, r, 'block'::public.permission_level
FROM public.users u
CROSS JOIN unnest(enum_range(NULL::public.permission_resource)) AS r
WHERE u.is_active = false
ON CONFLICT (user_id, resource) DO NOTHING;
```

For users with NULL or unexpected role values (the fallback):
```sql
INSERT INTO public.user_permissions (user_id, resource, level)
SELECT u.id, r,
  CASE WHEN r = 'system_dashboard' THEN 'view'::public.permission_level
       ELSE 'block'::public.permission_level
  END
FROM public.users u
CROSS JOIN unnest(enum_range(NULL::public.permission_resource)) AS r
WHERE u.role IS NULL OR u.role NOT IN ('admin', 'qmrl', 'qmhq')
ON CONFLICT (user_id, resource) DO NOTHING;
```

End with a validation block:
```sql
DO $$
DECLARE
  user_count INTEGER;
  perm_count INTEGER;
  expected INTEGER;
BEGIN
  SELECT COUNT(*) INTO user_count FROM public.users;
  SELECT COUNT(*) INTO perm_count FROM public.user_permissions;
  expected := user_count * 16;

  IF perm_count < expected THEN
    RAISE EXCEPTION 'Permission migration incomplete: expected %, got %', expected, perm_count;
  END IF;
END $$;
```

**Part B: TypeScript types update**

Read the existing `types/database.ts` file and add the following types after the existing type definitions:

1. Add new enum types (these will be auto-generated by `npx supabase gen types typescript` in production, but we need them now):

```typescript
// Permission system types
export type PermissionResource =
  | 'system_dashboard'
  | 'qmrl'
  | 'qmhq'
  | 'money_transactions'
  | 'inv_transactions'
  | 'po'
  | 'invoice'
  | 'stock_in'
  | 'sor'
  | 'sor_l1'
  | 'sor_l2'
  | 'sor_l3'
  | 'warehouse'
  | 'inventory_dashboard'
  | 'item'
  | 'admin';

export type PermissionLevel = 'edit' | 'view' | 'block';

export interface UserPermission {
  id: string;
  user_id: string;
  resource: PermissionResource;
  level: PermissionLevel;
  created_at: string;
  updated_at: string;
}

export type UserPermissionInsert = Omit<UserPermission, 'id' | 'created_at' | 'updated_at'>;
export type UserPermissionUpdate = Partial<Pick<UserPermission, 'level'>>;
```

2. Add a constant array of all 16 resources (for iteration in UI code in Phase 61):

```typescript
export const PERMISSION_RESOURCES: PermissionResource[] = [
  'system_dashboard',
  'qmrl',
  'qmhq',
  'money_transactions',
  'inv_transactions',
  'po',
  'invoice',
  'stock_in',
  'sor',
  'sor_l1',
  'sor_l2',
  'sor_l3',
  'warehouse',
  'inventory_dashboard',
  'item',
  'admin',
] as const;
```

3. Add a display name mapping:

```typescript
export const PERMISSION_RESOURCE_LABELS: Record<PermissionResource, string> = {
  system_dashboard: 'System Dashboard',
  qmrl: 'QMRL',
  qmhq: 'QMHQ',
  money_transactions: 'Money Transactions',
  inv_transactions: 'Inv Transactions',
  po: 'Purchase Orders',
  invoice: 'Invoices',
  stock_in: 'Stock In',
  sor: 'Stock-Out Requests',
  sor_l1: 'SOR Approval L1',
  sor_l2: 'SOR Approval L2',
  sor_l3: 'SOR Approval L3',
  warehouse: 'Warehouses',
  inventory_dashboard: 'Inventory Dashboard',
  item: 'Items',
  admin: 'Admin',
};

export const PERMISSION_LEVEL_LABELS: Record<PermissionLevel, string> = {
  edit: 'Edit',
  view: 'View',
  block: 'Block',
};
```

Place these additions AFTER the existing enum types section (around line 2270) and BEFORE the closing sections of the file. Keep all existing types intact — this is purely additive.
  </action>
  <verify>
For the SQL migration:
1. Run `npx supabase db reset` to apply all migrations including the new ones.
2. Verify: `SELECT COUNT(*) FROM public.user_permissions` returns (number of users) * 16.
3. Verify admin mapping: `SELECT resource, level FROM public.user_permissions WHERE user_id = (SELECT id FROM users WHERE role = 'admin' LIMIT 1) ORDER BY resource;` — all should be 'edit'.
4. Verify qmrl mapping: spot-check that qmrl user has 'edit' on qmrl, 'view' on po, 'block' on admin.
5. Verify qmhq mapping: spot-check that qmhq user has 'edit' on qmhq, 'view' on qmrl, 'block' on admin.

For TypeScript types:
1. Run `npm run type-check` — should pass with no errors.
2. Verify the new types are importable: `PermissionResource`, `PermissionLevel`, `UserPermission`, `PERMISSION_RESOURCES`, `PERMISSION_RESOURCE_LABELS`.
  </verify>
  <done>
Every existing user (active and inactive) has exactly 16 permission rows in user_permissions. Admin users have Edit on all 16 resources. QMRL users have the scoped permissions from CONTEXT.md. QMHQ users have the scoped permissions from CONTEXT.md. TypeScript types for UserPermission, PermissionResource, PermissionLevel, and display-name constants are available for downstream phases. `npm run type-check` passes.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Schema verification:**
   - `\d public.user_permissions` shows table with columns: id, user_id, resource, level, created_at, updated_at
   - Unique constraint on (user_id, resource) exists
   - Foreign key to users(id) with CASCADE exists

2. **Enum verification:**
   - `SELECT enum_range(NULL::public.permission_resource)` returns all 16 values
   - `SELECT enum_range(NULL::public.permission_level)` returns {edit,view,block}

3. **Data completeness:**
   - `SELECT COUNT(*) FROM public.user_permissions` = (SELECT COUNT(*) FROM public.users) * 16
   - No user has fewer or more than 16 permission rows

4. **Mapping correctness:**
   - Admin role users: all 16 resources = 'edit'
   - QMRL role users: qmrl/qmhq/system_dashboard = 'edit', po/invoice/item/warehouse = 'view', rest = 'block'
   - QMHQ role users: admin = 'block', qmrl/system_dashboard = 'view', rest = 'edit'

5. **Helper functions:**
   - `SELECT public.check_user_permission('{admin-user-id}', 'qmrl')` returns 'edit'
   - `SELECT public.has_permission('qmrl', 'edit')` returns true for admin user (when called with admin's auth.uid)

6. **Backward compatibility:**
   - `users.role` column still exists (NOT dropped)
   - `get_user_role()` still works
   - All existing RLS policies still function
   - `npm run build` succeeds
   - `npm run type-check` passes

7. **New user path:**
   - Trigger `handle_new_user()` still fires on auth.users insert
   - New users get 16 Block permission rows automatically
</verification>

<success_criteria>
- user_permissions table exists with correct schema
- All existing users have exactly 16 permission rows each
- Permission mappings match CONTEXT.md role specifications
- Helper functions check_user_permission() and has_permission() are available
- New user creation automatically gets 16 Block permissions
- Existing role column and functions are preserved (backward compatible)
- TypeScript types are available for downstream phases
- npm run build and npm run type-check pass
</success_criteria>

<output>
After completion, create `.planning/phases/59-permission-schema-migration/59-01-SUMMARY.md`
</output>
