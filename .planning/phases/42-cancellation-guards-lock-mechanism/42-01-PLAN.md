---
phase: 42-cancellation-guards-lock-mechanism
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260212210000_po_cancel_guard_and_unlock.sql
  - lib/actions/po-actions.ts
  - lib/actions/invoice-actions.ts
  - lib/utils/po-status.ts
autonomous: true

must_haves:
  truths:
    - "Database blocks PO cancellation when active non-voided invoices exist"
    - "Admin can unlock a closed PO via Server Action, returning it to a non-closed status"
    - "PO cancel toast shows simple message without cascade details"
    - "Invoice void toast shows simple message without cascade details"
  artifacts:
    - path: "supabase/migrations/20260212210000_po_cancel_guard_and_unlock.sql"
      provides: "Guard trigger for PO cancellation + unlock function"
      contains: "aa_block_po_cancel_with_invoices"
    - path: "lib/actions/po-actions.ts"
      provides: "unlockClosedPO Server Action + simplified cancelPO toast data"
      exports: ["cancelPO", "CancelPOResult", "unlockClosedPO", "UnlockPOResult"]
    - path: "lib/actions/invoice-actions.ts"
      provides: "Simplified voidInvoice return data"
      exports: ["voidInvoice", "VoidInvoiceResult"]
    - path: "lib/utils/po-status.ts"
      provides: "canUnlockPO utility function"
      exports: ["canUnlockPO"]
  key_links:
    - from: "supabase/migrations/20260212210000_po_cancel_guard_and_unlock.sql"
      to: "purchase_orders table"
      via: "BEFORE UPDATE trigger"
      pattern: "aa_block_po_cancel_with_invoices"
    - from: "lib/actions/po-actions.ts"
      to: "purchase_orders table"
      via: "supabase update query"
      pattern: "unlockClosedPO"
---

<objective>
Add database-level guard trigger for PO cancellation, create admin unlock Server Action for closed POs, and simplify cascade toast messages to simple confirmations per user decision.

Purpose: Establish the database safety net and Server Action infrastructure that UI plans will consume.
Output: Migration file with guard trigger, updated Server Actions with simplified feedback, new unlock capability.
</objective>

<execution_context>
@/home/yaungni/.claude/get-shit-done/workflows/execute-plan.md
@/home/yaungni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-cancellation-guards-lock-mechanism/42-RESEARCH.md
@.planning/phases/41-po-status-engine-enhancement/41-01-SUMMARY.md
@supabase/migrations/040_invoice_void_block_stockin.sql
@lib/actions/po-actions.ts
@lib/actions/invoice-actions.ts
@lib/utils/po-status.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database guard trigger for PO cancellation + unlock function</name>
  <files>supabase/migrations/20260212210000_po_cancel_guard_and_unlock.sql</files>
  <action>
Create migration file with two components:

**1. Guard trigger: aa_block_po_cancel_with_invoices**

Follow the exact pattern from migration 040 (aa_block_invoice_void_stockin):
- Create function `aa_block_po_cancel_with_invoices()` as BEFORE UPDATE trigger
- Check: IF NEW.status = 'cancelled' AND OLD.status != 'cancelled'
- Query: SELECT EXISTS from invoices WHERE po_id = NEW.id AND is_active = true AND (is_voided = false OR is_voided IS NULL)
- If exists: RAISE EXCEPTION 'Cannot cancel PO: active invoices exist'
- Use `aa_` prefix on trigger name to fire FIRST among BEFORE UPDATE triggers
- Add partial index on invoices(po_id) WHERE is_active = true AND (is_voided = false OR is_voided IS NULL) for efficient lookup
- Add COMMENT ON FUNCTION and COMMENT ON TRIGGER

**2. Guard trigger: aa_block_closed_po_update**

Block non-admin modifications to closed POs at database level:
- Create function `aa_block_closed_po_update()` as BEFORE UPDATE trigger
- Check: IF OLD.status = 'closed' AND NEW.status != 'cancelled'
  - Allow status changes (the unlock mechanism and cancel bypass this by nature)
  - Block if non-status fields are modified while status remains 'closed'
  - Actually, this is tricky to enforce at DB level without knowing user role.
  - SKIP this DB-level enforcement. The UI layer (Plan 02) handles read-only enforcement by hiding Edit buttons. The Server Actions already validate permissions. DB-level closed-PO protection would require passing user context into triggers which is complex and fragile. UI + Server Action layer is sufficient per existing codebase patterns.

**3. Unlock support: No special DB function needed**

The unlock mechanism works by updating purchase_orders.status from 'closed' to a recalculated status. The existing calculate_po_status() function handles this. The Server Action (Task 2) will call it directly. No migration needed for unlock itself.

So the migration contains ONLY the PO cancel guard trigger + index.

Add standard migration header comment block following migration 040 style.
  </action>
  <verify>
Review SQL syntax. Verify trigger uses `aa_` prefix. Verify EXISTS query excludes voided invoices (is_voided = false OR is_voided IS NULL). Run `npm run type-check` (migration is SQL, but ensures no TS breakage).
  </verify>
  <done>
Migration file exists with aa_block_po_cancel_with_invoices guard trigger that blocks PO cancellation when active non-voided invoices exist, following the exact pattern from migration 040.
  </done>
</task>

<task type="auto">
  <name>Task 2: Server Actions -- unlockClosedPO + simplify cascade toasts</name>
  <files>lib/actions/po-actions.ts, lib/actions/invoice-actions.ts, lib/utils/po-status.ts</files>
  <action>
**A. Add unlockClosedPO Server Action to lib/actions/po-actions.ts:**

Create a new exported async function `unlockClosedPO(poId: string)` that:
1. Validates user authentication
2. Validates admin role (check user.role === 'admin' from users table lookup)
3. Fetches current PO -- guards: must exist, must have status = 'closed'
4. Fetches line items to calculate aggregates (totalQty, invoicedQty, receivedQty)
5. Uses `recomputeStatusFromAggregates()` from po-status.ts to determine the correct non-closed status. NOTE: If the aggregates still indicate closed (all fully matched), set status to 'partially_received' as a fallback to allow the admin to make corrections. The status will auto-recalculate back to 'closed' after corrections via the existing trigger.
6. Updates purchase_orders SET status = computed_status WHERE id = poId
7. Creates audit log entry: entity_type='purchase_orders', entity_id=poId, action='update', summary='PO unlocked by admin for corrections'
8. Revalidates /po and /po/[id] paths
9. Returns UnlockPOResult (success with newStatus, or error)

Define type:
```typescript
export type UnlockPOResult =
  | { success: true; data: { poNumber: string; newStatus: string } }
  | { success: false; error: string };
```

**B. Simplify cancelPO toast data in lib/actions/po-actions.ts:**

The existing cancelPO already returns detailed cascade data (releasedAmountEusd, newBalanceInHand, qmhqRequestId). Per user decision: "Simple toast, no detailed cascade info in toast." However, the Server Action return data is fine as-is -- the UI layer (Plan 02) will simply use a simpler toast message. No changes needed to the Server Action return type -- keep it for potential future use. The toast simplification happens in the UI layer.

Actually, leave cancelPO completely unchanged. The UI will just display a simpler message.

**C. Simplify voidInvoice toast data in lib/actions/invoice-actions.ts:**

Same as above -- leave the Server Action return type unchanged. The UI layer will display simpler toast. No changes to invoice-actions.ts needed.

**D. Add canUnlockPO utility to lib/utils/po-status.ts:**

```typescript
export function canUnlockPO(status: POStatusEnum): boolean {
  return status === 'closed';
}
```

This is a simple predicate used by the UI layer for conditional rendering.

So the actual changes are:
1. Add `unlockClosedPO` function + `UnlockPOResult` type to lib/actions/po-actions.ts
2. Add `canUnlockPO` function to lib/utils/po-status.ts
3. No changes to invoice-actions.ts (toast simplification is UI-layer concern)
  </action>
  <verify>
Run `npm run type-check` to verify TypeScript compilation. Run `npm run lint` to verify no lint errors. Verify `unlockClosedPO` is exported from po-actions.ts. Verify `canUnlockPO` is exported from po-status.ts.
  </verify>
  <done>
unlockClosedPO Server Action exists with admin validation, status recalculation, and audit logging. canUnlockPO utility exists. All type checks pass.
  </done>
</task>

</tasks>

<verification>
1. Migration SQL is syntactically valid with proper trigger naming (aa_ prefix)
2. Guard trigger correctly excludes voided invoices from dependency check
3. unlockClosedPO validates admin role before allowing unlock
4. unlockClosedPO recalculates status using existing recomputeStatusFromAggregates logic
5. All TypeScript compilation passes (npm run type-check)
6. All linting passes (npm run lint)
</verification>

<success_criteria>
- Database guard trigger blocks PO cancellation when active invoices exist
- Admin can unlock closed PO via Server Action
- PO status recalculates to non-closed state after unlock
- Audit log entry created for unlock action
- No TypeScript or lint errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/42-cancellation-guards-lock-mechanism/42-01-SUMMARY.md`
</output>
